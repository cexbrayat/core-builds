{"version":3,"sources":["../../../../node_modules/tslib/tslib.es6.js","../../../packages/core/esm5/testing/src/async_fallback.js","../../../packages/core/esm5/testing/src/component_fixture.js","../../../packages/core/esm5/testing/src/fake_async_fallback.js","../../../packages/core/esm5/testing/src/fake_async.js","../../../packages/core/esm5/testing/src/async_test_completer.js","../../../packages/core/esm5/testing/src/metadata_overrider.js","../../../packages/core/esm5/testing/src/r3_test_bed.js","../../../packages/core/esm5/testing/src/resolvers.js","../../../packages/core/esm5/testing/src/test_bed_common.js","../../../packages/core/esm5/testing/src/test_compiler.js","../../../packages/core/esm5/testing/src/test_bed.js","../../../packages/core/esm5/testing/src/before_each.js","../../../packages/core/esm5/testing/src/async.js"],"names":["exports","module","factory","require","extendStatics","d","b","__proto__","Array","p","hasOwnProperty","prototype","Object","create","__","__decorate","decorators","target","key","desc","fn","context","finishCallback","failCallback","currentZone","Zone","current","AsyncTestZoneSpec","undefined","Error","ProxyZoneSpec","proxyZoneSpec","get","assertPresent","getZoneWith","getDelegate","run","testZoneSpec","error","setDelegate","previousDelegate","ComponentFixture","componentRef","ngZone","_autoDetect","_this","this","_isStable","_isDestroyed","_resolve","_promise","_onUnstableSubscription","_onStableSubscription","getDebugNode","_onMicrotaskEmptySubscription","_onErrorSubscription","changeDetectorRef","elementRef","location","debugElement","_angular_core","nativeElement","onMicrotaskEmpty","subscribe","detectChanges","hasPendingMacrotasks","onError","next","_tick","checkNoChanges","autoDetectChanges","autoDetect","whenStable","isStable","Promise","resolve","res","_getRenderer","_renderer","whenRenderingDone","renderer","destroy","unsubscribe","resetFakeAsyncZoneFallback","_getFakeAsyncZoneSpec","resetFakeAsyncZone","fakeAsyncTestModule","AsyncTestCompleter","rej","_reject","done","value","fail","stackTrace","defineProperty","overrideMetadata","metadataClass","oldMetadata","override","props","obj","prop","startsWith","push","getPrototypeOf","proto","keys","forEach","protoProp","getOwnPropertyDescriptor","set","remove","add","ɵstringify","metadata","setMetadata","references","Set","removeValue","removeObjects","_propHashKey","propValue","filter","has","_loop_2","removeMetadata","_references","concat","addValue","addMetadata","MetadataOverrider","propName","stringify","ref","id","_nextReferenceId","_serializeReference","testBed$1","reflection","ɵReflectionCapabilities","OverrideResolver","overrides","Map","resolved","setOverrides","clear","_a","type","getAnnotation","annotations","find","a","tslib_1.__extends","DirectiveResolver","_super","apply","arguments","Directive","enumerable","ComponentResolver","Component","PipeResolver","Pipe","NgModuleResolver","NgModule","TestComponentRenderer","TestBedRender3","platform","ngModule","_moduleOverrides","_directiveOverrides","_pipeOverrides","_providerOverrides","_rootProviderOverrides","_providers","_declarations","_imports","compileComponents","_getTestBedRender3","overrideModule","overrideComponent","component","overrideDirective","directive","overridePipe","pipe","overrideTemplateUsingTestingModule","template","overrideProvider","token","provider","deprecatedOverrideProvider","notFoundValue","Injector","THROW_IF_NOT_FOUND","createComponent","initTestEnvironment","aotSummaries","resetTestEnvironment","resetTestingModule","_moduleRef","_instantiated","fixture","e","console","componentInstance","stacktrace","_activeFixtures","configureCompiler","config","configureTestingModule","moduleDef","_b","_c","_d","_assertNotInstantiated","providers","declarations","imports","schemas","_schemas","_initIfNeeded","injector","execute","tokens","params","map","t","_componentOverrides","ngInjectableDef","providedIn","useFactory","provide","deps","useValue","testComponentRenderer","rootElId","_nextRootElementId$1","insertRootElement","ComponentFactory","componentDef","ngComponentDef","ɵRender3ComponentFactory","NULL","resolvers","_getResolvers","testModuleType","_createTestModule","parentInjector","ɵRender3NgModuleRef","methodName","methodDescription","rootProviderOverrides","rendererFactoryWrapper","ɵWRAP_RENDERER_FACTORY2","tslib_1.__decorate","rf","ɵRender3DebugRendererFactory2","RootScopeModule","jit","DynamicTestModule","compileNgModuleDefs","moduleType","ɵcompileNgModuleDefs","flatten","values","isArray","out","EMPTY_ARRAY","declaration","ɵcompileComponent","compileDirective","compilePipe","ɵcompilePipe","transitiveScopesFor","isNgModule","name","def","ngModuleDef","transitiveCompileScopes","scopes","directives","pipes","exported","declared","declaredWithDefs","ngPipeDef","compilation","imported","compileNgModule","importedScope","exportedTyped","exportedScope","entry","TestingCompiler","unimplemented","configurable","getComponentFactory","Compiler","getComponentFromError","TestBedViewEngine","_compiler","_moduleFactory","_compilerOptions","_testEnvAotSummaries","_aotSummaries","_templateOverrides","getTestBed","_getTestBedViewEngine","clearOverrides","ɵclearOverrides","_isRoot","_createCompilerAndModule","compileModuleAndAllComponentsAsync","then","moduleAndComponentFactories","ngModuleFactory","compileModuleAndAllComponentsSync","errorCompType","_i","NgZone","length","templateOf","compFactory","ɵoverrideComponentView","enableLongStackTrace","ngZoneInjector","ApplicationInitStatus","runInitializers","TestBed","slice","rootScopeImports","ɵAPP_ROOT","compilerFactory","TestingCompilerFactory","createTestingCompiler","summary","loadAotSummaries","result","UNDEFINED","overrideProviderImpl","deprecated","flags","Optional","dep","SkipSelf","depFlags","depToken","ɵoverrideProvider","deprecatedBehavior","OverrideComponent","selector","componentFactory","noNgZone","ComponentFixtureNoNgZone","ComponentFixtureAutoDetect","_nextRootElementId","initComponent","testBed","completer","InjectSetupWrapper","_moduleDef","_addModule","inject","self","call","window","global","_global$1","beforeEach","_Zone","reject","asyncTest","err","runInTestZone","fakeAsync","args","_inFakeAsyncCall","_fakeAsyncTestZoneSpec","FakeAsyncTestZoneSpec","lastProxyZoneSpec","flushMicrotasksFallback","pendingPeriodicTimers","pendingTimers","millis","tick","maxTurns","flush","discardPeriodicTasks","flushMicrotasks"],"mappings":"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","file":"/Users/ced-pro/Code/angular/angular/dist/packages-dist/core/bundles/core-testing.umd.min.js.map","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar _global = (typeof window === 'undefined' ? global : window);\n/**\n * Wraps a test function in an asynchronous test zone. The test will automatically\n * complete when all asynchronous calls within this zone are done. Can be used\n * to wrap an {@link inject} call.\n *\n * Example:\n *\n * ```\n * it('...', async(inject([AClass], (object) => {\n *   object.doSomething.then(() => {\n *     expect(...);\n *   })\n * });\n * ```\n *\n *\n */\nexport function asyncFallback(fn) {\n    // If we're running using the Jasmine test framework, adapt to call the 'done'\n    // function when asynchronous activity is finished.\n    if (_global.jasmine) {\n        // Not using an arrow function to preserve context passed from call site\n        return function (done) {\n            if (!done) {\n                // if we run beforeEach in @angular/core/testing/testing_internal then we get no done\n                // fake it here and assume sync.\n                done = function () { };\n                done.fail = function (e) { throw e; };\n            }\n            runInTestZone(fn, this, done, function (err) {\n                if (typeof err === 'string') {\n                    return done.fail(new Error(err));\n                }\n                else {\n                    done.fail(err);\n                }\n            });\n        };\n    }\n    // Otherwise, return a promise which will resolve when asynchronous activity\n    // is finished. This will be correctly consumed by the Mocha framework with\n    // it('...', async(myFn)); or can be used in a custom framework.\n    // Not using an arrow function to preserve context passed from call site\n    return function () {\n        var _this = this;\n        return new Promise(function (finishCallback, failCallback) {\n            runInTestZone(fn, _this, finishCallback, failCallback);\n        });\n    };\n}\nfunction runInTestZone(fn, context, finishCallback, failCallback) {\n    var currentZone = Zone.current;\n    var AsyncTestZoneSpec = Zone['AsyncTestZoneSpec'];\n    if (AsyncTestZoneSpec === undefined) {\n        throw new Error('AsyncTestZoneSpec is needed for the async() test helper but could not be found. ' +\n            'Please make sure that your environment includes zone.js/dist/async-test.js');\n    }\n    var ProxyZoneSpec = Zone['ProxyZoneSpec'];\n    if (ProxyZoneSpec === undefined) {\n        throw new Error('ProxyZoneSpec is needed for the async() test helper but could not be found. ' +\n            'Please make sure that your environment includes zone.js/dist/proxy.js');\n    }\n    var proxyZoneSpec = ProxyZoneSpec.get();\n    ProxyZoneSpec.assertPresent();\n    // We need to create the AsyncTestZoneSpec outside the ProxyZone.\n    // If we do it in ProxyZone then we will get to infinite recursion.\n    var proxyZone = Zone.current.getZoneWith('ProxyZoneSpec');\n    var previousDelegate = proxyZoneSpec.getDelegate();\n    proxyZone.parent.run(function () {\n        var testZoneSpec = new AsyncTestZoneSpec(function () {\n            // Need to restore the original zone.\n            currentZone.run(function () {\n                if (proxyZoneSpec.getDelegate() == testZoneSpec) {\n                    // Only reset the zone spec if it's sill this one. Otherwise, assume it's OK.\n                    proxyZoneSpec.setDelegate(previousDelegate);\n                }\n                finishCallback();\n            });\n        }, function (error) {\n            // Need to restore the original zone.\n            currentZone.run(function () {\n                if (proxyZoneSpec.getDelegate() == testZoneSpec) {\n                    // Only reset the zone spec if it's sill this one. Otherwise, assume it's OK.\n                    proxyZoneSpec.setDelegate(previousDelegate);\n                }\n                failCallback(error);\n            });\n        }, 'test');\n        proxyZoneSpec.setDelegate(testZoneSpec);\n    });\n    return Zone.current.runGuarded(fn, context);\n}\n//# sourceMappingURL=async_fallback.js.map","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { RendererFactory2, getDebugNode } from '@angular/core';\n/**\n * Fixture for debugging and testing a component.\n *\n *\n */\nvar ComponentFixture = /** @class */ (function () {\n    function ComponentFixture(componentRef, ngZone, _autoDetect) {\n        var _this = this;\n        this.componentRef = componentRef;\n        this.ngZone = ngZone;\n        this._autoDetect = _autoDetect;\n        this._isStable = true;\n        this._isDestroyed = false;\n        this._resolve = null;\n        this._promise = null;\n        this._onUnstableSubscription = null;\n        this._onStableSubscription = null;\n        this._onMicrotaskEmptySubscription = null;\n        this._onErrorSubscription = null;\n        this.changeDetectorRef = componentRef.changeDetectorRef;\n        this.elementRef = componentRef.location;\n        this.debugElement = getDebugNode(this.elementRef.nativeElement);\n        this.componentInstance = componentRef.instance;\n        this.nativeElement = this.elementRef.nativeElement;\n        this.componentRef = componentRef;\n        this.ngZone = ngZone;\n        if (ngZone) {\n            // Create subscriptions outside the NgZone so that the callbacks run oustide\n            // of NgZone.\n            ngZone.runOutsideAngular(function () {\n                _this._onUnstableSubscription =\n                    ngZone.onUnstable.subscribe({ next: function () { _this._isStable = false; } });\n                _this._onMicrotaskEmptySubscription = ngZone.onMicrotaskEmpty.subscribe({\n                    next: function () {\n                        if (_this._autoDetect) {\n                            // Do a change detection run with checkNoChanges set to true to check\n                            // there are no changes on the second run.\n                            _this.detectChanges(true);\n                        }\n                    }\n                });\n                _this._onStableSubscription = ngZone.onStable.subscribe({\n                    next: function () {\n                        _this._isStable = true;\n                        // Check whether there is a pending whenStable() completer to resolve.\n                        if (_this._promise !== null) {\n                            // If so check whether there are no pending macrotasks before resolving.\n                            // Do this check in the next tick so that ngZone gets a chance to update the state of\n                            // pending macrotasks.\n                            scheduleMicroTask(function () {\n                                if (!ngZone.hasPendingMacrotasks) {\n                                    if (_this._promise !== null) {\n                                        _this._resolve(true);\n                                        _this._resolve = null;\n                                        _this._promise = null;\n                                    }\n                                }\n                            });\n                        }\n                    }\n                });\n                _this._onErrorSubscription =\n                    ngZone.onError.subscribe({ next: function (error) { throw error; } });\n            });\n        }\n    }\n    ComponentFixture.prototype._tick = function (checkNoChanges) {\n        this.changeDetectorRef.detectChanges();\n        if (checkNoChanges) {\n            this.checkNoChanges();\n        }\n    };\n    /**\n     * Trigger a change detection cycle for the component.\n     */\n    ComponentFixture.prototype.detectChanges = function (checkNoChanges) {\n        var _this = this;\n        if (checkNoChanges === void 0) { checkNoChanges = true; }\n        if (this.ngZone != null) {\n            // Run the change detection inside the NgZone so that any async tasks as part of the change\n            // detection are captured by the zone and can be waited for in isStable.\n            this.ngZone.run(function () { _this._tick(checkNoChanges); });\n        }\n        else {\n            // Running without zone. Just do the change detection.\n            this._tick(checkNoChanges);\n        }\n    };\n    /**\n     * Do a change detection run to make sure there were no changes.\n     */\n    ComponentFixture.prototype.checkNoChanges = function () { this.changeDetectorRef.checkNoChanges(); };\n    /**\n     * Set whether the fixture should autodetect changes.\n     *\n     * Also runs detectChanges once so that any existing change is detected.\n     */\n    ComponentFixture.prototype.autoDetectChanges = function (autoDetect) {\n        if (autoDetect === void 0) { autoDetect = true; }\n        if (this.ngZone == null) {\n            throw new Error('Cannot call autoDetectChanges when ComponentFixtureNoNgZone is set');\n        }\n        this._autoDetect = autoDetect;\n        this.detectChanges();\n    };\n    /**\n     * Return whether the fixture is currently stable or has async tasks that have not been completed\n     * yet.\n     */\n    ComponentFixture.prototype.isStable = function () { return this._isStable && !this.ngZone.hasPendingMacrotasks; };\n    /**\n     * Get a promise that resolves when the fixture is stable.\n     *\n     * This can be used to resume testing after events have triggered asynchronous activity or\n     * asynchronous change detection.\n     */\n    ComponentFixture.prototype.whenStable = function () {\n        var _this = this;\n        if (this.isStable()) {\n            return Promise.resolve(false);\n        }\n        else if (this._promise !== null) {\n            return this._promise;\n        }\n        else {\n            this._promise = new Promise(function (res) { _this._resolve = res; });\n            return this._promise;\n        }\n    };\n    ComponentFixture.prototype._getRenderer = function () {\n        if (this._renderer === undefined) {\n            this._renderer = this.componentRef.injector.get(RendererFactory2, null);\n        }\n        return this._renderer;\n    };\n    /**\n      * Get a promise that resolves when the ui state is stable following animations.\n      */\n    ComponentFixture.prototype.whenRenderingDone = function () {\n        var renderer = this._getRenderer();\n        if (renderer && renderer.whenRenderingDone) {\n            return renderer.whenRenderingDone();\n        }\n        return this.whenStable();\n    };\n    /**\n     * Trigger component destruction.\n     */\n    ComponentFixture.prototype.destroy = function () {\n        if (!this._isDestroyed) {\n            this.componentRef.destroy();\n            if (this._onUnstableSubscription != null) {\n                this._onUnstableSubscription.unsubscribe();\n                this._onUnstableSubscription = null;\n            }\n            if (this._onStableSubscription != null) {\n                this._onStableSubscription.unsubscribe();\n                this._onStableSubscription = null;\n            }\n            if (this._onMicrotaskEmptySubscription != null) {\n                this._onMicrotaskEmptySubscription.unsubscribe();\n                this._onMicrotaskEmptySubscription = null;\n            }\n            if (this._onErrorSubscription != null) {\n                this._onErrorSubscription.unsubscribe();\n                this._onErrorSubscription = null;\n            }\n            this._isDestroyed = true;\n        }\n    };\n    return ComponentFixture;\n}());\nexport { ComponentFixture };\nfunction scheduleMicroTask(fn) {\n    Zone.current.scheduleMicroTask('scheduleMicrotask', fn);\n}\n//# sourceMappingURL=component_fixture.js.map","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * fakeAsync has been moved to zone.js\n * this file is for fallback in case old version of zone.js is used\n */\nvar _Zone = typeof Zone !== 'undefined' ? Zone : null;\nvar FakeAsyncTestZoneSpec = _Zone && _Zone['FakeAsyncTestZoneSpec'];\nvar ProxyZoneSpec = _Zone && _Zone['ProxyZoneSpec'];\nvar _fakeAsyncTestZoneSpec = null;\n/**\n * Clears out the shared fake async zone for a test.\n * To be called in a global `beforeEach`.\n *\n * @experimental\n */\nexport function resetFakeAsyncZoneFallback() {\n    _fakeAsyncTestZoneSpec = null;\n    // in node.js testing we may not have ProxyZoneSpec in which case there is nothing to reset.\n    ProxyZoneSpec && ProxyZoneSpec.assertPresent().resetDelegate();\n}\nvar _inFakeAsyncCall = false;\n/**\n * Wraps a function to be executed in the fakeAsync zone:\n * - microtasks are manually executed by calling `flushMicrotasks()`,\n * - timers are synchronous, `tick()` simulates the asynchronous passage of time.\n *\n * If there are any pending timers at the end of the function, an exception will be thrown.\n *\n * Can be used to wrap inject() calls.\n *\n * @usageNotes\n * ### Example\n *\n * {@example core/testing/ts/fake_async.ts region='basic'}\n *\n * @param fn\n * @returns The function wrapped to be executed in the fakeAsync zone\n *\n * @experimental\n */\nexport function fakeAsyncFallback(fn) {\n    // Not using an arrow function to preserve context passed from call site\n    return function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        var proxyZoneSpec = ProxyZoneSpec.assertPresent();\n        if (_inFakeAsyncCall) {\n            throw new Error('fakeAsync() calls can not be nested');\n        }\n        _inFakeAsyncCall = true;\n        try {\n            if (!_fakeAsyncTestZoneSpec) {\n                if (proxyZoneSpec.getDelegate() instanceof FakeAsyncTestZoneSpec) {\n                    throw new Error('fakeAsync() calls can not be nested');\n                }\n                _fakeAsyncTestZoneSpec = new FakeAsyncTestZoneSpec();\n            }\n            var res = void 0;\n            var lastProxyZoneSpec = proxyZoneSpec.getDelegate();\n            proxyZoneSpec.setDelegate(_fakeAsyncTestZoneSpec);\n            try {\n                res = fn.apply(this, args);\n                flushMicrotasksFallback();\n            }\n            finally {\n                proxyZoneSpec.setDelegate(lastProxyZoneSpec);\n            }\n            if (_fakeAsyncTestZoneSpec.pendingPeriodicTimers.length > 0) {\n                throw new Error(_fakeAsyncTestZoneSpec.pendingPeriodicTimers.length + \" \" +\n                    \"periodic timer(s) still in the queue.\");\n            }\n            if (_fakeAsyncTestZoneSpec.pendingTimers.length > 0) {\n                throw new Error(_fakeAsyncTestZoneSpec.pendingTimers.length + \" timer(s) still in the queue.\");\n            }\n            return res;\n        }\n        finally {\n            _inFakeAsyncCall = false;\n            resetFakeAsyncZoneFallback();\n        }\n    };\n}\nfunction _getFakeAsyncZoneSpec() {\n    if (_fakeAsyncTestZoneSpec == null) {\n        throw new Error('The code should be running in the fakeAsync zone to call this function');\n    }\n    return _fakeAsyncTestZoneSpec;\n}\n/**\n * Simulates the asynchronous passage of time for the timers in the fakeAsync zone.\n *\n * The microtasks queue is drained at the very start of this function and after any timer callback\n * has been executed.\n *\n * @usageNotes\n * ### Example\n *\n * {@example core/testing/ts/fake_async.ts region='basic'}\n *\n * @experimental\n */\nexport function tickFallback(millis) {\n    if (millis === void 0) { millis = 0; }\n    _getFakeAsyncZoneSpec().tick(millis);\n}\n/**\n * Simulates the asynchronous passage of time for the timers in the fakeAsync zone by\n * draining the macrotask queue until it is empty. The returned value is the milliseconds\n * of time that would have been elapsed.\n *\n * @param maxTurns\n * @returns The simulated time elapsed, in millis.\n *\n * @experimental\n */\nexport function flushFallback(maxTurns) {\n    return _getFakeAsyncZoneSpec().flush(maxTurns);\n}\n/**\n * Discard all remaining periodic tasks.\n *\n * @experimental\n */\nexport function discardPeriodicTasksFallback() {\n    var zoneSpec = _getFakeAsyncZoneSpec();\n    zoneSpec.pendingPeriodicTimers.length = 0;\n}\n/**\n * Flush any pending microtasks.\n *\n * @experimental\n */\nexport function flushMicrotasksFallback() {\n    _getFakeAsyncZoneSpec().flushMicrotasks();\n}\n//# sourceMappingURL=fake_async_fallback.js.map","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { discardPeriodicTasksFallback, fakeAsyncFallback, flushFallback, flushMicrotasksFallback, resetFakeAsyncZoneFallback, tickFallback } from './fake_async_fallback';\nvar _Zone = typeof Zone !== 'undefined' ? Zone : null;\nvar fakeAsyncTestModule = _Zone && _Zone[_Zone.__symbol__('fakeAsyncTest')];\n/**\n * Clears out the shared fake async zone for a test.\n * To be called in a global `beforeEach`.\n *\n * @experimental\n */\nexport function resetFakeAsyncZone() {\n    if (fakeAsyncTestModule) {\n        return fakeAsyncTestModule.resetFakeAsyncZone();\n    }\n    else {\n        return resetFakeAsyncZoneFallback();\n    }\n}\n/**\n * Wraps a function to be executed in the fakeAsync zone:\n * - microtasks are manually executed by calling `flushMicrotasks()`,\n * - timers are synchronous, `tick()` simulates the asynchronous passage of time.\n *\n * If there are any pending timers at the end of the function, an exception will be thrown.\n *\n * Can be used to wrap inject() calls.\n *\n * @usageNotes\n * ### Example\n *\n * {@example core/testing/ts/fake_async.ts region='basic'}\n *\n * @param fn\n * @returns The function wrapped to be executed in the fakeAsync zone\n *\n * @experimental\n */\nexport function fakeAsync(fn) {\n    if (fakeAsyncTestModule) {\n        return fakeAsyncTestModule.fakeAsync(fn);\n    }\n    else {\n        return fakeAsyncFallback(fn);\n    }\n}\n/**\n * Simulates the asynchronous passage of time for the timers in the fakeAsync zone.\n *\n * The microtasks queue is drained at the very start of this function and after any timer callback\n * has been executed.\n *\n * @usageNotes\n * ### Example\n *\n * {@example core/testing/ts/fake_async.ts region='basic'}\n *\n * @experimental\n */\nexport function tick(millis) {\n    if (millis === void 0) { millis = 0; }\n    if (fakeAsyncTestModule) {\n        return fakeAsyncTestModule.tick(millis);\n    }\n    else {\n        return tickFallback(millis);\n    }\n}\n/**\n * Simulates the asynchronous passage of time for the timers in the fakeAsync zone by\n * draining the macrotask queue until it is empty. The returned value is the milliseconds\n * of time that would have been elapsed.\n *\n * @param maxTurns\n * @returns The simulated time elapsed, in millis.\n *\n * @experimental\n */\nexport function flush(maxTurns) {\n    if (fakeAsyncTestModule) {\n        return fakeAsyncTestModule.flush(maxTurns);\n    }\n    else {\n        return flushFallback(maxTurns);\n    }\n}\n/**\n * Discard all remaining periodic tasks.\n *\n * @experimental\n */\nexport function discardPeriodicTasks() {\n    if (fakeAsyncTestModule) {\n        return fakeAsyncTestModule.discardPeriodicTasks();\n    }\n    else {\n        discardPeriodicTasksFallback();\n    }\n}\n/**\n * Flush any pending microtasks.\n *\n * @experimental\n */\nexport function flushMicrotasks() {\n    if (fakeAsyncTestModule) {\n        return fakeAsyncTestModule.flushMicrotasks();\n    }\n    else {\n        return flushMicrotasksFallback();\n    }\n}\n//# sourceMappingURL=fake_async.js.map","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Injectable completer that allows signaling completion of an asynchronous test. Used internally.\n */\nvar AsyncTestCompleter = /** @class */ (function () {\n    function AsyncTestCompleter() {\n        var _this = this;\n        this._promise = new Promise(function (res, rej) {\n            _this._resolve = res;\n            _this._reject = rej;\n        });\n    }\n    AsyncTestCompleter.prototype.done = function (value) { this._resolve(value); };\n    AsyncTestCompleter.prototype.fail = function (error, stackTrace) { this._reject(error); };\n    Object.defineProperty(AsyncTestCompleter.prototype, \"promise\", {\n        get: function () { return this._promise; },\n        enumerable: true,\n        configurable: true\n    });\n    return AsyncTestCompleter;\n}());\nexport { AsyncTestCompleter };\n//# sourceMappingURL=async_test_completer.js.map","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { ɵstringify as stringify } from '@angular/core';\nvar _nextReferenceId = 0;\nvar MetadataOverrider = /** @class */ (function () {\n    function MetadataOverrider() {\n        this._references = new Map();\n    }\n    /**\n     * Creates a new instance for the given metadata class\n     * based on an old instance and overrides.\n     */\n    MetadataOverrider.prototype.overrideMetadata = function (metadataClass, oldMetadata, override) {\n        var props = {};\n        if (oldMetadata) {\n            _valueProps(oldMetadata).forEach(function (prop) { return props[prop] = oldMetadata[prop]; });\n        }\n        if (override.set) {\n            if (override.remove || override.add) {\n                throw new Error(\"Cannot set and add/remove \" + stringify(metadataClass) + \" at the same time!\");\n            }\n            setMetadata(props, override.set);\n        }\n        if (override.remove) {\n            removeMetadata(props, override.remove, this._references);\n        }\n        if (override.add) {\n            addMetadata(props, override.add);\n        }\n        return new metadataClass(props);\n    };\n    return MetadataOverrider;\n}());\nexport { MetadataOverrider };\nfunction removeMetadata(metadata, remove, references) {\n    var removeObjects = new Set();\n    var _loop_1 = function (prop) {\n        var removeValue = remove[prop];\n        if (removeValue instanceof Array) {\n            removeValue.forEach(function (value) { removeObjects.add(_propHashKey(prop, value, references)); });\n        }\n        else {\n            removeObjects.add(_propHashKey(prop, removeValue, references));\n        }\n    };\n    for (var prop in remove) {\n        _loop_1(prop);\n    }\n    var _loop_2 = function (prop) {\n        var propValue = metadata[prop];\n        if (propValue instanceof Array) {\n            metadata[prop] = propValue.filter(function (value) { return !removeObjects.has(_propHashKey(prop, value, references)); });\n        }\n        else {\n            if (removeObjects.has(_propHashKey(prop, propValue, references))) {\n                metadata[prop] = undefined;\n            }\n        }\n    };\n    for (var prop in metadata) {\n        _loop_2(prop);\n    }\n}\nfunction addMetadata(metadata, add) {\n    for (var prop in add) {\n        var addValue = add[prop];\n        var propValue = metadata[prop];\n        if (propValue != null && propValue instanceof Array) {\n            metadata[prop] = propValue.concat(addValue);\n        }\n        else {\n            metadata[prop] = addValue;\n        }\n    }\n}\nfunction setMetadata(metadata, set) {\n    for (var prop in set) {\n        metadata[prop] = set[prop];\n    }\n}\nfunction _propHashKey(propName, propValue, references) {\n    var replacer = function (key, value) {\n        if (typeof value === 'function') {\n            value = _serializeReference(value, references);\n        }\n        return value;\n    };\n    return propName + \":\" + JSON.stringify(propValue, replacer);\n}\nfunction _serializeReference(ref, references) {\n    var id = references.get(ref);\n    if (!id) {\n        id = \"\" + stringify(ref) + _nextReferenceId++;\n        references.set(ref, id);\n    }\n    return id;\n}\nfunction _valueProps(obj) {\n    var props = [];\n    // regular public props\n    Object.keys(obj).forEach(function (prop) {\n        if (!prop.startsWith('_')) {\n            props.push(prop);\n        }\n    });\n    // getters\n    var proto = obj;\n    while (proto = Object.getPrototypeOf(proto)) {\n        Object.keys(proto).forEach(function (protoProp) {\n            var desc = Object.getOwnPropertyDescriptor(proto, protoProp);\n            if (!protoProp.startsWith('_') && desc && 'get' in desc) {\n                props.push(protoProp);\n            }\n        });\n    }\n    return props;\n}\n//# sourceMappingURL=metadata_overrider.js.map","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as tslib_1 from \"tslib\";\nimport { Injector, NgModule, ɵRender3ComponentFactory as ComponentFactory, ɵRender3DebugRendererFactory2 as Render3DebugRendererFactory2, ɵRender3NgModuleRef as NgModuleRef, ɵWRAP_RENDERER_FACTORY2 as WRAP_RENDERER_FACTORY2, ɵcompileComponent as compileComponent, ɵcompileDirective as compileDirective, ɵcompileNgModuleDefs as compileNgModuleDefs, ɵcompilePipe as compilePipe, ɵpatchComponentDefWithScope as patchComponentDefWithScope, ɵstringify as stringify } from '@angular/core';\nimport { ComponentFixture } from './component_fixture';\nimport { ComponentResolver, DirectiveResolver, NgModuleResolver, PipeResolver } from './resolvers';\nimport { ComponentFixtureAutoDetect, TestComponentRenderer } from './test_bed_common';\nvar _nextRootElementId = 0;\n/**\n * @description\n * Configures and initializes environment for unit testing and provides methods for\n * creating components and services in unit tests.\n *\n * TestBed is the primary api for writing unit tests for Angular applications and libraries.\n *\n * Note: Use `TestBed` in tests. It will be set to either `TestBedViewEngine` or `TestBedRender3`\n * according to the compiler used.\n */\nvar TestBedRender3 = /** @class */ (function () {\n    function TestBedRender3() {\n        // Properties\n        this.platform = null;\n        this.ngModule = null;\n        // metadata overrides\n        this._moduleOverrides = [];\n        this._componentOverrides = [];\n        this._directiveOverrides = [];\n        this._pipeOverrides = [];\n        this._providerOverrides = [];\n        this._rootProviderOverrides = [];\n        // test module configuration\n        this._providers = [];\n        this._declarations = [];\n        this._imports = [];\n        this._schemas = [];\n        this._activeFixtures = [];\n        this._moduleRef = null;\n        this._instantiated = false;\n    }\n    /**\n     * Initialize the environment for testing with a compiler factory, a PlatformRef, and an\n     * angular module. These are common to every test in the suite.\n     *\n     * This may only be called once, to set up the common providers for the current test\n     * suite on the current platform. If you absolutely need to change the providers,\n     * first use `resetTestEnvironment`.\n     *\n     * Test modules and platforms for individual platforms are available from\n     * '@angular/<platform_name>/testing'.\n     *\n     * @experimental\n     */\n    TestBedRender3.initTestEnvironment = function (ngModule, platform, aotSummaries) {\n        var testBed = _getTestBedRender3();\n        testBed.initTestEnvironment(ngModule, platform, aotSummaries);\n        return testBed;\n    };\n    /**\n     * Reset the providers for the test injector.\n     *\n     * @experimental\n     */\n    TestBedRender3.resetTestEnvironment = function () { _getTestBedRender3().resetTestEnvironment(); };\n    TestBedRender3.configureCompiler = function (config) {\n        _getTestBedRender3().configureCompiler(config);\n        return TestBedRender3;\n    };\n    /**\n     * Allows overriding default providers, directives, pipes, modules of the test injector,\n     * which are defined in test_injector.js\n     */\n    TestBedRender3.configureTestingModule = function (moduleDef) {\n        _getTestBedRender3().configureTestingModule(moduleDef);\n        return TestBedRender3;\n    };\n    /**\n     * Compile components with a `templateUrl` for the test's NgModule.\n     * It is necessary to call this function\n     * as fetching urls is asynchronous.\n     */\n    TestBedRender3.compileComponents = function () { return _getTestBedRender3().compileComponents(); };\n    TestBedRender3.overrideModule = function (ngModule, override) {\n        _getTestBedRender3().overrideModule(ngModule, override);\n        return TestBedRender3;\n    };\n    TestBedRender3.overrideComponent = function (component, override) {\n        _getTestBedRender3().overrideComponent(component, override);\n        return TestBedRender3;\n    };\n    TestBedRender3.overrideDirective = function (directive, override) {\n        _getTestBedRender3().overrideDirective(directive, override);\n        return TestBedRender3;\n    };\n    TestBedRender3.overridePipe = function (pipe, override) {\n        _getTestBedRender3().overridePipe(pipe, override);\n        return TestBedRender3;\n    };\n    TestBedRender3.overrideTemplate = function (component, template) {\n        _getTestBedRender3().overrideComponent(component, { set: { template: template, templateUrl: null } });\n        return TestBedRender3;\n    };\n    /**\n     * Overrides the template of the given component, compiling the template\n     * in the context of the TestingModule.\n     *\n     * Note: This works for JIT and AOTed components as well.\n     */\n    TestBedRender3.overrideTemplateUsingTestingModule = function (component, template) {\n        _getTestBedRender3().overrideTemplateUsingTestingModule(component, template);\n        return TestBedRender3;\n    };\n    TestBedRender3.prototype.overrideTemplateUsingTestingModule = function (component, template) {\n        throw new Error('Render3TestBed.overrideTemplateUsingTestingModule is not implemented yet');\n    };\n    TestBedRender3.overrideProvider = function (token, provider) {\n        _getTestBedRender3().overrideProvider(token, provider);\n        return TestBedRender3;\n    };\n    TestBedRender3.deprecatedOverrideProvider = function (token, provider) {\n        throw new Error('Render3TestBed.deprecatedOverrideProvider is not implemented');\n    };\n    TestBedRender3.get = function (token, notFoundValue) {\n        if (notFoundValue === void 0) { notFoundValue = Injector.THROW_IF_NOT_FOUND; }\n        return _getTestBedRender3().get(token, notFoundValue);\n    };\n    TestBedRender3.createComponent = function (component) {\n        return _getTestBedRender3().createComponent(component);\n    };\n    TestBedRender3.resetTestingModule = function () {\n        _getTestBedRender3().resetTestingModule();\n        return TestBedRender3;\n    };\n    /**\n     * Initialize the environment for testing with a compiler factory, a PlatformRef, and an\n     * angular module. These are common to every test in the suite.\n     *\n     * This may only be called once, to set up the common providers for the current test\n     * suite on the current platform. If you absolutely need to change the providers,\n     * first use `resetTestEnvironment`.\n     *\n     * Test modules and platforms for individual platforms are available from\n     * '@angular/<platform_name>/testing'.\n     *\n     * @experimental\n     */\n    TestBedRender3.prototype.initTestEnvironment = function (ngModule, platform, aotSummaries) {\n        if (this.platform || this.ngModule) {\n            throw new Error('Cannot set base providers because it has already been called');\n        }\n        this.platform = platform;\n        this.ngModule = ngModule;\n    };\n    /**\n     * Reset the providers for the test injector.\n     *\n     * @experimental\n     */\n    TestBedRender3.prototype.resetTestEnvironment = function () {\n        this.resetTestingModule();\n        this.platform = null;\n        this.ngModule = null;\n    };\n    TestBedRender3.prototype.resetTestingModule = function () {\n        // reset metadata overrides\n        this._moduleOverrides = [];\n        this._componentOverrides = [];\n        this._directiveOverrides = [];\n        this._pipeOverrides = [];\n        this._providerOverrides = [];\n        this._rootProviderOverrides = [];\n        // reset test module config\n        this._providers = [];\n        this._declarations = [];\n        this._imports = [];\n        this._schemas = [];\n        this._moduleRef = null;\n        this._instantiated = false;\n        this._activeFixtures.forEach(function (fixture) {\n            try {\n                fixture.destroy();\n            }\n            catch (e) {\n                console.error('Error during cleanup of component', {\n                    component: fixture.componentInstance,\n                    stacktrace: e,\n                });\n            }\n        });\n        this._activeFixtures = [];\n    };\n    TestBedRender3.prototype.configureCompiler = function (config) {\n        throw new Error('the Render3 compiler is not configurable !');\n    };\n    TestBedRender3.prototype.configureTestingModule = function (moduleDef) {\n        var _a, _b, _c, _d;\n        this._assertNotInstantiated('R3TestBed.configureTestingModule', 'configure the test module');\n        if (moduleDef.providers) {\n            (_a = this._providers).push.apply(_a, moduleDef.providers);\n        }\n        if (moduleDef.declarations) {\n            (_b = this._declarations).push.apply(_b, moduleDef.declarations);\n        }\n        if (moduleDef.imports) {\n            (_c = this._imports).push.apply(_c, moduleDef.imports);\n        }\n        if (moduleDef.schemas) {\n            (_d = this._schemas).push.apply(_d, moduleDef.schemas);\n        }\n    };\n    // TODO(vicb): implement\n    TestBedRender3.prototype.compileComponents = function () {\n        throw new Error('Render3TestBed.compileComponents is not implemented yet');\n    };\n    TestBedRender3.prototype.get = function (token, notFoundValue) {\n        if (notFoundValue === void 0) { notFoundValue = Injector.THROW_IF_NOT_FOUND; }\n        this._initIfNeeded();\n        if (token === TestBedRender3) {\n            return this;\n        }\n        return this._moduleRef.injector.get(token, notFoundValue);\n    };\n    TestBedRender3.prototype.execute = function (tokens, fn, context) {\n        var _this = this;\n        this._initIfNeeded();\n        var params = tokens.map(function (t) { return _this.get(t); });\n        return fn.apply(context, params);\n    };\n    TestBedRender3.prototype.overrideModule = function (ngModule, override) {\n        this._assertNotInstantiated('overrideModule', 'override module metadata');\n        this._moduleOverrides.push([ngModule, override]);\n    };\n    TestBedRender3.prototype.overrideComponent = function (component, override) {\n        this._assertNotInstantiated('overrideComponent', 'override component metadata');\n        this._componentOverrides.push([component, override]);\n    };\n    TestBedRender3.prototype.overrideDirective = function (directive, override) {\n        this._assertNotInstantiated('overrideDirective', 'override directive metadata');\n        this._directiveOverrides.push([directive, override]);\n    };\n    TestBedRender3.prototype.overridePipe = function (pipe, override) {\n        this._assertNotInstantiated('overridePipe', 'override pipe metadata');\n        this._pipeOverrides.push([pipe, override]);\n    };\n    /**\n     * Overwrites all providers for the given token with the given provider definition.\n     */\n    TestBedRender3.prototype.overrideProvider = function (token, provider) {\n        var isRoot = (typeof token !== 'string' && token.ngInjectableDef &&\n            token.ngInjectableDef.providedIn === 'root');\n        var overrides = isRoot ? this._rootProviderOverrides : this._providerOverrides;\n        if (provider.useFactory) {\n            overrides.push({ provide: token, useFactory: provider.useFactory, deps: provider.deps || [] });\n        }\n        else {\n            overrides.push({ provide: token, useValue: provider.useValue });\n        }\n    };\n    TestBedRender3.prototype.deprecatedOverrideProvider = function (token, provider) {\n        throw new Error('No implemented in IVY');\n    };\n    TestBedRender3.prototype.createComponent = function (type) {\n        this._initIfNeeded();\n        var testComponentRenderer = this.get(TestComponentRenderer);\n        var rootElId = \"root\" + _nextRootElementId++;\n        testComponentRenderer.insertRootElement(rootElId);\n        var componentDef = type.ngComponentDef;\n        if (!componentDef) {\n            throw new Error(\"It looks like '\" + stringify(type) + \"' has not been IVY compiled - it has no 'ngComponentDef' field\");\n        }\n        var componentFactory = new ComponentFactory(componentDef);\n        var componentRef = componentFactory.create(Injector.NULL, [], \"#\" + rootElId, this._moduleRef);\n        var autoDetect = this.get(ComponentFixtureAutoDetect, false);\n        var fixture = new ComponentFixture(componentRef, null, autoDetect);\n        this._activeFixtures.push(fixture);\n        return fixture;\n    };\n    // internal methods\n    TestBedRender3.prototype._initIfNeeded = function () {\n        if (this._instantiated) {\n            return;\n        }\n        var resolvers = this._getResolvers();\n        var testModuleType = this._createTestModule();\n        compileNgModule(testModuleType, resolvers);\n        var parentInjector = this.platform.injector;\n        this._moduleRef = new NgModuleRef(testModuleType, parentInjector);\n        this._instantiated = true;\n    };\n    // creates resolvers taking overrides into account\n    TestBedRender3.prototype._getResolvers = function () {\n        var module = new NgModuleResolver();\n        module.setOverrides(this._moduleOverrides);\n        var component = new ComponentResolver();\n        component.setOverrides(this._componentOverrides);\n        var directive = new DirectiveResolver();\n        directive.setOverrides(this._directiveOverrides);\n        var pipe = new PipeResolver();\n        pipe.setOverrides(this._pipeOverrides);\n        return { module: module, component: component, directive: directive, pipe: pipe };\n    };\n    TestBedRender3.prototype._assertNotInstantiated = function (methodName, methodDescription) {\n        if (this._instantiated) {\n            throw new Error(\"Cannot \" + methodDescription + \" when the test module has already been instantiated. \" +\n                (\"Make sure you are not using `inject` before `\" + methodName + \"`.\"));\n        }\n    };\n    TestBedRender3.prototype._createTestModule = function () {\n        var rootProviderOverrides = this._rootProviderOverrides;\n        var rendererFactoryWrapper = {\n            provide: WRAP_RENDERER_FACTORY2,\n            useFactory: function () { return function (rf) { return new Render3DebugRendererFactory2(rf); }; },\n        };\n        var RootScopeModule = /** @class */ (function () {\n            function RootScopeModule() {\n            }\n            RootScopeModule = tslib_1.__decorate([\n                NgModule({\n                    providers: rootProviderOverrides.concat([rendererFactoryWrapper]),\n                    jit: true,\n                })\n            ], RootScopeModule);\n            return RootScopeModule;\n        }());\n        var providers = this._providers.concat(this._providerOverrides);\n        var declarations = this._declarations;\n        var imports = [RootScopeModule, this.ngModule, this._imports];\n        var schemas = this._schemas;\n        var DynamicTestModule = /** @class */ (function () {\n            function DynamicTestModule() {\n            }\n            DynamicTestModule = tslib_1.__decorate([\n                NgModule({ providers: providers, declarations: declarations, imports: imports, schemas: schemas, jit: true })\n            ], DynamicTestModule);\n            return DynamicTestModule;\n        }());\n        return DynamicTestModule;\n    };\n    return TestBedRender3;\n}());\nexport { TestBedRender3 };\nvar testBed;\nexport function _getTestBedRender3() {\n    return testBed = testBed || new TestBedRender3();\n}\n// Module compiler\nvar EMPTY_ARRAY = [];\nfunction compileNgModule(moduleType, resolvers) {\n    var ngModule = resolvers.module.resolve(moduleType);\n    if (ngModule === null) {\n        throw new Error(stringify(moduleType) + \" has not @NgModule annotation\");\n    }\n    compileNgModuleDefs(moduleType, ngModule);\n    var declarations = flatten(ngModule.declarations || EMPTY_ARRAY);\n    var compiledComponents = [];\n    // Compile the components, directives and pipes declared by this module\n    declarations.forEach(function (declaration) {\n        var component = resolvers.component.resolve(declaration);\n        if (component) {\n            compileComponent(declaration, component);\n            compiledComponents.push(declaration);\n            return;\n        }\n        var directive = resolvers.directive.resolve(declaration);\n        if (directive) {\n            compileDirective(declaration, directive);\n            return;\n        }\n        var pipe = resolvers.pipe.resolve(declaration);\n        if (pipe) {\n            compilePipe(declaration, pipe);\n            return;\n        }\n    });\n    // Compile transitive modules, components, directives and pipes\n    var transitiveScope = transitiveScopesFor(moduleType, resolvers);\n    compiledComponents.forEach(function (cmp) { return patchComponentDefWithScope(cmp.ngComponentDef, transitiveScope); });\n}\n/**\n * Compute the pair of transitive scopes (compilation scope and exported scope) for a given module.\n *\n * This operation is memoized and the result is cached on the module's definition. It can be called\n * on modules with components that have not fully compiled yet, but the result should not be used\n * until they have.\n */\nfunction transitiveScopesFor(moduleType, resolvers) {\n    if (!isNgModule(moduleType)) {\n        throw new Error(moduleType.name + \" does not have an ngModuleDef\");\n    }\n    var def = moduleType.ngModuleDef;\n    if (def.transitiveCompileScopes !== null) {\n        return def.transitiveCompileScopes;\n    }\n    var scopes = {\n        compilation: {\n            directives: new Set(),\n            pipes: new Set(),\n        },\n        exported: {\n            directives: new Set(),\n            pipes: new Set(),\n        },\n    };\n    def.declarations.forEach(function (declared) {\n        var declaredWithDefs = declared;\n        if (declaredWithDefs.ngPipeDef !== undefined) {\n            scopes.compilation.pipes.add(declared);\n        }\n        else {\n            scopes.compilation.directives.add(declared);\n        }\n    });\n    def.imports.forEach(function (imported) {\n        var ngModule = resolvers.module.resolve(imported);\n        if (ngModule === null) {\n            throw new Error(\"Importing \" + imported.name + \" which does not have an @ngModule\");\n        }\n        else {\n            compileNgModule(imported, resolvers);\n        }\n        // When this module imports another, the imported module's exported directives and pipes are\n        // added to the compilation scope of this module.\n        var importedScope = transitiveScopesFor(imported, resolvers);\n        importedScope.exported.directives.forEach(function (entry) { return scopes.compilation.directives.add(entry); });\n        importedScope.exported.pipes.forEach(function (entry) { return scopes.compilation.pipes.add(entry); });\n    });\n    def.exports.forEach(function (exported) {\n        var exportedTyped = exported;\n        // Either the type is a module, a pipe, or a component/directive (which may not have an\n        // ngComponentDef as it might be compiled asynchronously).\n        if (isNgModule(exportedTyped)) {\n            // When this module exports another, the exported module's exported directives and pipes are\n            // added to both the compilation and exported scopes of this module.\n            var exportedScope = transitiveScopesFor(exportedTyped, resolvers);\n            exportedScope.exported.directives.forEach(function (entry) {\n                scopes.compilation.directives.add(entry);\n                scopes.exported.directives.add(entry);\n            });\n            exportedScope.exported.pipes.forEach(function (entry) {\n                scopes.compilation.pipes.add(entry);\n                scopes.exported.pipes.add(entry);\n            });\n        }\n        else if (exportedTyped.ngPipeDef !== undefined) {\n            scopes.exported.pipes.add(exportedTyped);\n        }\n        else {\n            scopes.exported.directives.add(exportedTyped);\n        }\n    });\n    def.transitiveCompileScopes = scopes;\n    return scopes;\n}\nfunction flatten(values) {\n    var out = [];\n    values.forEach(function (value) {\n        if (Array.isArray(value)) {\n            out.push.apply(out, flatten(value));\n        }\n        else {\n            out.push(value);\n        }\n    });\n    return out;\n}\nfunction isNgModule(value) {\n    return value.ngModuleDef !== undefined;\n}\n//# sourceMappingURL=r3_test_bed.js.map","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as tslib_1 from \"tslib\";\nimport { Component, Directive, NgModule, Pipe, ɵReflectionCapabilities as ReflectionCapabilities } from '@angular/core';\nimport { MetadataOverrider } from './metadata_overrider';\nvar reflection = new ReflectionCapabilities();\n/**\n * Allows to override ivy metadata for tests (via the `TestBed`).\n */\nvar OverrideResolver = /** @class */ (function () {\n    function OverrideResolver() {\n        this.overrides = new Map();\n        this.resolved = new Map();\n    }\n    OverrideResolver.prototype.setOverrides = function (overrides) {\n        var _this = this;\n        this.overrides.clear();\n        overrides.forEach(function (_a) {\n            var type = _a[0], override = _a[1];\n            return _this.overrides.set(type, override);\n        });\n    };\n    OverrideResolver.prototype.getAnnotation = function (type) {\n        var _this = this;\n        return reflection.annotations(type).find(function (a) { return a instanceof _this.type; }) || null;\n    };\n    OverrideResolver.prototype.resolve = function (type) {\n        var resolved = this.resolved.get(type) || null;\n        if (!resolved) {\n            resolved = this.getAnnotation(type);\n            if (resolved) {\n                var override = this.overrides.get(type);\n                if (override) {\n                    var overrider = new MetadataOverrider();\n                    resolved = overrider.overrideMetadata(this.type, resolved, override);\n                }\n            }\n            this.resolved.set(type, resolved);\n        }\n        return resolved;\n    };\n    return OverrideResolver;\n}());\nvar DirectiveResolver = /** @class */ (function (_super) {\n    tslib_1.__extends(DirectiveResolver, _super);\n    function DirectiveResolver() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(DirectiveResolver.prototype, \"type\", {\n        get: function () { return Directive; },\n        enumerable: true,\n        configurable: true\n    });\n    return DirectiveResolver;\n}(OverrideResolver));\nexport { DirectiveResolver };\nvar ComponentResolver = /** @class */ (function (_super) {\n    tslib_1.__extends(ComponentResolver, _super);\n    function ComponentResolver() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(ComponentResolver.prototype, \"type\", {\n        get: function () { return Component; },\n        enumerable: true,\n        configurable: true\n    });\n    return ComponentResolver;\n}(OverrideResolver));\nexport { ComponentResolver };\nvar PipeResolver = /** @class */ (function (_super) {\n    tslib_1.__extends(PipeResolver, _super);\n    function PipeResolver() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(PipeResolver.prototype, \"type\", {\n        get: function () { return Pipe; },\n        enumerable: true,\n        configurable: true\n    });\n    return PipeResolver;\n}(OverrideResolver));\nexport { PipeResolver };\nvar NgModuleResolver = /** @class */ (function (_super) {\n    tslib_1.__extends(NgModuleResolver, _super);\n    function NgModuleResolver() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(NgModuleResolver.prototype, \"type\", {\n        get: function () { return NgModule; },\n        enumerable: true,\n        configurable: true\n    });\n    return NgModuleResolver;\n}(OverrideResolver));\nexport { NgModuleResolver };\n//# sourceMappingURL=resolvers.js.map","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { InjectionToken } from '@angular/core';\n/**\n * An abstract class for inserting the root test component element in a platform independent way.\n *\n * @experimental\n */\nvar TestComponentRenderer = /** @class */ (function () {\n    function TestComponentRenderer() {\n    }\n    TestComponentRenderer.prototype.insertRootElement = function (rootElementId) { };\n    return TestComponentRenderer;\n}());\nexport { TestComponentRenderer };\n/**\n * @experimental\n */\nexport var ComponentFixtureAutoDetect = new InjectionToken('ComponentFixtureAutoDetect');\n/**\n * @experimental\n */\nexport var ComponentFixtureNoNgZone = new InjectionToken('ComponentFixtureNoNgZone');\n//# sourceMappingURL=test_bed_common.js.map","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as tslib_1 from \"tslib\";\nimport { Compiler, Injectable } from '@angular/core';\nfunction unimplemented() {\n    throw Error('unimplemented');\n}\n/**\n * Special interface to the compiler only used by testing\n *\n * @experimental\n */\nvar TestingCompiler = /** @class */ (function (_super) {\n    tslib_1.__extends(TestingCompiler, _super);\n    function TestingCompiler() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(TestingCompiler.prototype, \"injector\", {\n        get: function () { throw unimplemented(); },\n        enumerable: true,\n        configurable: true\n    });\n    TestingCompiler.prototype.overrideModule = function (module, overrides) {\n        throw unimplemented();\n    };\n    TestingCompiler.prototype.overrideDirective = function (directive, overrides) {\n        throw unimplemented();\n    };\n    TestingCompiler.prototype.overrideComponent = function (component, overrides) {\n        throw unimplemented();\n    };\n    TestingCompiler.prototype.overridePipe = function (directive, overrides) {\n        throw unimplemented();\n    };\n    /**\n     * Allows to pass the compile summary from AOT compilation to the JIT compiler,\n     * so that it can use the code generated by AOT.\n     */\n    TestingCompiler.prototype.loadAotSummaries = function (summaries) { throw unimplemented(); };\n    /**\n     * Gets the component factory for the given component.\n     * This assumes that the component has been compiled before calling this call using\n     * `compileModuleAndAllComponents*`.\n     */\n    TestingCompiler.prototype.getComponentFactory = function (component) { throw unimplemented(); };\n    /**\n     * Returns the component type that is stored in the given error.\n     * This can be used for errors created by compileModule...\n     */\n    TestingCompiler.prototype.getComponentFromError = function (error) { throw unimplemented(); };\n    TestingCompiler = tslib_1.__decorate([\n        Injectable()\n    ], TestingCompiler);\n    return TestingCompiler;\n}(Compiler));\nexport { TestingCompiler };\n/**\n * A factory for creating a Compiler\n *\n * @experimental\n */\nvar TestingCompilerFactory = /** @class */ (function () {\n    function TestingCompilerFactory() {\n    }\n    return TestingCompilerFactory;\n}());\nexport { TestingCompilerFactory };\n//# sourceMappingURL=test_compiler.js.map","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as tslib_1 from \"tslib\";\nimport { ApplicationInitStatus, Component, Injector, NgModule, NgZone, Optional, SkipSelf, ɵAPP_ROOT as APP_ROOT, ɵclearOverrides as clearOverrides, ɵivyEnabled as ivyEnabled, ɵoverrideComponentView as overrideComponentView, ɵoverrideProvider as overrideProvider, ɵstringify as stringify } from '@angular/core';\nimport { AsyncTestCompleter } from './async_test_completer';\nimport { ComponentFixture } from './component_fixture';\nimport { TestBedRender3, _getTestBedRender3 } from './r3_test_bed';\nimport { ComponentFixtureAutoDetect, ComponentFixtureNoNgZone, TestComponentRenderer } from './test_bed_common';\nimport { TestingCompilerFactory } from './test_compiler';\nvar UNDEFINED = new Object();\nvar _nextRootElementId = 0;\n/**\n * @description\n * Configures and initializes environment for unit testing and provides methods for\n * creating components and services in unit tests.\n *\n * `TestBed` is the primary api for writing unit tests for Angular applications and libraries.\n *\n * Note: Use `TestBed` in tests. It will be set to either `TestBedViewEngine` or `TestBedRender3`\n * according to the compiler used.\n */\nvar TestBedViewEngine = /** @class */ (function () {\n    function TestBedViewEngine() {\n        this._instantiated = false;\n        this._compiler = null;\n        this._moduleRef = null;\n        this._moduleFactory = null;\n        this._compilerOptions = [];\n        this._moduleOverrides = [];\n        this._componentOverrides = [];\n        this._directiveOverrides = [];\n        this._pipeOverrides = [];\n        this._providers = [];\n        this._declarations = [];\n        this._imports = [];\n        this._schemas = [];\n        this._activeFixtures = [];\n        this._testEnvAotSummaries = function () { return []; };\n        this._aotSummaries = [];\n        this._templateOverrides = [];\n        this._isRoot = true;\n        this._rootProviderOverrides = [];\n        this.platform = null;\n        this.ngModule = null;\n    }\n    /**\n     * Initialize the environment for testing with a compiler factory, a PlatformRef, and an\n     * angular module. These are common to every test in the suite.\n     *\n     * This may only be called once, to set up the common providers for the current test\n     * suite on the current platform. If you absolutely need to change the providers,\n     * first use `resetTestEnvironment`.\n     *\n     * Test modules and platforms for individual platforms are available from\n     * '@angular/<platform_name>/testing'.\n     *\n     * @experimental\n     */\n    TestBedViewEngine.initTestEnvironment = function (ngModule, platform, aotSummaries) {\n        var testBed = _getTestBedViewEngine();\n        testBed.initTestEnvironment(ngModule, platform, aotSummaries);\n        return testBed;\n    };\n    /**\n     * Reset the providers for the test injector.\n     *\n     * @experimental\n     */\n    TestBedViewEngine.resetTestEnvironment = function () { _getTestBedViewEngine().resetTestEnvironment(); };\n    TestBedViewEngine.resetTestingModule = function () {\n        _getTestBedViewEngine().resetTestingModule();\n        return TestBedViewEngine;\n    };\n    /**\n     * Allows overriding default compiler providers and settings\n     * which are defined in test_injector.js\n     */\n    TestBedViewEngine.configureCompiler = function (config) {\n        _getTestBedViewEngine().configureCompiler(config);\n        return TestBedViewEngine;\n    };\n    /**\n     * Allows overriding default providers, directives, pipes, modules of the test injector,\n     * which are defined in test_injector.js\n     */\n    TestBedViewEngine.configureTestingModule = function (moduleDef) {\n        _getTestBedViewEngine().configureTestingModule(moduleDef);\n        return TestBedViewEngine;\n    };\n    /**\n     * Compile components with a `templateUrl` for the test's NgModule.\n     * It is necessary to call this function\n     * as fetching urls is asynchronous.\n     */\n    TestBedViewEngine.compileComponents = function () { return getTestBed().compileComponents(); };\n    TestBedViewEngine.overrideModule = function (ngModule, override) {\n        _getTestBedViewEngine().overrideModule(ngModule, override);\n        return TestBedViewEngine;\n    };\n    TestBedViewEngine.overrideComponent = function (component, override) {\n        _getTestBedViewEngine().overrideComponent(component, override);\n        return TestBedViewEngine;\n    };\n    TestBedViewEngine.overrideDirective = function (directive, override) {\n        _getTestBedViewEngine().overrideDirective(directive, override);\n        return TestBedViewEngine;\n    };\n    TestBedViewEngine.overridePipe = function (pipe, override) {\n        _getTestBedViewEngine().overridePipe(pipe, override);\n        return TestBedViewEngine;\n    };\n    TestBedViewEngine.overrideTemplate = function (component, template) {\n        _getTestBedViewEngine().overrideComponent(component, { set: { template: template, templateUrl: null } });\n        return TestBedViewEngine;\n    };\n    /**\n     * Overrides the template of the given component, compiling the template\n     * in the context of the TestingModule.\n     *\n     * Note: This works for JIT and AOTed components as well.\n     */\n    TestBedViewEngine.overrideTemplateUsingTestingModule = function (component, template) {\n        _getTestBedViewEngine().overrideTemplateUsingTestingModule(component, template);\n        return TestBedViewEngine;\n    };\n    TestBedViewEngine.overrideProvider = function (token, provider) {\n        _getTestBedViewEngine().overrideProvider(token, provider);\n        return TestBedViewEngine;\n    };\n    TestBedViewEngine.deprecatedOverrideProvider = function (token, provider) {\n        _getTestBedViewEngine().deprecatedOverrideProvider(token, provider);\n        return TestBedViewEngine;\n    };\n    TestBedViewEngine.get = function (token, notFoundValue) {\n        if (notFoundValue === void 0) { notFoundValue = Injector.THROW_IF_NOT_FOUND; }\n        return _getTestBedViewEngine().get(token, notFoundValue);\n    };\n    TestBedViewEngine.createComponent = function (component) {\n        return _getTestBedViewEngine().createComponent(component);\n    };\n    /**\n     * Initialize the environment for testing with a compiler factory, a PlatformRef, and an\n     * angular module. These are common to every test in the suite.\n     *\n     * This may only be called once, to set up the common providers for the current test\n     * suite on the current platform. If you absolutely need to change the providers,\n     * first use `resetTestEnvironment`.\n     *\n     * Test modules and platforms for individual platforms are available from\n     * '@angular/<platform_name>/testing'.\n     *\n     * @experimental\n     */\n    TestBedViewEngine.prototype.initTestEnvironment = function (ngModule, platform, aotSummaries) {\n        if (this.platform || this.ngModule) {\n            throw new Error('Cannot set base providers because it has already been called');\n        }\n        this.platform = platform;\n        this.ngModule = ngModule;\n        if (aotSummaries) {\n            this._testEnvAotSummaries = aotSummaries;\n        }\n    };\n    /**\n     * Reset the providers for the test injector.\n     *\n     * @experimental\n     */\n    TestBedViewEngine.prototype.resetTestEnvironment = function () {\n        this.resetTestingModule();\n        this.platform = null;\n        this.ngModule = null;\n        this._testEnvAotSummaries = function () { return []; };\n    };\n    TestBedViewEngine.prototype.resetTestingModule = function () {\n        clearOverrides();\n        this._aotSummaries = [];\n        this._templateOverrides = [];\n        this._compiler = null;\n        this._moduleOverrides = [];\n        this._componentOverrides = [];\n        this._directiveOverrides = [];\n        this._pipeOverrides = [];\n        this._isRoot = true;\n        this._rootProviderOverrides = [];\n        this._moduleRef = null;\n        this._moduleFactory = null;\n        this._compilerOptions = [];\n        this._providers = [];\n        this._declarations = [];\n        this._imports = [];\n        this._schemas = [];\n        this._instantiated = false;\n        this._activeFixtures.forEach(function (fixture) {\n            try {\n                fixture.destroy();\n            }\n            catch (e) {\n                console.error('Error during cleanup of component', {\n                    component: fixture.componentInstance,\n                    stacktrace: e,\n                });\n            }\n        });\n        this._activeFixtures = [];\n    };\n    TestBedViewEngine.prototype.configureCompiler = function (config) {\n        this._assertNotInstantiated('TestBed.configureCompiler', 'configure the compiler');\n        this._compilerOptions.push(config);\n    };\n    TestBedViewEngine.prototype.configureTestingModule = function (moduleDef) {\n        var _a, _b, _c, _d;\n        this._assertNotInstantiated('TestBed.configureTestingModule', 'configure the test module');\n        if (moduleDef.providers) {\n            (_a = this._providers).push.apply(_a, moduleDef.providers);\n        }\n        if (moduleDef.declarations) {\n            (_b = this._declarations).push.apply(_b, moduleDef.declarations);\n        }\n        if (moduleDef.imports) {\n            (_c = this._imports).push.apply(_c, moduleDef.imports);\n        }\n        if (moduleDef.schemas) {\n            (_d = this._schemas).push.apply(_d, moduleDef.schemas);\n        }\n        if (moduleDef.aotSummaries) {\n            this._aotSummaries.push(moduleDef.aotSummaries);\n        }\n    };\n    TestBedViewEngine.prototype.compileComponents = function () {\n        var _this = this;\n        if (this._moduleFactory || this._instantiated) {\n            return Promise.resolve(null);\n        }\n        var moduleType = this._createCompilerAndModule();\n        return this._compiler.compileModuleAndAllComponentsAsync(moduleType)\n            .then(function (moduleAndComponentFactories) {\n            _this._moduleFactory = moduleAndComponentFactories.ngModuleFactory;\n        });\n    };\n    TestBedViewEngine.prototype._initIfNeeded = function () {\n        if (this._instantiated) {\n            return;\n        }\n        if (!this._moduleFactory) {\n            try {\n                var moduleType = this._createCompilerAndModule();\n                this._moduleFactory =\n                    this._compiler.compileModuleAndAllComponentsSync(moduleType).ngModuleFactory;\n            }\n            catch (e) {\n                var errorCompType = this._compiler.getComponentFromError(e);\n                if (errorCompType) {\n                    throw new Error(\"This test module uses the component \" + stringify(errorCompType) + \" which is using a \\\"templateUrl\\\" or \\\"styleUrls\\\", but they were never compiled. \" +\n                        \"Please call \\\"TestBed.compileComponents\\\" before your test.\");\n                }\n                else {\n                    throw e;\n                }\n            }\n        }\n        for (var _i = 0, _a = this._templateOverrides; _i < _a.length; _i++) {\n            var _b = _a[_i], component = _b.component, templateOf = _b.templateOf;\n            var compFactory = this._compiler.getComponentFactory(templateOf);\n            overrideComponentView(component, compFactory);\n        }\n        var ngZone = new NgZone({ enableLongStackTrace: true });\n        var providers = [{ provide: NgZone, useValue: ngZone }];\n        var ngZoneInjector = Injector.create({\n            providers: providers,\n            parent: this.platform.injector,\n            name: this._moduleFactory.moduleType.name\n        });\n        this._moduleRef = this._moduleFactory.create(ngZoneInjector);\n        // ApplicationInitStatus.runInitializers() is marked @internal to core. So casting to any\n        // before accessing it.\n        this._moduleRef.injector.get(ApplicationInitStatus).runInitializers();\n        this._instantiated = true;\n    };\n    TestBedViewEngine.prototype._createCompilerAndModule = function () {\n        var _this = this;\n        var providers = this._providers.concat([{ provide: TestBed, useValue: this }]);\n        var declarations = this._declarations.concat(this._templateOverrides.map(function (entry) { return entry.templateOf; }));\n        var rootScopeImports = [];\n        var rootProviderOverrides = this._rootProviderOverrides;\n        if (this._isRoot) {\n            var RootScopeModule = /** @class */ (function () {\n                function RootScopeModule() {\n                }\n                RootScopeModule = tslib_1.__decorate([\n                    NgModule({\n                        providers: rootProviderOverrides.slice(),\n                        jit: true,\n                    })\n                ], RootScopeModule);\n                return RootScopeModule;\n            }());\n            rootScopeImports.push(RootScopeModule);\n        }\n        providers.push({ provide: APP_ROOT, useValue: this._isRoot });\n        var imports = [rootScopeImports, this.ngModule, this._imports];\n        var schemas = this._schemas;\n        var DynamicTestModule = /** @class */ (function () {\n            function DynamicTestModule() {\n            }\n            DynamicTestModule = tslib_1.__decorate([\n                NgModule({ providers: providers, declarations: declarations, imports: imports, schemas: schemas, jit: true })\n            ], DynamicTestModule);\n            return DynamicTestModule;\n        }());\n        var compilerFactory = this.platform.injector.get(TestingCompilerFactory);\n        this._compiler = compilerFactory.createTestingCompiler(this._compilerOptions);\n        for (var _i = 0, _a = [this._testEnvAotSummaries].concat(this._aotSummaries); _i < _a.length; _i++) {\n            var summary = _a[_i];\n            this._compiler.loadAotSummaries(summary);\n        }\n        this._moduleOverrides.forEach(function (entry) { return _this._compiler.overrideModule(entry[0], entry[1]); });\n        this._componentOverrides.forEach(function (entry) { return _this._compiler.overrideComponent(entry[0], entry[1]); });\n        this._directiveOverrides.forEach(function (entry) { return _this._compiler.overrideDirective(entry[0], entry[1]); });\n        this._pipeOverrides.forEach(function (entry) { return _this._compiler.overridePipe(entry[0], entry[1]); });\n        return DynamicTestModule;\n    };\n    TestBedViewEngine.prototype._assertNotInstantiated = function (methodName, methodDescription) {\n        if (this._instantiated) {\n            throw new Error(\"Cannot \" + methodDescription + \" when the test module has already been instantiated. \" +\n                (\"Make sure you are not using `inject` before `\" + methodName + \"`.\"));\n        }\n    };\n    TestBedViewEngine.prototype.get = function (token, notFoundValue) {\n        if (notFoundValue === void 0) { notFoundValue = Injector.THROW_IF_NOT_FOUND; }\n        this._initIfNeeded();\n        if (token === TestBed) {\n            return this;\n        }\n        // Tests can inject things from the ng module and from the compiler,\n        // but the ng module can't inject things from the compiler and vice versa.\n        var result = this._moduleRef.injector.get(token, UNDEFINED);\n        return result === UNDEFINED ? this._compiler.injector.get(token, notFoundValue) : result;\n    };\n    TestBedViewEngine.prototype.execute = function (tokens, fn, context) {\n        var _this = this;\n        this._initIfNeeded();\n        var params = tokens.map(function (t) { return _this.get(t); });\n        return fn.apply(context, params);\n    };\n    TestBedViewEngine.prototype.overrideModule = function (ngModule, override) {\n        this._assertNotInstantiated('overrideModule', 'override module metadata');\n        this._moduleOverrides.push([ngModule, override]);\n    };\n    TestBedViewEngine.prototype.overrideComponent = function (component, override) {\n        this._assertNotInstantiated('overrideComponent', 'override component metadata');\n        this._componentOverrides.push([component, override]);\n    };\n    TestBedViewEngine.prototype.overrideDirective = function (directive, override) {\n        this._assertNotInstantiated('overrideDirective', 'override directive metadata');\n        this._directiveOverrides.push([directive, override]);\n    };\n    TestBedViewEngine.prototype.overridePipe = function (pipe, override) {\n        this._assertNotInstantiated('overridePipe', 'override pipe metadata');\n        this._pipeOverrides.push([pipe, override]);\n    };\n    TestBedViewEngine.prototype.overrideProvider = function (token, provider) {\n        this.overrideProviderImpl(token, provider);\n    };\n    TestBedViewEngine.prototype.deprecatedOverrideProvider = function (token, provider) {\n        this.overrideProviderImpl(token, provider, /* deprecated */ true);\n    };\n    TestBedViewEngine.prototype.overrideProviderImpl = function (token, provider, deprecated) {\n        if (deprecated === void 0) { deprecated = false; }\n        if (typeof token !== 'string' && token.ngInjectableDef &&\n            token.ngInjectableDef.providedIn === 'root') {\n            if (provider.useFactory) {\n                this._rootProviderOverrides.push({ provide: token, useFactory: provider.useFactory, deps: provider.deps || [] });\n            }\n            else {\n                this._rootProviderOverrides.push({ provide: token, useValue: provider.useValue });\n            }\n        }\n        var flags = 0;\n        var value;\n        if (provider.useFactory) {\n            flags |= 1024 /* TypeFactoryProvider */;\n            value = provider.useFactory;\n        }\n        else {\n            flags |= 256 /* TypeValueProvider */;\n            value = provider.useValue;\n        }\n        var deps = (provider.deps || []).map(function (dep) {\n            var depFlags = 0 /* None */;\n            var depToken;\n            if (Array.isArray(dep)) {\n                dep.forEach(function (entry) {\n                    if (entry instanceof Optional) {\n                        depFlags |= 2 /* Optional */;\n                    }\n                    else if (entry instanceof SkipSelf) {\n                        depFlags |= 1 /* SkipSelf */;\n                    }\n                    else {\n                        depToken = entry;\n                    }\n                });\n            }\n            else {\n                depToken = dep;\n            }\n            return [depFlags, depToken];\n        });\n        overrideProvider({ token: token, flags: flags, deps: deps, value: value, deprecatedBehavior: deprecated });\n    };\n    TestBedViewEngine.prototype.overrideTemplateUsingTestingModule = function (component, template) {\n        this._assertNotInstantiated('overrideTemplateUsingTestingModule', 'override template');\n        var OverrideComponent = /** @class */ (function () {\n            function OverrideComponent() {\n            }\n            OverrideComponent = tslib_1.__decorate([\n                Component({ selector: 'empty', template: template, jit: true })\n            ], OverrideComponent);\n            return OverrideComponent;\n        }());\n        this._templateOverrides.push({ component: component, templateOf: OverrideComponent });\n    };\n    TestBedViewEngine.prototype.createComponent = function (component) {\n        var _this = this;\n        this._initIfNeeded();\n        var componentFactory = this._compiler.getComponentFactory(component);\n        if (!componentFactory) {\n            throw new Error(\"Cannot create the component \" + stringify(component) + \" as it was not imported into the testing module!\");\n        }\n        var noNgZone = this.get(ComponentFixtureNoNgZone, false);\n        var autoDetect = this.get(ComponentFixtureAutoDetect, false);\n        var ngZone = noNgZone ? null : this.get(NgZone, null);\n        var testComponentRenderer = this.get(TestComponentRenderer);\n        var rootElId = \"root\" + _nextRootElementId++;\n        testComponentRenderer.insertRootElement(rootElId);\n        var initComponent = function () {\n            var componentRef = componentFactory.create(Injector.NULL, [], \"#\" + rootElId, _this._moduleRef);\n            return new ComponentFixture(componentRef, ngZone, autoDetect);\n        };\n        var fixture = !ngZone ? initComponent() : ngZone.run(initComponent);\n        this._activeFixtures.push(fixture);\n        return fixture;\n    };\n    return TestBedViewEngine;\n}());\nexport { TestBedViewEngine };\n/**\n * @description\n * Configures and initializes environment for unit testing and provides methods for\n * creating components and services in unit tests.\n *\n * `TestBed` is the primary api for writing unit tests for Angular applications and libraries.\n *\n * Note: Use `TestBed` in tests. It will be set to either `TestBedViewEngine` or `TestBedRender3`\n * according to the compiler used.\n */\nexport var TestBed = ivyEnabled ? TestBedRender3 : TestBedViewEngine;\n/**\n * Returns a singleton of the applicable `TestBed`.\n *\n * It will be either an instance of `TestBedViewEngine` or `TestBedRender3`.\n *\n * @experimental\n */\nexport var getTestBed = ivyEnabled ? _getTestBedRender3 : _getTestBedViewEngine;\nvar testBed;\nfunction _getTestBedViewEngine() {\n    return testBed = testBed || new TestBedViewEngine();\n}\n/**\n * Allows injecting dependencies in `beforeEach()` and `it()`.\n *\n * Example:\n *\n * ```\n * beforeEach(inject([Dependency, AClass], (dep, object) => {\n *   // some code that uses `dep` and `object`\n *   // ...\n * }));\n *\n * it('...', inject([AClass], (object) => {\n *   object.doSomething();\n *   expect(...);\n * })\n * ```\n *\n * Notes:\n * - inject is currently a function because of some Traceur limitation the syntax should\n * eventually\n *   becomes `it('...', @Inject (object: AClass, async: AsyncTestCompleter) => { ... });`\n *\n *\n */\nexport function inject(tokens, fn) {\n    var testBed = getTestBed();\n    if (tokens.indexOf(AsyncTestCompleter) >= 0) {\n        // Not using an arrow function to preserve context passed from call site\n        return function () {\n            var _this = this;\n            // Return an async test method that returns a Promise if AsyncTestCompleter is one of\n            // the injected tokens.\n            return testBed.compileComponents().then(function () {\n                var completer = testBed.get(AsyncTestCompleter);\n                testBed.execute(tokens, fn, _this);\n                return completer.promise;\n            });\n        };\n    }\n    else {\n        // Not using an arrow function to preserve context passed from call site\n        return function () { return testBed.execute(tokens, fn, this); };\n    }\n}\n/**\n * @experimental\n */\nvar InjectSetupWrapper = /** @class */ (function () {\n    function InjectSetupWrapper(_moduleDef) {\n        this._moduleDef = _moduleDef;\n    }\n    InjectSetupWrapper.prototype._addModule = function () {\n        var moduleDef = this._moduleDef();\n        if (moduleDef) {\n            getTestBed().configureTestingModule(moduleDef);\n        }\n    };\n    InjectSetupWrapper.prototype.inject = function (tokens, fn) {\n        var self = this;\n        // Not using an arrow function to preserve context passed from call site\n        return function () {\n            self._addModule();\n            return inject(tokens, fn).call(this);\n        };\n    };\n    return InjectSetupWrapper;\n}());\nexport { InjectSetupWrapper };\nexport function withModule(moduleDef, fn) {\n    if (fn) {\n        // Not using an arrow function to preserve context passed from call site\n        return function () {\n            var testBed = getTestBed();\n            if (moduleDef) {\n                testBed.configureTestingModule(moduleDef);\n            }\n            return fn.apply(this);\n        };\n    }\n    return new InjectSetupWrapper(function () { return moduleDef; });\n}\n//# sourceMappingURL=test_bed.js.map","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Public Test Library for unit testing Angular applications. Assumes that you are running\n * with Jasmine, Mocha, or a similar framework which exports a beforeEach function and\n * allows tests to be asynchronous by either returning a promise or using a 'done' parameter.\n */\nimport { resetFakeAsyncZone } from './fake_async';\nimport { TestBed } from './test_bed';\nvar _global = (typeof window === 'undefined' ? global : window);\n// Reset the test providers and the fake async zone before each test.\nif (_global.beforeEach) {\n    _global.beforeEach(function () {\n        TestBed.resetTestingModule();\n        resetFakeAsyncZone();\n    });\n}\n// TODO(juliemr): remove this, only used because we need to export something to have compilation\n// work.\nexport var __core_private_testing_placeholder__ = '';\n//# sourceMappingURL=before_each.js.map","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { asyncFallback } from './async_fallback';\n/**\n * Wraps a test function in an asynchronous test zone. The test will automatically\n * complete when all asynchronous calls within this zone are done. Can be used\n * to wrap an {@link inject} call.\n *\n * Example:\n *\n * ```\n * it('...', async(inject([AClass], (object) => {\n *   object.doSomething.then(() => {\n *     expect(...);\n *   })\n * });\n * ```\n *\n *\n */\nexport function async(fn) {\n    var _Zone = typeof Zone !== 'undefined' ? Zone : null;\n    if (!_Zone) {\n        return function () {\n            return Promise.reject('Zone is needed for the async() test helper but could not be found. ' +\n                'Please make sure that your environment includes zone.js/dist/zone.js');\n        };\n    }\n    var asyncTest = _Zone && _Zone[_Zone.__symbol__('asyncTest')];\n    if (typeof asyncTest === 'function') {\n        return asyncTest(fn);\n    }\n    // not using new version of zone.js\n    // TODO @JiaLiPassion, remove this after all library updated to\n    // newest version of zone.js(0.8.25)\n    return asyncFallback(fn);\n}\n//# sourceMappingURL=async.js.map"]}