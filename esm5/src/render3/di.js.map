{"version":3,"file":"di.js","sourceRoot":"","sources":["../../../../../../packages/core/src/render3/di.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n// We are temporarily importing the existing viewEngine_from core so we can be sure we are\n// correctly implementing its interfaces for backwards compatibility.\n\nimport {getInjectableDef, getInjectorDef} from '../di/defs';\nimport {InjectionToken} from '../di/injection_token';\nimport {InjectFlags, Injector, inject, setCurrentInjector} from '../di/injector';\nimport {Type} from '../type';\n\nimport {assertDefined} from './assert';\nimport {getComponentDef, getDirectiveDef, getPipeDef} from './definition';\nimport {NG_ELEMENT_ID} from './fields';\nimport {_getViewData, getPreviousOrParentTNode, resolveDirective, setEnvironment} from './instructions';\nimport {DirectiveDef} from './interfaces/definition';\nimport {InjectorLocationFlags, PARENT_INJECTOR, TNODE,} from './interfaces/injector';\nimport {AttributeMarker, TContainerNode, TElementContainerNode, TElementNode, TNode, TNodeFlags, TNodeType} from './interfaces/node';\nimport {DECLARATION_VIEW, HOST_NODE, INJECTOR, LViewData, TData, TVIEW, TView} from './interfaces/view';\nimport {assertNodeOfPossibleTypes} from './node_assert';\n\n/**\n * The number of slots in each bloom filter (used by DI). The larger this number, the fewer\n * directives that will share slots, and thus, the fewer false positives when checking for\n * the existence of a directive.\n */\nconst BLOOM_SIZE = 256;\nconst BLOOM_MASK = BLOOM_SIZE - 1;\n\n/** Counter used to generate unique IDs for directives. */\nlet nextNgElementId = 0;\n\n/**\n * Registers this directive as present in its node's injector by flipping the directive's\n * corresponding bit in the injector's bloom filter.\n *\n * @param injectorIndex The index of the node injector where this token should be registered\n * @param tView The TView for the injector's bloom filters\n * @param type The directive token to register\n */\nexport function bloomAdd(injectorIndex: number, tView: TView, type: Type<any>): void {\n  if (tView.firstTemplatePass) {\n    let id: number|undefined = (type as any)[NG_ELEMENT_ID];\n\n    // Set a unique ID on the directive type, so if something tries to inject the directive,\n    // we can easily retrieve the ID and hash it into the bloom bit that should be checked.\n    if (id == null) {\n      id = (type as any)[NG_ELEMENT_ID] = nextNgElementId++;\n    }\n\n    // We only have BLOOM_SIZE (256) slots in our bloom filter (8 buckets * 32 bits each),\n    // so all unique IDs must be modulo-ed into a number from 0 - 255 to fit into the filter.\n    const bloomBit = id & BLOOM_MASK;\n\n    // Create a mask that targets the specific bit associated with the directive.\n    // JS bit operations are 32 bits, so this will be a number between 2^0 and 2^31, corresponding\n    // to bit positions 0 - 31 in a 32 bit integer.\n    const mask = 1 << bloomBit;\n\n    // Use the raw bloomBit number to determine which bloom filter bucket we should check\n    // e.g: bf0 = [0 - 31], bf1 = [32 - 63], bf2 = [64 - 95], bf3 = [96 - 127], etc\n    const b7 = bloomBit & 0x80;\n    const b6 = bloomBit & 0x40;\n    const b5 = bloomBit & 0x20;\n    const tData = tView.data as number[];\n\n    if (b7) {\n      b6 ? (b5 ? (tData[injectorIndex + 7] |= mask) : (tData[injectorIndex + 6] |= mask)) :\n           (b5 ? (tData[injectorIndex + 5] |= mask) : (tData[injectorIndex + 4] |= mask));\n    } else {\n      b6 ? (b5 ? (tData[injectorIndex + 3] |= mask) : (tData[injectorIndex + 2] |= mask)) :\n           (b5 ? (tData[injectorIndex + 1] |= mask) : (tData[injectorIndex] |= mask));\n    }\n  }\n}\n\nexport function getOrCreateNodeInjector(): number {\n  return getOrCreateNodeInjectorForNode(\n      getPreviousOrParentTNode() as TElementNode | TElementContainerNode | TContainerNode,\n      _getViewData());\n}\n\n/**\n * Creates (or gets an existing) injector for a given element or container.\n *\n * @param tNode for which an injector should be retrieved / created.\n * @param hostView View where the node is stored\n * @returns Node injector\n */\nexport function getOrCreateNodeInjectorForNode(\n    tNode: TElementNode | TContainerNode | TElementContainerNode, hostView: LViewData): number {\n  const existingInjectorIndex = getInjectorIndex(tNode, hostView);\n  if (existingInjectorIndex !== -1) {\n    return existingInjectorIndex;\n  }\n\n  const tView = hostView[TVIEW];\n  if (tView.firstTemplatePass) {\n    tNode.injectorIndex = hostView.length;\n    setUpBloom(tView.data, tNode);  // foundation for node bloom\n    setUpBloom(hostView, null);     // foundation for cumulative bloom\n    setUpBloom(tView.blueprint, null);\n  }\n\n  const parentLoc = getParentInjectorLocation(tNode, hostView);\n  const parentIndex = parentLoc & InjectorLocationFlags.InjectorIndexMask;\n  const parentView: LViewData = getParentInjectorView(parentLoc, hostView);\n\n  const parentData = parentView[TVIEW].data as any;\n  const injectorIndex = tNode.injectorIndex;\n\n  // If a parent injector can't be found, its location is set to -1.\n  // In that case, we don't need to set up a cumulative bloom\n  if (parentLoc !== -1) {\n    for (let i = 0; i < PARENT_INJECTOR; i++) {\n      const bloomIndex = parentIndex + i;\n      // Creates a cumulative bloom filter that merges the parent's bloom filter\n      // and its own cumulative bloom (which contains tokens for all ancestors)\n      hostView[injectorIndex + i] = parentView[bloomIndex] | parentData[bloomIndex];\n    }\n  }\n\n  hostView[injectorIndex + PARENT_INJECTOR] = parentLoc;\n  return injectorIndex;\n}\n\nfunction setUpBloom(arr: any[], footer: TNode | null) {\n  arr.push(0, 0, 0, 0, 0, 0, 0, 0, footer);\n}\n\nexport function getInjectorIndex(tNode: TNode, hostView: LViewData): number {\n  if (tNode.injectorIndex === -1 ||\n      // If the injector index is the same as its parent's injector index, then the index has been\n      // copied down from the parent node. No injector has been created yet on this node.\n      (tNode.parent && tNode.parent.injectorIndex === tNode.injectorIndex) ||\n      // After the first template pass, the injector index might exist but the parent values\n      // might not have been calculated yet for this instance\n      hostView[tNode.injectorIndex + PARENT_INJECTOR] == null) {\n    return -1;\n  } else {\n    return tNode.injectorIndex;\n  }\n}\n\n/**\n * Finds the index of the parent injector, with a view offset if applicable. Used to set the\n * parent injector initially.\n */\nexport function getParentInjectorLocation(tNode: TNode, view: LViewData): number {\n  if (tNode.parent && tNode.parent.injectorIndex !== -1) {\n    return tNode.parent.injectorIndex;  // view offset is 0\n  }\n\n  // For most cases, the parent injector index can be found on the host node (e.g. for component\n  // or container), so this loop will be skipped, but we must keep the loop here to support\n  // the rarer case of deeply nested <ng-template> tags or inline views.\n  let hostTNode = view[HOST_NODE];\n  let viewOffset = 1;\n  while (hostTNode && hostTNode.injectorIndex === -1) {\n    view = view[DECLARATION_VIEW] !;\n    hostTNode = view[HOST_NODE] !;\n    viewOffset++;\n  }\n  return hostTNode ?\n      hostTNode.injectorIndex | (viewOffset << InjectorLocationFlags.ViewOffsetShift) :\n      -1;\n}\n\n/**\n * Unwraps a parent injector location number to find the view offset from the current injector,\n * then walks up the declaration view tree until the view is found that contains the parent\n * injector.\n *\n * @param location The location of the parent injector, which contains the view offset\n * @param startView The LViewData instance from which to start walking up the view tree\n * @returns The LViewData instance that contains the parent injector\n */\nexport function getParentInjectorView(location: number, startView: LViewData): LViewData {\n  let viewOffset = location >> InjectorLocationFlags.ViewOffsetShift;\n  let parentView = startView;\n  // For most cases, the parent injector can be found on the host node (e.g. for component\n  // or container), but we must keep the loop here to support the rarer case of deeply nested\n  // <ng-template> tags or inline views, where the parent injector might live many views\n  // above the child injector.\n  while (viewOffset > 0) {\n    parentView = parentView[DECLARATION_VIEW] !;\n    viewOffset--;\n  }\n  return parentView;\n}\n\n/**\n * Makes a directive public to the DI system by adding it to an injector's bloom filter.\n *\n * @param di The node injector in which a directive will be added\n * @param def The definition of the directive to be made public\n */\nexport function diPublicInInjector(\n    injectorIndex: number, view: LViewData, def: DirectiveDef<any>): void {\n  bloomAdd(injectorIndex, view[TVIEW], def.type);\n}\n\n/**\n * Makes a directive public to the DI system by adding it to an injector's bloom filter.\n *\n * @param def The definition of the directive to be made public\n */\nexport function diPublic(def: DirectiveDef<any>): void {\n  diPublicInInjector(getOrCreateNodeInjector(), _getViewData(), def);\n}\n\n/**\n * Returns the value associated to the given token from the injectors.\n *\n * `directiveInject` is intended to be used for directive, component and pipe factories.\n *  All other injection use `inject` which does not walk the node injector tree.\n *\n * Usage example (in factory function):\n *\n * class SomeDirective {\n *   constructor(directive: DirectiveA) {}\n *\n *   static ngDirectiveDef = defineDirective({\n *     type: SomeDirective,\n *     factory: () => new SomeDirective(directiveInject(DirectiveA))\n *   });\n * }\n *\n * @param token the type or token to inject\n * @param flags Injection flags\n * @returns the value from the injector or `null` when not found\n */\nexport function directiveInject<T>(token: Type<T>| InjectionToken<T>): T;\nexport function directiveInject<T>(token: Type<T>| InjectionToken<T>, flags: InjectFlags): T;\nexport function directiveInject<T>(\n    token: Type<T>| InjectionToken<T>, flags = InjectFlags.Default): T|null {\n  const hostTNode =\n      getPreviousOrParentTNode() as TElementNode | TContainerNode | TElementContainerNode;\n  return getOrCreateInjectable<T>(hostTNode, _getViewData(), token, flags);\n}\n\n/**\n * Inject static attribute value into directive constructor.\n *\n * This method is used with `factory` functions which are generated as part of\n * `defineDirective` or `defineComponent`. The method retrieves the static value\n * of an attribute. (Dynamic attributes are not supported since they are not resolved\n *  at the time of injection and can change over time.)\n *\n * # Example\n * Given:\n * ```\n * @Component(...)\n * class MyComponent {\n *   constructor(@Attribute('title') title: string) { ... }\n * }\n * ```\n * When instantiated with\n * ```\n * <my-component title=\"Hello\"></my-component>\n * ```\n *\n * Then factory method generated is:\n * ```\n * MyComponent.ngComponentDef = defineComponent({\n *   factory: () => new MyComponent(injectAttribute('title'))\n *   ...\n * })\n * ```\n *\n * @experimental\n */\nexport function injectAttribute(attrNameToInject: string): string|undefined {\n  const tNode = getPreviousOrParentTNode();\n  ngDevMode && assertNodeOfPossibleTypes(\n                   tNode, TNodeType.Container, TNodeType.Element, TNodeType.ElementContainer);\n  ngDevMode && assertDefined(tNode, 'expecting tNode');\n  const attrs = tNode.attrs;\n  if (attrs) {\n    for (let i = 0; i < attrs.length; i = i + 2) {\n      const attrName = attrs[i];\n      if (attrName === AttributeMarker.SelectOnly) break;\n      if (attrName == attrNameToInject) {\n        return attrs[i + 1] as string;\n      }\n    }\n  }\n  return undefined;\n}\n\n\n/**\n * Returns the value associated to the given token from the injectors.\n *\n * Look for the injector providing the token by walking up the node injector tree and then\n * the module injector tree.\n *\n * @param nodeInjector Node injector where the search should start\n * @param token The token to look for\n * @param flags Injection flags\n * @returns the value from the injector or `null` when not found\n */\nexport function getOrCreateInjectable<T>(\n    hostTNode: TElementNode | TContainerNode | TElementContainerNode, hostView: LViewData,\n    token: Type<T>| InjectionToken<T>, flags: InjectFlags = InjectFlags.Default): T|null {\n  const bloomHash = bloomHashBitOrFactory(token);\n  // If the ID stored here is a function, this is a special object like ElementRef or TemplateRef\n  // so just call the factory function to create it.\n  if (typeof bloomHash === 'function') return bloomHash();\n\n  // If the token has a bloom hash, then it is a directive that is public to the injection system\n  // (diPublic) otherwise fall back to the module injector.\n  if (bloomHash != null) {\n    const startInjectorIndex = getInjectorIndex(hostTNode, hostView);\n\n    let injectorIndex = startInjectorIndex;\n    let injectorView = hostView;\n    let parentLocation: number = -1;\n\n    // If we should skip this injector or if an injector doesn't exist on this node (e.g. all\n    // directives on this node are private), start by searching the parent injector.\n    if (flags & InjectFlags.SkipSelf || injectorIndex === -1) {\n      parentLocation = injectorIndex === -1 ? getParentInjectorLocation(hostTNode, hostView) :\n                                              injectorView[injectorIndex + PARENT_INJECTOR];\n\n      if (shouldNotSearchParent(flags, parentLocation)) {\n        injectorIndex = -1;\n      } else {\n        injectorIndex = parentLocation & InjectorLocationFlags.InjectorIndexMask;\n        injectorView = getParentInjectorView(parentLocation, injectorView);\n      }\n    }\n\n    while (injectorIndex !== -1) {\n      // Traverse up the injector tree until we find a potential match or until we know there\n      // *isn't* a match. Outer loop is necessary in case we get a false positive injector.\n      while (injectorIndex !== -1) {\n        // Check the current injector. If it matches, stop searching for an injector.\n        if (injectorHasToken(bloomHash, injectorIndex, injectorView[TVIEW].data)) {\n          break;\n        }\n\n        parentLocation = injectorView[injectorIndex + PARENT_INJECTOR];\n        if (shouldNotSearchParent(flags, parentLocation)) {\n          injectorIndex = -1;\n          break;\n        }\n\n        // If the ancestor bloom filter value has the bit corresponding to the directive, traverse\n        // up to find the specific injector. If the ancestor bloom filter does not have the bit, we\n        // can abort.\n        if (injectorHasToken(bloomHash, injectorIndex, injectorView)) {\n          injectorIndex = parentLocation & InjectorLocationFlags.InjectorIndexMask;\n          injectorView = getParentInjectorView(parentLocation, injectorView);\n        } else {\n          injectorIndex = -1;\n          break;\n        }\n      }\n\n      // If no injector is found, we *know* that there is no ancestor injector that contains the\n      // token, so we abort.\n      if (injectorIndex === -1) {\n        break;\n      }\n\n      // At this point, we have an injector which *may* contain the token, so we step through the\n      // directives associated with the injector's corresponding node to get the directive instance.\n      let instance: T|null;\n      if (instance = searchDirectivesOnInjector<T>(injectorIndex, injectorView, token)) {\n        return instance;\n      }\n\n      // If we *didn't* find the directive for the token and we are searching the current node's\n      // injector, it's possible the directive is on this node and hasn't been created yet.\n      if (injectorIndex === startInjectorIndex && hostView === injectorView &&\n          (instance = searchMatchesQueuedForCreation<T>(token, injectorView[TVIEW]))) {\n        return instance;\n      }\n\n      // The def wasn't found anywhere on this node, so it was a false positive.\n      // Traverse up the tree and continue searching.\n      injectorIndex = parentLocation & InjectorLocationFlags.InjectorIndexMask;\n      injectorView = getParentInjectorView(parentLocation, injectorView);\n    }\n  }\n\n  const moduleInjector = hostView[INJECTOR];\n  const formerInjector = setCurrentInjector(moduleInjector);\n  try {\n    return inject(token, flags);\n  } finally {\n    setCurrentInjector(formerInjector);\n  }\n}\n\nfunction searchMatchesQueuedForCreation<T>(token: any, hostTView: TView): T|null {\n  const matches = hostTView.currentMatches;\n  if (matches) {\n    for (let i = 0; i < matches.length; i += 2) {\n      const def = matches[i] as DirectiveDef<any>;\n      if (def.type === token) {\n        return resolveDirective(def, i + 1, matches);\n      }\n    }\n  }\n  return null;\n}\n\nfunction searchDirectivesOnInjector<T>(\n    injectorIndex: number, injectorView: LViewData, token: Type<T>| InjectionToken<T>) {\n  const tNode = injectorView[TVIEW].data[injectorIndex + TNODE] as TNode;\n  const nodeFlags = tNode.flags;\n  const count = nodeFlags & TNodeFlags.DirectiveCountMask;\n\n  if (count !== 0) {\n    const start = nodeFlags >> TNodeFlags.DirectiveStartingIndexShift;\n    const end = start + count;\n    const defs = injectorView[TVIEW].data;\n\n    for (let i = start; i < end; i++) {\n      // Get the definition for the directive at this index and, if it is injectable (diPublic),\n      // and matches the given token, return the directive instance.\n      const directiveDef = defs[i] as DirectiveDef<any>;\n      if (directiveDef.type === token && directiveDef.diPublic) {\n        return injectorView[i];\n      }\n    }\n  }\n  return null;\n}\n\n/**\n * Returns the bit in an injector's bloom filter that should be used to determine whether or not\n * the directive might be provided by the injector.\n *\n * When a directive is public, it is added to the bloom filter and given a unique ID that can be\n * retrieved on the Type. When the directive isn't public or the token is not a directive `null`\n * is returned as the node injector can not possibly provide that token.\n *\n * @param token the injection token\n * @returns the matching bit to check in the bloom filter or `null` if the token is not known.\n */\nexport function bloomHashBitOrFactory(token: Type<any>| InjectionToken<any>): number|Function|\n    undefined {\n  const tokenId: number|undefined = (token as any)[NG_ELEMENT_ID];\n  return typeof tokenId === 'number' ? tokenId & BLOOM_MASK : tokenId;\n}\n\nexport function injectorHasToken(\n    bloomHash: number, injectorIndex: number, injectorView: LViewData | TData) {\n  // Create a mask that targets the specific bit associated with the directive we're looking for.\n  // JS bit operations are 32 bits, so this will be a number between 2^0 and 2^31, corresponding\n  // to bit positions 0 - 31 in a 32 bit integer.\n  const mask = 1 << bloomHash;\n  const b7 = bloomHash & 0x80;\n  const b6 = bloomHash & 0x40;\n  const b5 = bloomHash & 0x20;\n\n  // Our bloom filter size is 256 bits, which is eight 32-bit bloom filter buckets:\n  // bf0 = [0 - 31], bf1 = [32 - 63], bf2 = [64 - 95], bf3 = [96 - 127], etc.\n  // Get the bloom filter value from the appropriate bucket based on the directive's bloomBit.\n  let value: number;\n\n  if (b7) {\n    value = b6 ? (b5 ? injectorView[injectorIndex + 7] : injectorView[injectorIndex + 6]) :\n                 (b5 ? injectorView[injectorIndex + 5] : injectorView[injectorIndex + 4]);\n  } else {\n    value = b6 ? (b5 ? injectorView[injectorIndex + 3] : injectorView[injectorIndex + 2]) :\n                 (b5 ? injectorView[injectorIndex + 1] : injectorView[injectorIndex]);\n  }\n\n  // If the bloom filter value has the bit corresponding to the directive's bloomBit flipped on,\n  // this injector is a potential match.\n  return !!(value & mask);\n}\n\n/** Returns true if flags prevent parent injector from being searched for tokens */\nfunction shouldNotSearchParent(flags: InjectFlags, parentLocation: number): boolean|number {\n  return flags & InjectFlags.Self ||\n      (flags & InjectFlags.Host && (parentLocation >> InjectorLocationFlags.ViewOffsetShift) > 0);\n}\n\nexport class NodeInjector implements Injector {\n  private _injectorIndex: number;\n\n  constructor(\n      private _tNode: TElementNode|TContainerNode|TElementContainerNode,\n      private _hostView: LViewData) {\n    this._injectorIndex = getOrCreateNodeInjectorForNode(_tNode, _hostView);\n  }\n\n  get(token: any): any {\n    setEnvironment(this._tNode, this._hostView);\n    return getOrCreateInjectable(this._tNode, this._hostView, token);\n  }\n}\nexport function getFactoryOf<T>(type: Type<any>): ((type?: Type<T>) => T)|null {\n  const typeAny = type as any;\n  const def = getComponentDef<T>(typeAny) || getDirectiveDef<T>(typeAny) ||\n      getPipeDef<T>(typeAny) || getInjectableDef<T>(typeAny) || getInjectorDef<T>(typeAny);\n  if (!def || def.factory === undefined) {\n    return null;\n  }\n  return def.factory;\n}\n\nexport function getInheritedFactory<T>(type: Type<any>): (type: Type<T>) => T {\n  const proto = Object.getPrototypeOf(type.prototype).constructor as Type<any>;\n  const factory = getFactoryOf<T>(proto);\n  if (factory !== null) {\n    return factory;\n  } else {\n    // There is no factory defined. Either this was improper usage of inheritance\n    // (no Angular decorator on the superclass) or there is no constructor at all\n    // in the inheritance chain. Since the two cases cannot be distinguished, the\n    // latter has to be assumed.\n    return (t) => new t();\n  }\n}\n"]}