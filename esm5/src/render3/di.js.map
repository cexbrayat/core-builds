{"version":3,"file":"di.js","sourceRoot":"","sources":["../../../../../../packages/core/src/render3/di.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n// We are temporarily importing the existing viewEngine_from core so we can be sure we are\n// correctly implementing its interfaces for backwards compatibility.\n\nimport {ChangeDetectorRef as viewEngine_ChangeDetectorRef} from '../change_detection/change_detector_ref';\nimport {InjectionToken} from '../di/injection_token';\nimport {InjectFlags, Injector, NullInjector, inject, setCurrentInjector} from '../di/injector';\nimport {ComponentFactory as viewEngine_ComponentFactory, ComponentRef as viewEngine_ComponentRef} from '../linker/component_factory';\nimport {ComponentFactoryResolver as viewEngine_ComponentFactoryResolver} from '../linker/component_factory_resolver';\nimport {ElementRef as viewEngine_ElementRef} from '../linker/element_ref';\nimport {NgModuleRef as viewEngine_NgModuleRef} from '../linker/ng_module_factory';\nimport {TemplateRef as viewEngine_TemplateRef} from '../linker/template_ref';\nimport {ViewContainerRef as viewEngine_ViewContainerRef} from '../linker/view_container_ref';\nimport {EmbeddedViewRef as viewEngine_EmbeddedViewRef, ViewRef as viewEngine_ViewRef} from '../linker/view_ref';\nimport {Renderer2} from '../render';\nimport {Type} from '../type';\n\nimport {assertDefined, assertGreaterThan, assertLessThan} from './assert';\nimport {ComponentFactoryResolver} from './component_ref';\nimport {addToViewTree, assertPreviousIsParent, createEmbeddedViewNode, createLContainer, createLNodeObject, createTNode, getPreviousOrParentNode, getRenderer, isComponent, renderEmbeddedTemplate, resolveDirective} from './instructions';\nimport {VIEWS} from './interfaces/container';\nimport {DirectiveDefInternal, RenderFlags} from './interfaces/definition';\nimport {LInjector} from './interfaces/injector';\nimport {AttributeMarker, LContainerNode, LElementContainerNode, LElementNode, LNode, LNodeWithLocalRefs, LViewNode, TContainerNode, TElementNode, TNodeFlags, TNodeType} from './interfaces/node';\nimport {LQueries, QueryReadType} from './interfaces/query';\nimport {Renderer3, isProceduralRenderer} from './interfaces/renderer';\nimport {DIRECTIVES, HOST_NODE, INJECTOR, LViewData, QUERIES, RENDERER, TVIEW, TView} from './interfaces/view';\nimport {assertNodeOfPossibleTypes, assertNodeType} from './node_assert';\nimport {addRemoveViewFromContainer, appendChild, detachView, getChildLNode, getParentLNode, insertView, removeView} from './node_manipulation';\nimport {ViewRef} from './view_ref';\n\n\n\n/**\n * If a directive is diPublic, bloomAdd sets a property on the type with this constant as\n * the key and the directive's unique ID as the value. This allows us to map directives to their\n * bloom filter bit for DI.\n */\nconst NG_ELEMENT_ID = '__NG_ELEMENT_ID__';\n\n/**\n * The number of slots in each bloom filter (used by DI). The larger this number, the fewer\n * directives that will share slots, and thus, the fewer false positives when checking for\n * the existence of a directive.\n */\nconst BLOOM_SIZE = 256;\nconst BLOOM_MASK = BLOOM_SIZE - 1;\n\n/** Counter used to generate unique IDs for directives. */\nlet nextNgElementId = 0;\n\n/**\n * Registers this directive as present in its node's injector by flipping the directive's\n * corresponding bit in the injector's bloom filter.\n *\n * @param injector The node injector in which the directive should be registered\n * @param type The directive to register\n */\nexport function bloomAdd(injector: LInjector, type: Type<any>): void {\n  let id: number|undefined = (type as any)[NG_ELEMENT_ID];\n\n  // Set a unique ID on the directive type, so if something tries to inject the directive,\n  // we can easily retrieve the ID and hash it into the bloom bit that should be checked.\n  if (id == null) {\n    id = (type as any)[NG_ELEMENT_ID] = nextNgElementId++;\n  }\n\n  // We only have BLOOM_SIZE (256) slots in our bloom filter (8 buckets * 32 bits each),\n  // so all unique IDs must be modulo-ed into a number from 0 - 255 to fit into the filter.\n  const bloomBit = id & BLOOM_MASK;\n\n  // Create a mask that targets the specific bit associated with the directive.\n  // JS bit operations are 32 bits, so this will be a number between 2^0 and 2^31, corresponding\n  // to bit positions 0 - 31 in a 32 bit integer.\n  const mask = 1 << bloomBit;\n\n  // Use the raw bloomBit number to determine which bloom filter bucket we should check\n  // e.g: bf0 = [0 - 31], bf1 = [32 - 63], bf2 = [64 - 95], bf3 = [96 - 127], etc\n  const b7 = bloomBit & 0x80;\n  const b6 = bloomBit & 0x40;\n  const b5 = bloomBit & 0x20;\n\n  if (b7) {\n    b6 ? (b5 ? (injector.bf7 |= mask) : (injector.bf6 |= mask)) :\n         (b5 ? (injector.bf5 |= mask) : (injector.bf4 |= mask));\n  } else {\n    b6 ? (b5 ? (injector.bf3 |= mask) : (injector.bf2 |= mask)) :\n         (b5 ? (injector.bf1 |= mask) : (injector.bf0 |= mask));\n  }\n}\n\nexport function getOrCreateNodeInjector(): LInjector {\n  ngDevMode && assertPreviousIsParent();\n  return getOrCreateNodeInjectorForNode(\n      getPreviousOrParentNode() as LElementNode | LElementContainerNode | LContainerNode);\n}\n\n/**\n * Creates (or gets an existing) injector for a given element or container.\n *\n * @param node for which an injector should be retrieved / created.\n * @returns Node injector\n */\nexport function getOrCreateNodeInjectorForNode(\n    node: LElementNode | LElementContainerNode | LContainerNode): LInjector {\n  const nodeInjector = node.nodeInjector;\n  const parent = getParentLNode(node);\n  const parentInjector = parent && parent.nodeInjector;\n  if (nodeInjector != parentInjector) {\n    return nodeInjector !;\n  }\n  return node.nodeInjector = {\n    parent: parentInjector,\n    node: node,\n    bf0: 0,\n    bf1: 0,\n    bf2: 0,\n    bf3: 0,\n    bf4: 0,\n    bf5: 0,\n    bf6: 0,\n    bf7: 0,\n    cbf0: parentInjector == null ? 0 : parentInjector.cbf0 | parentInjector.bf0,\n    cbf1: parentInjector == null ? 0 : parentInjector.cbf1 | parentInjector.bf1,\n    cbf2: parentInjector == null ? 0 : parentInjector.cbf2 | parentInjector.bf2,\n    cbf3: parentInjector == null ? 0 : parentInjector.cbf3 | parentInjector.bf3,\n    cbf4: parentInjector == null ? 0 : parentInjector.cbf4 | parentInjector.bf4,\n    cbf5: parentInjector == null ? 0 : parentInjector.cbf5 | parentInjector.bf5,\n    cbf6: parentInjector == null ? 0 : parentInjector.cbf6 | parentInjector.bf6,\n    cbf7: parentInjector == null ? 0 : parentInjector.cbf7 | parentInjector.bf7,\n    templateRef: null,\n    viewContainerRef: null,\n    elementRef: null,\n    changeDetectorRef: null,\n  };\n}\n\n\n/**\n * Makes a directive public to the DI system by adding it to an injector's bloom filter.\n *\n * @param di The node injector in which a directive will be added\n * @param def The definition of the directive to be made public\n */\nexport function diPublicInInjector(di: LInjector, def: DirectiveDefInternal<any>): void {\n  bloomAdd(di, def.type);\n}\n\n/**\n * Makes a directive public to the DI system by adding it to an injector's bloom filter.\n *\n * @param def The definition of the directive to be made public\n */\nexport function diPublic(def: DirectiveDefInternal<any>): void {\n  diPublicInInjector(getOrCreateNodeInjector(), def);\n}\n\n/**\n * Returns the value associated to the given token from the injectors.\n *\n * `directiveInject` is intended to be used for directive, component and pipe factories.\n *  All other injection use `inject` which does not walk the node injector tree.\n *\n * Usage example (in factory function):\n *\n * class SomeDirective {\n *   constructor(directive: DirectiveA) {}\n *\n *   static ngDirectiveDef = defineDirective({\n *     type: SomeDirective,\n *     factory: () => new SomeDirective(directiveInject(DirectiveA))\n *   });\n * }\n *\n * @param token the type or token to inject\n * @param flags Injection flags\n * @returns the value from the injector or `null` when not found\n */\nexport function directiveInject<T>(token: Type<T>| InjectionToken<T>): T;\nexport function directiveInject<T>(token: Type<T>| InjectionToken<T>, flags: InjectFlags): T;\nexport function directiveInject<T>(\n    token: Type<T>| InjectionToken<T>, flags = InjectFlags.Default): T|null {\n  return getOrCreateInjectable<T>(getOrCreateNodeInjector(), token, flags);\n}\n\n/**\n * Creates an ElementRef and stores it on the injector.\n * Or, if the ElementRef already exists, retrieves the existing ElementRef.\n *\n * @returns The ElementRef instance to use\n */\nexport function injectElementRef(): viewEngine_ElementRef {\n  return getOrCreateElementRef(getOrCreateNodeInjector());\n}\n\n/**\n * Creates a TemplateRef and stores it on the injector. Or, if the TemplateRef already\n * exists, retrieves the existing TemplateRef.\n *\n * @returns The TemplateRef instance to use\n */\nexport function injectTemplateRef<T>(): viewEngine_TemplateRef<T> {\n  return getOrCreateTemplateRef<T>(getOrCreateNodeInjector());\n}\n\n/**\n * Creates a ViewContainerRef and stores it on the injector. Or, if the ViewContainerRef\n * already exists, retrieves the existing ViewContainerRef.\n *\n * @returns The ViewContainerRef instance to use\n */\nexport function injectViewContainerRef(): viewEngine_ViewContainerRef {\n  return getOrCreateContainerRef(getOrCreateNodeInjector());\n}\n\n/** Returns a ChangeDetectorRef (a.k.a. a ViewRef) */\nexport function injectChangeDetectorRef(): viewEngine_ChangeDetectorRef {\n  return getOrCreateChangeDetectorRef(getOrCreateNodeInjector(), null);\n}\n\n/**\n * Creates a ComponentFactoryResolver and stores it on the injector. Or, if the\n * ComponentFactoryResolver\n * already exists, retrieves the existing ComponentFactoryResolver.\n *\n * @returns The ComponentFactoryResolver instance to use\n */\nexport function injectComponentFactoryResolver(): viewEngine_ComponentFactoryResolver {\n  return componentFactoryResolver;\n}\nconst componentFactoryResolver: ComponentFactoryResolver = new ComponentFactoryResolver();\n\n\nexport function injectRenderer2(): Renderer2 {\n  return getOrCreateRenderer2(getOrCreateNodeInjector());\n}\n/**\n * Inject static attribute value into directive constructor.\n *\n * This method is used with `factory` functions which are generated as part of\n * `defineDirective` or `defineComponent`. The method retrieves the static value\n * of an attribute. (Dynamic attributes are not supported since they are not resolved\n *  at the time of injection and can change over time.)\n *\n * # Example\n * Given:\n * ```\n * @Component(...)\n * class MyComponent {\n *   constructor(@Attribute('title') title: string) { ... }\n * }\n * ```\n * When instantiated with\n * ```\n * <my-component title=\"Hello\"></my-component>\n * ```\n *\n * Then factory method generated is:\n * ```\n * MyComponent.ngComponentDef = defineComponent({\n *   factory: () => new MyComponent(injectAttribute('title'))\n *   ...\n * })\n * ```\n *\n * @experimental\n */\nexport function injectAttribute(attrNameToInject: string): string|undefined {\n  const lNode = getPreviousOrParentNode();\n  ngDevMode && assertNodeOfPossibleTypes(\n                   lNode, TNodeType.Container, TNodeType.Element, TNodeType.ElementContainer);\n  const tNode = lNode.tNode;\n  ngDevMode && assertDefined(tNode, 'expecting tNode');\n  const attrs = tNode.attrs;\n  if (attrs) {\n    for (let i = 0; i < attrs.length; i = i + 2) {\n      const attrName = attrs[i];\n      if (attrName === AttributeMarker.SelectOnly) break;\n      if (attrName == attrNameToInject) {\n        return attrs[i + 1] as string;\n      }\n    }\n  }\n  return undefined;\n}\n\n/**\n * Creates a ViewRef and stores it on the injector as ChangeDetectorRef (public alias).\n * Or, if it already exists, retrieves the existing instance.\n *\n * @returns The ChangeDetectorRef to use\n */\nexport function getOrCreateChangeDetectorRef(\n    di: LInjector, context: any): viewEngine_ChangeDetectorRef {\n  if (di.changeDetectorRef) return di.changeDetectorRef;\n\n  const currentNode = di.node;\n  if (isComponent(currentNode.tNode)) {\n    return di.changeDetectorRef = new ViewRef(currentNode.data as LViewData, context);\n  } else if (currentNode.tNode.type === TNodeType.Element) {\n    return di.changeDetectorRef = getOrCreateHostChangeDetector(currentNode.view[HOST_NODE]);\n  }\n  return null !;\n}\n\n/** Gets or creates ChangeDetectorRef for the closest host component */\nfunction getOrCreateHostChangeDetector(currentNode: LViewNode | LElementNode):\n    viewEngine_ChangeDetectorRef {\n  const hostNode = getClosestComponentAncestor(currentNode);\n  const hostInjector = hostNode.nodeInjector;\n  const existingRef = hostInjector && hostInjector.changeDetectorRef;\n\n  return existingRef ?\n      existingRef :\n      new ViewRef(\n          hostNode.data as LViewData,\n          hostNode\n              .view[DIRECTIVES] ![hostNode.tNode.flags >> TNodeFlags.DirectiveStartingIndexShift]);\n}\n\n\n\nfunction getOrCreateRenderer2(di: LInjector): Renderer2 {\n  const renderer = di.node.view[RENDERER];\n  if (isProceduralRenderer(renderer)) {\n    return renderer as Renderer2;\n  } else {\n    throw new Error('Cannot inject Renderer2 when the application uses Renderer3!');\n  }\n}\n\n/**\n * If the node is an embedded view, traverses up the view tree to return the closest\n * ancestor view that is attached to a component. If it's already a component node,\n * returns itself.\n */\nfunction getClosestComponentAncestor(node: LViewNode | LElementNode): LElementNode {\n  while (node.tNode.type === TNodeType.View) {\n    node = node.view[HOST_NODE];\n  }\n  return node as LElementNode;\n}\n\n/**\n * Returns the value associated to the given token from the injectors.\n *\n * Look for the injector providing the token by walking up the node injector tree and then\n * the module injector tree.\n *\n * @param nodeInjector Node injector where the search should start\n * @param token The token to look for\n * @param flags Injection flags\n * @returns the value from the injector or `null` when not found\n */\nexport function getOrCreateInjectable<T>(\n    nodeInjector: LInjector, token: Type<T>| InjectionToken<T>,\n    flags: InjectFlags = InjectFlags.Default): T|null {\n  const bloomHash = bloomHashBit(token);\n\n  // If the token has a bloom hash, then it is a directive that is public to the injection system\n  // (diPublic) otherwise fall back to the module injector.\n  if (bloomHash !== null) {\n    let injector: LInjector|null = nodeInjector;\n\n    while (injector) {\n      // Get the closest potential matching injector (upwards in the injector tree) that\n      // *potentially* has the token.\n      injector = bloomFindPossibleInjector(injector, bloomHash, flags);\n\n      // If no injector is found, we *know* that there is no ancestor injector that contains the\n      // token, so we abort.\n      if (!injector) {\n        break;\n      }\n\n      // At this point, we have an injector which *may* contain the token, so we step through the\n      // directives associated with the injector's corresponding node to get the directive instance.\n      const node = injector.node;\n      const nodeFlags = node.tNode.flags;\n      const count = nodeFlags & TNodeFlags.DirectiveCountMask;\n\n      if (count !== 0) {\n        const start = nodeFlags >> TNodeFlags.DirectiveStartingIndexShift;\n        const end = start + count;\n        const defs = node.view[TVIEW].directives !;\n\n        for (let i = start; i < end; i++) {\n          // Get the definition for the directive at this index and, if it is injectable (diPublic),\n          // and matches the given token, return the directive instance.\n          const directiveDef = defs[i] as DirectiveDefInternal<any>;\n          if (directiveDef.type === token && directiveDef.diPublic) {\n            return node.view[DIRECTIVES] ![i];\n          }\n        }\n      }\n\n      // If we *didn't* find the directive for the token and we are searching the current node's\n      // injector, it's possible the directive is on this node and hasn't been created yet.\n      let instance: T|null;\n      if (injector === nodeInjector &&\n          (instance = searchMatchesQueuedForCreation<T>(node, token))) {\n        return instance;\n      }\n\n      // The def wasn't found anywhere on this node, so it was a false positive.\n      // If flags permit, traverse up the tree and continue searching.\n      if (flags & InjectFlags.Self || flags & InjectFlags.Host && !sameHostView(injector)) {\n        injector = null;\n      } else {\n        injector = injector.parent;\n      }\n    }\n  }\n\n  const moduleInjector = getPreviousOrParentNode().view[INJECTOR];\n  const formerInjector = setCurrentInjector(moduleInjector);\n  try {\n    return inject(token, flags);\n  } finally {\n    setCurrentInjector(formerInjector);\n  }\n}\n\nfunction searchMatchesQueuedForCreation<T>(node: LNode, token: any): T|null {\n  const matches = node.view[TVIEW].currentMatches;\n  if (matches) {\n    for (let i = 0; i < matches.length; i += 2) {\n      const def = matches[i] as DirectiveDefInternal<any>;\n      if (def.type === token) {\n        return resolveDirective(def, i + 1, matches, node.view[TVIEW]);\n      }\n    }\n  }\n  return null;\n}\n\n/**\n * Returns the bit in an injector's bloom filter that should be used to determine whether or not\n * the directive might be provided by the injector.\n *\n * When a directive is public, it is added to the bloom filter and given a unique ID that can be\n * retrieved on the Type. When the directive isn't public or the token is not a directive `null`\n * is returned as the node injector can not possibly provide that token.\n *\n * @param token the injection token\n * @returns the matching bit to check in the bloom filter or `null` if the token is not known.\n */\nfunction bloomHashBit(token: Type<any>| InjectionToken<any>): number|null {\n  let id: number|undefined = (token as any)[NG_ELEMENT_ID];\n  return typeof id === 'number' ? id & BLOOM_MASK : null;\n}\n\n/**\n * Finds the closest injector that might have a certain directive.\n *\n * Each directive corresponds to a bit in an injector's bloom filter. Given the bloom bit to\n * check and a starting injector, this function traverses up injectors until it finds an\n * injector that contains a 1 for that bit in its bloom filter. A 1 indicates that the\n * injector may have that directive. It only *may* have the directive because directives begin\n * to share bloom filter bits after the BLOOM_SIZE is reached, and it could correspond to a\n * different directive sharing the bit.\n *\n * Note: We can skip checking further injectors up the tree if an injector's cbf structure\n * has a 0 for that bloom bit. Since cbf contains the merged value of all the parent\n * injectors, a 0 in the bloom bit indicates that the parents definitely do not contain\n * the directive and do not need to be checked.\n *\n * @param injector The starting node injector to check\n * @param  bloomBit The bit to check in each injector's bloom filter\n * @param  flags The injection flags for this injection site (e.g. Optional or SkipSelf)\n * @returns An injector that might have the directive\n */\nexport function bloomFindPossibleInjector(\n    startInjector: LInjector, bloomBit: number, flags: InjectFlags): LInjector|null {\n  // Create a mask that targets the specific bit associated with the directive we're looking for.\n  // JS bit operations are 32 bits, so this will be a number between 2^0 and 2^31, corresponding\n  // to bit positions 0 - 31 in a 32 bit integer.\n  const mask = 1 << bloomBit;\n  const b7 = bloomBit & 0x80;\n  const b6 = bloomBit & 0x40;\n  const b5 = bloomBit & 0x20;\n\n  // Traverse up the injector tree until we find a potential match or until we know there *isn't* a\n  // match.\n  let injector: LInjector|null =\n      flags & InjectFlags.SkipSelf ? startInjector.parent : startInjector;\n\n  while (injector) {\n    // Our bloom filter size is 256 bits, which is eight 32-bit bloom filter buckets:\n    // bf0 = [0 - 31], bf1 = [32 - 63], bf2 = [64 - 95], bf3 = [96 - 127], etc.\n    // Get the bloom filter value from the appropriate bucket based on the directive's bloomBit.\n    let value: number;\n\n    if (b7) {\n      value = b6 ? (b5 ? injector.bf7 : injector.bf6) : (b5 ? injector.bf5 : injector.bf4);\n    } else {\n      value = b6 ? (b5 ? injector.bf3 : injector.bf2) : (b5 ? injector.bf1 : injector.bf0);\n    }\n\n    // If the bloom filter value has the bit corresponding to the directive's bloomBit flipped on,\n    // this injector is a potential match.\n    if (value & mask) {\n      return injector;\n    }\n\n    if (flags & InjectFlags.Self || flags & InjectFlags.Host && !sameHostView(injector)) {\n      return null;\n    }\n\n    // If the current injector does not have the directive, check the bloom filters for the ancestor\n    // injectors (cbf0 - cbf7). These filters capture *all* ancestor injectors.\n    if (b7) {\n      value = b6 ? (b5 ? injector.cbf7 : injector.cbf6) : (b5 ? injector.cbf5 : injector.cbf4);\n    } else {\n      value = b6 ? (b5 ? injector.cbf3 : injector.cbf2) : (b5 ? injector.cbf1 : injector.cbf0);\n    }\n\n    // If the ancestor bloom filter value has the bit corresponding to the directive, traverse up to\n    // find the specific injector. If the ancestor bloom filter does not have the bit, we can abort.\n    if (value & mask) {\n      injector = injector.parent;\n    } else {\n      return null;\n    }\n  }\n\n  return null;\n}\n\n/**\n * Checks whether the current injector and its parent are in the same host view.\n *\n * This is necessary to support @Host() decorators. If @Host() is set, we should stop searching once\n * the injector and its parent view don't match because it means we'd cross the view boundary.\n */\nfunction sameHostView(injector: LInjector): boolean {\n  return !!injector.parent && injector.parent.node.view === injector.node.view;\n}\n\nexport class ReadFromInjectorFn<T> {\n  constructor(readonly read: (injector: LInjector, node: LNode, directiveIndex?: number) => T) {}\n}\n\n/**\n * Creates an ElementRef for a given node injector and stores it on the injector.\n * Or, if the ElementRef already exists, retrieves the existing ElementRef.\n *\n * @param di The node injector where we should store a created ElementRef\n * @returns The ElementRef instance to use\n */\nexport function getOrCreateElementRef(di: LInjector): viewEngine_ElementRef {\n  return di.elementRef || (di.elementRef = new ElementRef(di.node.native));\n}\n\nexport const QUERY_READ_TEMPLATE_REF = <QueryReadType<viewEngine_TemplateRef<any>>>(\n    new ReadFromInjectorFn<viewEngine_TemplateRef<any>>(\n        (injector: LInjector) => getOrCreateTemplateRef(injector)) as any);\n\nexport const QUERY_READ_CONTAINER_REF = <QueryReadType<viewEngine_ViewContainerRef>>(\n    new ReadFromInjectorFn<viewEngine_ViewContainerRef>(\n        (injector: LInjector) => getOrCreateContainerRef(injector)) as any);\n\nexport const QUERY_READ_ELEMENT_REF =\n    <QueryReadType<viewEngine_ElementRef>>(new ReadFromInjectorFn<viewEngine_ElementRef>(\n        (injector: LInjector) => getOrCreateElementRef(injector)) as any);\n\nexport const QUERY_READ_FROM_NODE =\n    (new ReadFromInjectorFn<any>((injector: LInjector, node: LNode, directiveIdx: number) => {\n      ngDevMode && assertNodeOfPossibleTypes(\n                       node, TNodeType.Container, TNodeType.Element, TNodeType.ElementContainer);\n      if (directiveIdx > -1) {\n        return node.view[DIRECTIVES] ![directiveIdx];\n      }\n      if (node.tNode.type === TNodeType.Element || node.tNode.type === TNodeType.ElementContainer) {\n        return getOrCreateElementRef(injector);\n      }\n      if (node.tNode.type === TNodeType.Container) {\n        return getOrCreateTemplateRef(injector);\n      }\n      if (ngDevMode) {\n        // should never happen\n        throw new Error(`Unexpected node type: ${node.tNode.type}`);\n      }\n    }) as any as QueryReadType<any>);\n\n/** A ref to a node's native element. */\nclass ElementRef implements viewEngine_ElementRef {\n  readonly nativeElement: any;\n  constructor(nativeElement: any) { this.nativeElement = nativeElement; }\n}\n\n/**\n * Creates a ViewContainerRef and stores it on the injector. Or, if the ViewContainerRef\n * already exists, retrieves the existing ViewContainerRef.\n *\n * @returns The ViewContainerRef instance to use\n */\nexport function getOrCreateContainerRef(di: LInjector): viewEngine_ViewContainerRef {\n  if (!di.viewContainerRef) {\n    const vcRefHost = di.node;\n\n    ngDevMode && assertNodeOfPossibleTypes(\n                     vcRefHost, TNodeType.Container, TNodeType.Element, TNodeType.ElementContainer);\n    const hostParent = getParentLNode(vcRefHost) !;\n    const lContainer = createLContainer(hostParent, vcRefHost.view, true);\n    const comment = vcRefHost.view[RENDERER].createComment(ngDevMode ? 'container' : '');\n    const lContainerNode: LContainerNode =\n        createLNodeObject(TNodeType.Container, vcRefHost.view, hostParent, comment, lContainer);\n    appendChild(hostParent, comment, vcRefHost.view);\n\n    const hostTNode = vcRefHost.tNode as TElementNode | TContainerNode;\n    if (!hostTNode.dynamicContainerNode) {\n      hostTNode.dynamicContainerNode =\n          createTNode(TNodeType.Container, -1, null, null, hostTNode, null);\n    }\n\n    lContainerNode.tNode = hostTNode.dynamicContainerNode;\n    vcRefHost.dynamicLContainerNode = lContainerNode;\n\n    addToViewTree(vcRefHost.view, hostTNode.index as number, lContainer);\n\n    di.viewContainerRef = new ViewContainerRef(lContainerNode, vcRefHost);\n  }\n\n  return di.viewContainerRef;\n}\n\nexport class NodeInjector implements Injector {\n  constructor(private _lInjector: LInjector) {}\n\n  get(token: any): any {\n    if (token === viewEngine_TemplateRef) {\n      return getOrCreateTemplateRef(this._lInjector);\n    }\n    if (token === viewEngine_ViewContainerRef) {\n      return getOrCreateContainerRef(this._lInjector);\n    }\n    if (token === viewEngine_ElementRef) {\n      return getOrCreateElementRef(this._lInjector);\n    }\n    if (token === viewEngine_ChangeDetectorRef) {\n      return getOrCreateChangeDetectorRef(this._lInjector, null);\n    }\n    if (token === Renderer2) {\n      return getOrCreateRenderer2(this._lInjector);\n    }\n\n    return getOrCreateInjectable(this._lInjector, token);\n  }\n}\n\n/**\n * A ref to a container that enables adding and removing views from that container\n * imperatively.\n */\nclass ViewContainerRef implements viewEngine_ViewContainerRef {\n  private _viewRefs: viewEngine_ViewRef[] = [];\n\n  constructor(\n      private _lContainerNode: LContainerNode,\n      private _hostNode: LElementNode|LElementContainerNode|LContainerNode) {}\n\n  get element(): ElementRef {\n    const injector = getOrCreateNodeInjectorForNode(this._hostNode);\n    return getOrCreateElementRef(injector);\n  }\n\n  get injector(): Injector {\n    const injector = getOrCreateNodeInjectorForNode(this._hostNode);\n    return new NodeInjector(injector);\n  }\n\n  /** @deprecated No replacement */\n  get parentInjector(): Injector {\n    const parentLInjector = getParentLNode(this._hostNode).nodeInjector;\n    return parentLInjector ? new NodeInjector(parentLInjector) : new NullInjector();\n  }\n\n  clear(): void {\n    const lContainer = this._lContainerNode.data;\n    while (lContainer[VIEWS].length) {\n      this.remove(0);\n    }\n  }\n\n  get(index: number): viewEngine_ViewRef|null { return this._viewRefs[index] || null; }\n\n  get length(): number {\n    const lContainer = this._lContainerNode.data;\n    return lContainer[VIEWS].length;\n  }\n\n  createEmbeddedView<C>(templateRef: viewEngine_TemplateRef<C>, context?: C, index?: number):\n      viewEngine_EmbeddedViewRef<C> {\n    const adjustedIdx = this._adjustIndex(index);\n    const viewRef = (templateRef as TemplateRef<C>)\n                        .createEmbeddedView(context || <any>{}, this._lContainerNode, adjustedIdx);\n    (viewRef as ViewRef<any>).attachToViewContainerRef(this);\n    this._viewRefs.splice(adjustedIdx, 0, viewRef);\n    return viewRef;\n  }\n\n  createComponent<C>(\n      componentFactory: viewEngine_ComponentFactory<C>, index?: number|undefined,\n      injector?: Injector|undefined, projectableNodes?: any[][]|undefined,\n      ngModuleRef?: viewEngine_NgModuleRef<any>|undefined): viewEngine_ComponentRef<C> {\n    const contextInjector = injector || this.parentInjector;\n    if (!ngModuleRef && contextInjector) {\n      ngModuleRef = contextInjector.get(viewEngine_NgModuleRef, null);\n    }\n\n    const componentRef =\n        componentFactory.create(contextInjector, projectableNodes, undefined, ngModuleRef);\n    this.insert(componentRef.hostView, index);\n    return componentRef;\n  }\n\n  insert(viewRef: viewEngine_ViewRef, index?: number): viewEngine_ViewRef {\n    if (viewRef.destroyed) {\n      throw new Error('Cannot insert a destroyed View in a ViewContainer!');\n    }\n    const lViewNode = (viewRef as ViewRef<any>)._lViewNode !;\n    const adjustedIdx = this._adjustIndex(index);\n\n    insertView(this._lContainerNode, lViewNode, adjustedIdx);\n    const views = this._lContainerNode.data[VIEWS];\n    const beforeNode = adjustedIdx + 1 < views.length ?\n        (getChildLNode(views[adjustedIdx + 1]) !).native :\n        this._lContainerNode.native;\n    addRemoveViewFromContainer(this._lContainerNode, lViewNode, true, beforeNode);\n\n    (viewRef as ViewRef<any>).attachToViewContainerRef(this);\n    this._viewRefs.splice(adjustedIdx, 0, viewRef);\n\n    return viewRef;\n  }\n\n  move(viewRef: viewEngine_ViewRef, newIndex: number): viewEngine_ViewRef {\n    const index = this.indexOf(viewRef);\n    this.detach(index);\n    this.insert(viewRef, this._adjustIndex(newIndex));\n    return viewRef;\n  }\n\n  indexOf(viewRef: viewEngine_ViewRef): number { return this._viewRefs.indexOf(viewRef); }\n\n  remove(index?: number): void {\n    const adjustedIdx = this._adjustIndex(index, -1);\n    removeView(this._lContainerNode, adjustedIdx);\n    this._viewRefs.splice(adjustedIdx, 1);\n  }\n\n  detach(index?: number): viewEngine_ViewRef|null {\n    const adjustedIdx = this._adjustIndex(index, -1);\n    detachView(this._lContainerNode, adjustedIdx);\n    return this._viewRefs.splice(adjustedIdx, 1)[0] || null;\n  }\n\n  private _adjustIndex(index?: number, shift: number = 0) {\n    if (index == null) {\n      return this._lContainerNode.data[VIEWS].length + shift;\n    }\n    if (ngDevMode) {\n      assertGreaterThan(index, -1, 'index must be positive');\n      // +1 because it's legal to insert at the end.\n      assertLessThan(index, this._lContainerNode.data[VIEWS].length + 1 + shift, 'index');\n    }\n    return index;\n  }\n}\n\n/**\n * Creates a TemplateRef and stores it on the injector. Or, if the TemplateRef already\n * exists, retrieves the existing TemplateRef.\n *\n * @param di The node injector where we should store a created TemplateRef\n * @returns The TemplateRef instance to use\n */\nexport function getOrCreateTemplateRef<T>(di: LInjector): viewEngine_TemplateRef<T> {\n  if (!di.templateRef) {\n    ngDevMode && assertNodeType(di.node, TNodeType.Container);\n    const hostNode = di.node as LContainerNode;\n    const hostTNode = hostNode.tNode;\n    ngDevMode && assertDefined(hostTNode.tViews, 'TView must be allocated');\n    di.templateRef = new TemplateRef<any>(\n        hostNode.view, getOrCreateElementRef(di), hostTNode.tViews as TView, getRenderer(),\n        hostNode.data[QUERIES]);\n  }\n  return di.templateRef;\n}\n\nexport function getFactoryOf<T>(type: Type<any>): ((type?: Type<T>) => T)|null {\n  const typeAny = type as any;\n  const def = typeAny.ngComponentDef || typeAny.ngDirectiveDef || typeAny.ngPipeDef ||\n      typeAny.ngInjectableDef || typeAny.ngInjectorDef;\n  if (def === undefined || def.factory === undefined) {\n    return null;\n  }\n  return def.factory;\n}\n\nexport function getInheritedFactory<T>(type: Type<any>): (type: Type<T>) => T {\n  const proto = Object.getPrototypeOf(type.prototype).constructor as Type<any>;\n  const factory = getFactoryOf<T>(proto);\n  if (factory !== null) {\n    return factory;\n  } else {\n    // There is no factory defined. Either this was improper usage of inheritance\n    // (no Angular decorator on the superclass) or there is no constructor at all\n    // in the inheritance chain. Since the two cases cannot be distinguished, the\n    // latter has to be assumed.\n    return (t) => new t();\n  }\n}\n\nclass TemplateRef<T> implements viewEngine_TemplateRef<T> {\n  constructor(\n      private _declarationParentView: LViewData, readonly elementRef: viewEngine_ElementRef,\n      private _tView: TView, private _renderer: Renderer3, private _queries: LQueries|null) {}\n\n  createEmbeddedView(context: T, containerNode?: LContainerNode, index?: number):\n      viewEngine_EmbeddedViewRef<T> {\n    const viewNode = createEmbeddedViewNode(\n        this._tView, context, this._declarationParentView, this._renderer, this._queries);\n    if (containerNode) {\n      insertView(containerNode, viewNode, index !);\n    }\n    renderEmbeddedTemplate(viewNode, this._tView, context, RenderFlags.Create);\n    const viewRef = new ViewRef(viewNode.data, context);\n    viewRef._lViewNode = viewNode;\n    return viewRef;\n  }\n}\n\n/**\n * Retrieves `TemplateRef` instance from `Injector` when a local reference is placed on the\n * `<ng-template>` element.\n */\nexport function templateRefExtractor(lNode: LNodeWithLocalRefs) {\n  return getOrCreateTemplateRef(getOrCreateNodeInjectorForNode(lNode));\n}"]}