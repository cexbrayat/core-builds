{"version":3,"file":"view_ref.js","sourceRoot":"","sources":["../../../../../../packages/core/src/render3/view_ref.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ApplicationRef} from '../application_ref';\nimport {ChangeDetectorRef as viewEngine_ChangeDetectorRef} from '../change_detection/change_detector_ref';\nimport {ViewContainerRef as viewEngine_ViewContainerRef} from '../linker/view_container_ref';\nimport {EmbeddedViewRef as viewEngine_EmbeddedViewRef, InternalViewRef as viewEngine_InternalViewRef} from '../linker/view_ref';\n\nimport {checkNoChanges, checkNoChangesInRootView, detectChanges, detectChangesInRootView, getRendererFactory, markViewDirty, storeCleanupFn, viewAttached} from './instructions';\nimport {LViewNode} from './interfaces/node';\nimport {FLAGS, LViewData, LViewFlags} from './interfaces/view';\nimport {destroyLView} from './node_manipulation';\n\n\n// Needed due to tsickle downleveling where multiple `implements` with classes creates\n// multiple @extends in Closure annotations, which is illegal. This workaround fixes\n// the multiple @extends by making the annotation @implements instead\nexport interface viewEngine_ChangeDetectorRef_interface extends viewEngine_ChangeDetectorRef {}\n\nexport class ViewRef<T> implements viewEngine_EmbeddedViewRef<T>, viewEngine_InternalViewRef,\n    viewEngine_ChangeDetectorRef_interface {\n  private _appRef: ApplicationRef|null = null;\n  private _viewContainerRef: viewEngine_ViewContainerRef|null = null;\n\n  /**\n   * @internal\n   */\n  _lViewNode: LViewNode|null = null;\n\n  context: T;\n  // TODO(issue/24571): remove '!'.\n  rootNodes !: any[];\n\n  constructor(protected _view: LViewData, context: T|null) { this.context = context !; }\n\n  /** @internal */\n  _setComponentContext(view: LViewData, context: T) {\n    this._view = view;\n    this.context = context;\n  }\n\n  get destroyed(): boolean {\n    return (this._view[FLAGS] & LViewFlags.Destroyed) === LViewFlags.Destroyed;\n  }\n\n  destroy(): void {\n    if (this._viewContainerRef && viewAttached(this._view)) {\n      this._viewContainerRef.detach(this._viewContainerRef.indexOf(this));\n      this._viewContainerRef = null;\n    }\n    destroyLView(this._view);\n  }\n\n  onDestroy(callback: Function) { storeCleanupFn(this._view, callback); }\n\n  /**\n   * Marks a view and all of its ancestors dirty.\n   *\n   * It also triggers change detection by calling `scheduleTick` internally, which coalesces\n   * multiple `markForCheck` calls to into one change detection run.\n   *\n   * This can be used to ensure an {@link ChangeDetectionStrategy#OnPush OnPush} component is\n   * checked when it needs to be re-rendered but the two normal triggers haven't marked it\n   * dirty (i.e. inputs haven't changed and events haven't fired in the view).\n   *\n   * <!-- TODO: Add a link to a chapter on OnPush components -->\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * ```typescript\n   * @Component({\n   *   selector: 'my-app',\n   *   template: `Number of ticks: {{numberOfTicks}}`\n   *   changeDetection: ChangeDetectionStrategy.OnPush,\n   * })\n   * class AppComponent {\n   *   numberOfTicks = 0;\n   *\n   *   constructor(private ref: ChangeDetectorRef) {\n   *     setInterval(() => {\n   *       this.numberOfTicks++;\n   *       // the following is required, otherwise the view will not be updated\n   *       this.ref.markForCheck();\n   *     }, 1000);\n   *   }\n   * }\n   * ```\n   */\n  markForCheck(): void { markViewDirty(this._view); }\n\n  /**\n   * Detaches the view from the change detection tree.\n   *\n   * Detached views will not be checked during change detection runs until they are\n   * re-attached, even if they are dirty. `detach` can be used in combination with\n   * {@link ChangeDetectorRef#detectChanges detectChanges} to implement local change\n   * detection checks.\n   *\n   * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->\n   * <!-- TODO: Add a live demo once ref.detectChanges is merged into master -->\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * The following example defines a component with a large list of readonly data.\n   * Imagine the data changes constantly, many times per second. For performance reasons,\n   * we want to check and update the list every five seconds. We can do that by detaching\n   * the component's change detector and doing a local check every five seconds.\n   *\n   * ```typescript\n   * class DataProvider {\n   *   // in a real application the returned data will be different every time\n   *   get data() {\n   *     return [1,2,3,4,5];\n   *   }\n   * }\n   *\n   * @Component({\n   *   selector: 'giant-list',\n   *   template: `\n   *     <li *ngFor=\"let d of dataProvider.data\">Data {{d}}</li>\n   *   `,\n   * })\n   * class GiantList {\n   *   constructor(private ref: ChangeDetectorRef, private dataProvider: DataProvider) {\n   *     ref.detach();\n   *     setInterval(() => {\n   *       this.ref.detectChanges();\n   *     }, 5000);\n   *   }\n   * }\n   *\n   * @Component({\n   *   selector: 'app',\n   *   providers: [DataProvider],\n   *   template: `\n   *     <giant-list><giant-list>\n   *   `,\n   * })\n   * class App {\n   * }\n   * ```\n   */\n  detach(): void { this._view[FLAGS] &= ~LViewFlags.Attached; }\n\n  /**\n   * Re-attaches a view to the change detection tree.\n   *\n   * This can be used to re-attach views that were previously detached from the tree\n   * using {@link ChangeDetectorRef#detach detach}. Views are attached to the tree by default.\n   *\n   * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * The following example creates a component displaying `live` data. The component will detach\n   * its change detector from the main change detector tree when the component's live property\n   * is set to false.\n   *\n   * ```typescript\n   * class DataProvider {\n   *   data = 1;\n   *\n   *   constructor() {\n   *     setInterval(() => {\n   *       this.data = this.data * 2;\n   *     }, 500);\n   *   }\n   * }\n   *\n   * @Component({\n   *   selector: 'live-data',\n   *   inputs: ['live'],\n   *   template: 'Data: {{dataProvider.data}}'\n   * })\n   * class LiveData {\n   *   constructor(private ref: ChangeDetectorRef, private dataProvider: DataProvider) {}\n   *\n   *   set live(value) {\n   *     if (value) {\n   *       this.ref.reattach();\n   *     } else {\n   *       this.ref.detach();\n   *     }\n   *   }\n   * }\n   *\n   * @Component({\n   *   selector: 'my-app',\n   *   providers: [DataProvider],\n   *   template: `\n   *     Live Update: <input type=\"checkbox\" [(ngModel)]=\"live\">\n   *     <live-data [live]=\"live\"><live-data>\n   *   `,\n   * })\n   * class AppComponent {\n   *   live = true;\n   * }\n   * ```\n   */\n  reattach(): void { this._view[FLAGS] |= LViewFlags.Attached; }\n\n  /**\n   * Checks the view and its children.\n   *\n   * This can also be used in combination with {@link ChangeDetectorRef#detach detach} to implement\n   * local change detection checks.\n   *\n   * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->\n   * <!-- TODO: Add a live demo once ref.detectChanges is merged into master -->\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * The following example defines a component with a large list of readonly data.\n   * Imagine, the data changes constantly, many times per second. For performance reasons,\n   * we want to check and update the list every five seconds.\n   *\n   * We can do that by detaching the component's change detector and doing a local change detection\n   * check every five seconds.\n   *\n   * See {@link ChangeDetectorRef#detach detach} for more information.\n   */\n  detectChanges(): void {\n    const rendererFactory = getRendererFactory();\n    if (rendererFactory.begin) {\n      rendererFactory.begin();\n    }\n    detectChanges(this.context);\n    if (rendererFactory.end) {\n      rendererFactory.end();\n    }\n  }\n\n  /**\n   * Checks the change detector and its children, and throws if any changes are detected.\n   *\n   * This is used in development mode to verify that running change detection doesn't\n   * introduce other changes.\n   */\n  checkNoChanges(): void { checkNoChanges(this.context); }\n\n  attachToViewContainerRef(vcRef: viewEngine_ViewContainerRef) { this._viewContainerRef = vcRef; }\n\n  detachFromAppRef() { this._appRef = null; }\n\n  attachToAppRef(appRef: ApplicationRef) { this._appRef = appRef; }\n}\n\n/** @internal */\nexport class RootViewRef<T> extends ViewRef<T> {\n  constructor(protected _view: LViewData) { super(_view, null); }\n\n  detectChanges(): void { detectChangesInRootView(this._view); }\n\n  checkNoChanges(): void { checkNoChangesInRootView(this._view); }\n}\n"]}