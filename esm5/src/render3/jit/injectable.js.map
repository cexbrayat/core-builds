{"version":3,"file":"injectable.js","sourceRoot":"","sources":["../../../../../../../packages/core/src/render3/jit/injectable.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Expression, LiteralExpr, R3DependencyMetadata, R3InjectableMetadata, WrappedNodeExpr, compileInjectable as compileR3Injectable, jitExpression} from '@angular/compiler';\n\nimport {Injectable} from '../../di/injectable';\nimport {ClassSansProvider, ExistingSansProvider, FactorySansProvider, StaticClassSansProvider, ValueProvider, ValueSansProvider} from '../../di/provider';\nimport {Type} from '../../type';\nimport {getClosureSafeProperty} from '../../util/property';\n\nimport {angularCoreEnv} from './environment';\nimport {NG_INJECTABLE_DEF} from './fields';\nimport {convertDependencies, reflectDependencies} from './util';\n\n\n\n/**\n * Compile an Angular injectable according to its `Injectable` metadata, and patch the resulting\n * `ngInjectableDef` onto the injectable type.\n */\nexport function compileInjectable(type: Type<any>, srcMeta?: Injectable): void {\n  // Allow the compilation of a class with a `@Injectable()` decorator without parameters\n  const meta: Injectable = srcMeta || {providedIn: null};\n\n  let def: any = null;\n  Object.defineProperty(type, NG_INJECTABLE_DEF, {\n    get: () => {\n      if (def === null) {\n        // Check whether the injectable metadata includes a provider specification.\n        const hasAProvider = isUseClassProvider(meta) || isUseFactoryProvider(meta) ||\n            isUseValueProvider(meta) || isUseExistingProvider(meta);\n\n        const ctorDeps = reflectDependencies(type);\n\n        let userDeps: R3DependencyMetadata[]|undefined = undefined;\n        if ((isUseClassProvider(meta) || isUseFactoryProvider(meta)) && meta.deps !== undefined) {\n          userDeps = convertDependencies(meta.deps);\n        }\n\n        // Decide which flavor of factory to generate, based on the provider specified.\n        // Only one of the use* fields should be set.\n        let useClass: Expression|undefined = undefined;\n        let useFactory: Expression|undefined = undefined;\n        let useValue: Expression|undefined = undefined;\n        let useExisting: Expression|undefined = undefined;\n\n        if (!hasAProvider) {\n          // In the case the user specifies a type provider, treat it as {provide: X, useClass: X}.\n          // The deps will have been reflected above, causing the factory to create the class by\n          // calling\n          // its constructor with injected deps.\n          useClass = new WrappedNodeExpr(type);\n        } else if (isUseClassProvider(meta)) {\n          // The user explicitly specified useClass, and may or may not have provided deps.\n          useClass = new WrappedNodeExpr(meta.useClass);\n        } else if (isUseValueProvider(meta)) {\n          // The user explicitly specified useValue.\n          useValue = new WrappedNodeExpr(meta.useValue);\n        } else if (isUseFactoryProvider(meta)) {\n          // The user explicitly specified useFactory.\n          useFactory = new WrappedNodeExpr(meta.useFactory);\n        } else if (isUseExistingProvider(meta)) {\n          // The user explicitly specified useExisting.\n          useExisting = new WrappedNodeExpr(meta.useExisting);\n        } else {\n          // Can't happen - either hasAProvider will be false, or one of the providers will be set.\n          throw new Error(`Unreachable state.`);\n        }\n\n        const {expression, statements} = compileR3Injectable({\n          name: type.name,\n          type: new WrappedNodeExpr(type),\n          providedIn: computeProvidedIn(meta.providedIn),\n          useClass,\n          useFactory,\n          useValue,\n          useExisting,\n          ctorDeps,\n          userDeps,\n        });\n\n        def = jitExpression(\n            expression, angularCoreEnv, `ng://${type.name}/ngInjectableDef.js`, statements);\n      }\n      return def;\n    },\n  });\n}\n\nfunction computeProvidedIn(providedIn: Type<any>| string | null | undefined): Expression {\n  if (providedIn == null || typeof providedIn === 'string') {\n    return new LiteralExpr(providedIn);\n  } else {\n    return new WrappedNodeExpr(providedIn);\n  }\n}\n\ntype UseClassProvider = Injectable & ClassSansProvider & {deps?: any[]};\n\nfunction isUseClassProvider(meta: Injectable): meta is UseClassProvider {\n  return (meta as UseClassProvider).useClass !== undefined;\n}\n\nconst GET_PROPERTY_NAME = {} as any;\nconst USE_VALUE = getClosureSafeProperty<ValueProvider>(\n    {provide: String, useValue: GET_PROPERTY_NAME}, GET_PROPERTY_NAME);\n\nfunction isUseValueProvider(meta: Injectable): meta is Injectable&ValueSansProvider {\n  return USE_VALUE in meta;\n}\n\nfunction isUseFactoryProvider(meta: Injectable): meta is Injectable&FactorySansProvider {\n  return (meta as FactorySansProvider).useFactory !== undefined;\n}\n\nfunction isUseExistingProvider(meta: Injectable): meta is Injectable&ExistingSansProvider {\n  return (meta as ExistingSansProvider).useExisting !== undefined;\n}\n"]}