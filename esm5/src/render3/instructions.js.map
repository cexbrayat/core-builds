{"version":3,"file":"instructions.js","sourceRoot":"","sources":["../../../../../../packages/core/src/render3/instructions.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport './ng_dev_mode';\n\nimport {QueryList} from '../linker';\nimport {Sanitizer} from '../sanitization/security';\nimport {StyleSanitizeFn} from '../sanitization/style_sanitizer';\n\nimport {assertDefined, assertEqual, assertLessThan, assertNotEqual} from './assert';\nimport {attachPatchData, getComponentViewByInstance} from './context_discovery';\nimport {throwCyclicDependencyError, throwErrorIfNoChangesMode, throwMultipleComponentError} from './errors';\nimport {executeHooks, executeInitHooks, queueInitHooks, queueLifecycleHooks} from './hooks';\nimport {ACTIVE_INDEX, LContainer, VIEWS} from './interfaces/container';\nimport {ComponentDef, ComponentQuery, ComponentTemplate, DirectiveDef, DirectiveDefListOrFactory, InitialStylingFlags, PipeDefListOrFactory, RenderFlags} from './interfaces/definition';\nimport {INJECTOR_SIZE} from './interfaces/injector';\nimport {AttributeMarker, InitialInputData, InitialInputs, LocalRefExtractor, PropertyAliasValue, PropertyAliases, TAttributes, TContainerNode, TElementContainerNode, TElementNode, TNode, TNodeFlags, TNodeType, TProjectionNode, TViewNode} from './interfaces/node';\nimport {CssSelectorList, NG_PROJECT_AS_ATTR_NAME} from './interfaces/projection';\nimport {LQueries} from './interfaces/query';\nimport {ProceduralRenderer3, RComment, RElement, RNode, RText, Renderer3, RendererFactory3, isProceduralRenderer} from './interfaces/renderer';\nimport {BINDING_INDEX, CLEANUP, CONTAINER_INDEX, CONTENT_QUERIES, CONTEXT, CurrentMatchesList, DECLARATION_VIEW, FLAGS, HEADER_OFFSET, HOST, HOST_NODE, INJECTOR, LViewData, LViewFlags, NEXT, OpaqueViewState, PARENT, QUERIES, RENDERER, RootContext, RootContextFlags, SANITIZER, TAIL, TVIEW, TView} from './interfaces/view';\nimport {assertNodeOfPossibleTypes, assertNodeType} from './node_assert';\nimport {appendChild, appendProjectedNode, createTextNode, findComponentView, getLViewChild, getRenderParent, insertView, removeView} from './node_manipulation';\nimport {isNodeMatchingSelectorList, matchingSelectorIndex} from './node_selector_matcher';\nimport {createStylingContextTemplate, renderStyling as renderElementStyles, updateClassProp as updateElementClassProp, updateStyleProp as updateElementStyleProp, updateStylingMap} from './styling/class_and_style_bindings';\nimport {getStylingContext} from './styling/util';\nimport {assertDataInRangeInternal, getComponentViewByIndex, getNativeByIndex, getNativeByTNode, getRootView, getTNode, isComponent, isContentQueryHost, isDifferent, loadInternal, readPatchedLViewData, stringify} from './util';\n\n\n\n/**\n * A permanent marker promise which signifies that the current CD tree is\n * clean.\n */\nconst _CLEAN_PROMISE = Promise.resolve(null);\n\n/**\n * Function used to sanitize the value before writing it into the renderer.\n */\nexport type SanitizerFn = (value: any) => string;\n\n/**\n * Token set in currentMatches while dependencies are being resolved.\n *\n * If we visit a directive that has a value set to CIRCULAR, we know we've\n * already seen it, and thus have a circular dependency.\n */\nexport const CIRCULAR = '__CIRCULAR__';\n\n/**\n * This property gets set before entering a template.\n *\n * This renderer can be one of two varieties of Renderer3:\n *\n * - ObjectedOrientedRenderer3\n *\n * This is the native browser API style, e.g. operations are methods on individual objects\n * like HTMLElement. With this style, no additional code is needed as a facade (reducing payload\n * size).\n *\n * - ProceduralRenderer3\n *\n * In non-native browser environments (e.g. platforms such as web-workers), this is the facade\n * that enables element manipulation. This also facilitates backwards compatibility with\n * Renderer2.\n */\nlet renderer: Renderer3;\n\nexport function getRenderer(): Renderer3 {\n  // top level variables should not be exported for performance reasons (PERF_NOTES.md)\n  return renderer;\n}\n\nlet rendererFactory: RendererFactory3;\n\nexport function getRendererFactory(): RendererFactory3 {\n  // top level variables should not be exported for performance reasons (PERF_NOTES.md)\n  return rendererFactory;\n}\n\nexport function getCurrentSanitizer(): Sanitizer|null {\n  return viewData && viewData[SANITIZER];\n}\n\n/**\n * Store the element depth count. This is used to identify the root elements of the template\n * so that we can than attach `LViewData` to only those elements.\n */\nlet elementDepthCount !: number;\n\n/**\n * Stores whether directives should be matched to elements.\n *\n * When template contains `ngNonBindable` than we need to prevent the runtime form matching\n * directives on children of that element.\n *\n * Example:\n * ```\n * <my-comp my-directive>\n *   Should match component / directive.\n * </my-comp>\n * <div ngNonBindable>\n *   <my-comp my-directive>\n *     Should not match component / directive because we are in ngNonBindable.\n *   </my-comp>\n * </div>\n * ```\n */\nlet bindingsEnabled !: boolean;\n\n/**\n * Returns the current OpaqueViewState instance.\n *\n * Used in conjunction with the restoreView() instruction to save a snapshot\n * of the current view and restore it when listeners are invoked. This allows\n * walking the declaration view tree in listeners to get vars from parent views.\n */\nexport function getCurrentView(): OpaqueViewState {\n  return viewData as any as OpaqueViewState;\n}\n\n/**\n * Restores `contextViewData` to the given OpaqueViewState instance.\n *\n * Used in conjunction with the getCurrentView() instruction to save a snapshot\n * of the current view and restore it when listeners are invoked. This allows\n * walking the declaration view tree in listeners to get vars from parent views.\n *\n * @param viewToRestore The OpaqueViewState instance to restore.\n */\nexport function restoreView(viewToRestore: OpaqueViewState) {\n  contextViewData = viewToRestore as any as LViewData;\n}\n\n/** Used to set the parent property when nodes are created and track query results. */\nlet previousOrParentTNode: TNode;\n\nexport function getPreviousOrParentTNode(): TNode {\n  // top level variables should not be exported for performance reasons (PERF_NOTES.md)\n  return previousOrParentTNode;\n}\n\nexport function setEnvironment(tNode: TNode, view: LViewData) {\n  previousOrParentTNode = tNode;\n  viewData = view;\n}\n\n/**\n * If `isParent` is:\n *  - `true`: then `previousOrParentTNode` points to a parent node.\n *  - `false`: then `previousOrParentTNode` points to previous node (sibling).\n */\nlet isParent: boolean;\n\nlet tView: TView;\n\nlet currentQueries: LQueries|null;\n\n/**\n * Query instructions can ask for \"current queries\" in 2 different cases:\n * - when creating view queries (at the root of a component view, before any node is created - in\n * this case currentQueries points to view queries)\n * - when creating content queries (i.e. this previousOrParentTNode points to a node on which we\n * create content queries).\n */\nexport function getOrCreateCurrentQueries(\n    QueryType: {new (parent: null, shallow: null, deep: null): LQueries}): LQueries {\n  // if this is the first content query on a node, any existing LQueries needs to be cloned\n  // in subsequent template passes, the cloning occurs before directive instantiation.\n  if (previousOrParentTNode && previousOrParentTNode !== viewData[HOST_NODE] &&\n      !isContentQueryHost(previousOrParentTNode)) {\n    currentQueries && (currentQueries = currentQueries.clone());\n    previousOrParentTNode.flags |= TNodeFlags.hasContentQuery;\n  }\n\n  return currentQueries || (currentQueries = new QueryType(null, null, null));\n}\n\n/**\n * This property gets set before entering a template.\n */\nlet creationMode: boolean;\n\nexport function getCreationMode(): boolean {\n  // top level variables should not be exported for performance reasons (PERF_NOTES.md)\n  return creationMode;\n}\n\n/**\n * State of the current view being processed.\n *\n * An array of nodes (text, element, container, etc), pipes, their bindings, and\n * any local variables that need to be stored between invocations.\n */\nlet viewData: LViewData;\n\n/**\n * Internal function that returns the current LViewData instance.\n *\n * The getCurrentView() instruction should be used for anything public.\n */\nexport function _getViewData(): LViewData {\n  // top level variables should not be exported for performance reasons (PERF_NOTES.md)\n  return viewData;\n}\n\n/**\n * The last viewData retrieved by nextContext().\n * Allows building nextContext() and reference() calls.\n *\n * e.g. const inner = x().$implicit; const outer = x().$implicit;\n */\nlet contextViewData: LViewData = null !;\n\nfunction getCleanup(view: LViewData): any[] {\n  // top level variables should not be exported for performance reasons (PERF_NOTES.md)\n  return view[CLEANUP] || (view[CLEANUP] = []);\n}\n\nfunction getTViewCleanup(view: LViewData): any[] {\n  return view[TVIEW].cleanup || (view[TVIEW].cleanup = []);\n}\n/**\n * In this mode, any changes in bindings will throw an ExpressionChangedAfterChecked error.\n *\n * Necessary to support ChangeDetectorRef.checkNoChanges().\n */\nlet checkNoChangesMode = false;\n\n/** Whether or not this is the first time the current view has been processed. */\nlet firstTemplatePass = true;\n\n/**\n * The root index from which pure function instructions should calculate their binding\n * indices. In component views, this is TView.bindingStartIndex. In a host binding\n * context, this is the TView.expandoStartIndex + any dirs/hostVars before the given dir.\n */\nlet bindingRootIndex: number = -1;\n\n// top level variables should not be exported for performance reasons (PERF_NOTES.md)\nexport function getBindingRoot() {\n  return bindingRootIndex;\n}\n\nconst enum BindingDirection {\n  Input,\n  Output,\n}\n\n/**\n * Swap the current state with a new state.\n *\n * For performance reasons we store the state in the top level of the module.\n * This way we minimize the number of properties to read. Whenever a new view\n * is entered we have to store the state for later, and when the view is\n * exited the state has to be restored\n *\n * @param newView New state to become active\n * @param host Element to which the View is a child of\n * @returns the previous state;\n */\nexport function enterView(\n    newView: LViewData, hostTNode: TElementNode | TViewNode | null): LViewData {\n  const oldView: LViewData = viewData;\n  tView = newView && newView[TVIEW];\n\n  creationMode = newView && (newView[FLAGS] & LViewFlags.CreationMode) === LViewFlags.CreationMode;\n  firstTemplatePass = newView && tView.firstTemplatePass;\n  bindingRootIndex = newView && tView.bindingStartIndex;\n  renderer = newView && newView[RENDERER];\n\n  previousOrParentTNode = hostTNode !;\n  isParent = true;\n\n  viewData = contextViewData = newView;\n  oldView && (oldView[QUERIES] = currentQueries);\n  currentQueries = newView && newView[QUERIES];\n\n  return oldView;\n}\n\n/**\n * Used in lieu of enterView to make it clear when we are exiting a child view. This makes\n * the direction of traversal (up or down the view tree) a bit clearer.\n *\n * @param newView New state to become active\n * @param creationOnly An optional boolean to indicate that the view was processed in creation mode\n * only, i.e. the first update will be done later. Only possible for dynamically created views.\n */\nexport function leaveView(newView: LViewData, creationOnly?: boolean): void {\n  if (!creationOnly) {\n    if (!checkNoChangesMode) {\n      executeHooks(viewData, tView.viewHooks, tView.viewCheckHooks, creationMode);\n    }\n    // Views are clean and in update mode after being checked, so these bits are cleared\n    viewData[FLAGS] &= ~(LViewFlags.CreationMode | LViewFlags.Dirty);\n  }\n  viewData[FLAGS] |= LViewFlags.RunInit;\n  viewData[BINDING_INDEX] = tView.bindingStartIndex;\n  enterView(newView, null);\n}\n\n/**\n * Refreshes the view, executing the following steps in that order:\n * triggers init hooks, refreshes dynamic embedded views, triggers content hooks, sets host\n * bindings, refreshes child components.\n * Note: view hooks are triggered later when leaving the view.\n */\nfunction refreshDescendantViews() {\n  setHostBindings();\n  const parentFirstTemplatePass = firstTemplatePass;\n\n  // This needs to be set before children are processed to support recursive components\n  tView.firstTemplatePass = firstTemplatePass = false;\n\n  if (!checkNoChangesMode) {\n    executeInitHooks(viewData, tView, creationMode);\n  }\n  refreshDynamicEmbeddedViews(viewData);\n\n  // Content query results must be refreshed before content hooks are called.\n  refreshContentQueries(tView);\n\n  if (!checkNoChangesMode) {\n    executeHooks(viewData, tView.contentHooks, tView.contentCheckHooks, creationMode);\n  }\n\n  refreshChildComponents(tView.components, parentFirstTemplatePass);\n}\n\n\n/** Sets the host bindings for the current view. */\nexport function setHostBindings(): void {\n  if (tView.expandoInstructions) {\n    bindingRootIndex = viewData[BINDING_INDEX] = tView.expandoStartIndex;\n    let currentDirectiveIndex = -1;\n    let currentElementIndex = -1;\n    for (let i = 0; i < tView.expandoInstructions.length; i++) {\n      const instruction = tView.expandoInstructions[i];\n      if (typeof instruction === 'number') {\n        if (instruction <= 0) {\n          // Negative numbers mean that we are starting new EXPANDO block and need to update\n          // the current element and directive index.\n          currentElementIndex = -instruction;\n          if (typeof viewData[bindingRootIndex] === 'number') {\n            // We've hit an injector. It may or may not exist depending on whether\n            // there is a public directive on this node.\n            bindingRootIndex += INJECTOR_SIZE;\n          }\n          currentDirectiveIndex = bindingRootIndex;\n        } else {\n          // This is either the injector size (so the binding root can skip over directives\n          // and get to the first set of host bindings on this node) or the host var count\n          // (to get to the next set of host bindings on this node).\n          bindingRootIndex += instruction;\n        }\n      } else {\n        // If it's not a number, it's a host binding function that needs to be executed.\n        viewData[BINDING_INDEX] = bindingRootIndex;\n        // We must subtract the header offset because the load() instruction\n        // expects a raw, unadjusted index.\n        instruction(currentDirectiveIndex - HEADER_OFFSET, currentElementIndex);\n        currentDirectiveIndex++;\n      }\n    }\n  }\n}\n\n/** Refreshes content queries for all directives in the given view. */\nfunction refreshContentQueries(tView: TView): void {\n  if (tView.contentQueries != null) {\n    for (let i = 0; i < tView.contentQueries.length; i += 2) {\n      const directiveDefIdx = tView.contentQueries[i];\n      const directiveDef = tView.data[directiveDefIdx] as DirectiveDef<any>;\n\n      directiveDef.contentQueriesRefresh !(\n          directiveDefIdx - HEADER_OFFSET, tView.contentQueries[i + 1]);\n    }\n  }\n}\n\n/** Refreshes child components in the current view. */\nfunction refreshChildComponents(\n    components: number[] | null, parentFirstTemplatePass: boolean): void {\n  if (components != null) {\n    for (let i = 0; i < components.length; i++) {\n      componentRefresh(components[i], parentFirstTemplatePass);\n    }\n  }\n}\n\nexport function executeInitAndContentHooks(): void {\n  if (!checkNoChangesMode) {\n    executeInitHooks(viewData, tView, creationMode);\n    executeHooks(viewData, tView.contentHooks, tView.contentCheckHooks, creationMode);\n  }\n}\n\nexport function createLViewData<T>(\n    renderer: Renderer3, tView: TView, context: T | null, flags: LViewFlags,\n    sanitizer?: Sanitizer | null): LViewData {\n  const instance = tView.blueprint.slice() as LViewData;\n  instance[FLAGS] = flags | LViewFlags.CreationMode | LViewFlags.Attached | LViewFlags.RunInit;\n  instance[PARENT] = instance[DECLARATION_VIEW] = viewData;\n  instance[CONTEXT] = context;\n  instance[INJECTOR] = viewData ? viewData[INJECTOR] : null;\n  instance[RENDERER] = renderer;\n  instance[SANITIZER] = sanitizer || null;\n  return instance;\n}\n\n/**\n * Create and stores the TNode, and hooks it up to the tree.\n *\n * @param index The index at which the TNode should be saved (null if view, since they are not\n * saved).\n * @param type The type of TNode to create\n * @param native The native element for this node, if applicable\n * @param name The tag name of the associated native element, if applicable\n * @param attrs Any attrs for the native element, if applicable\n */\nexport function createNodeAtIndex(\n    index: number, type: TNodeType.Element, native: RElement | RText | null, name: string | null,\n    attrs: TAttributes | null): TElementNode;\nexport function createNodeAtIndex(\n    index: number, type: TNodeType.Container, native: RComment, name: string | null,\n    attrs: TAttributes | null): TContainerNode;\nexport function createNodeAtIndex(\n    index: number, type: TNodeType.Projection, native: null, name: null,\n    attrs: TAttributes | null): TProjectionNode;\nexport function createNodeAtIndex(\n    index: number, type: TNodeType.ElementContainer, native: RComment, name: null,\n    attrs: TAttributes | null): TElementContainerNode;\nexport function createNodeAtIndex(\n    index: number, type: TNodeType, native: RText | RElement | RComment | null, name: string | null,\n    attrs: TAttributes | null): TElementNode&TContainerNode&TElementContainerNode&TProjectionNode {\n  const adjustedIndex = index + HEADER_OFFSET;\n  ngDevMode &&\n      assertLessThan(adjustedIndex, viewData.length, `Slot should have been initialized with null`);\n  viewData[adjustedIndex] = native;\n\n  let tNode = tView.data[adjustedIndex] as TNode;\n  if (tNode == null) {\n    tNode = tView.data[adjustedIndex] = createTNode(type, adjustedIndex, name, attrs, null);\n\n    // Now link ourselves into the tree.\n    if (previousOrParentTNode) {\n      if (isParent && previousOrParentTNode.child == null &&\n          (tNode.parent !== null || previousOrParentTNode.type === TNodeType.View)) {\n        // We are in the same view, which means we are adding content node to the parent view.\n        previousOrParentTNode.child = tNode;\n      } else if (!isParent) {\n        previousOrParentTNode.next = tNode;\n      }\n    }\n  }\n\n  if (tView.firstChild == null && type === TNodeType.Element) {\n    tView.firstChild = tNode;\n  }\n\n  previousOrParentTNode = tNode;\n  isParent = true;\n  return tNode as TElementNode & TViewNode & TContainerNode & TElementContainerNode &\n      TProjectionNode;\n}\n\nexport function createViewNode(index: number, view: LViewData) {\n  // View nodes are not stored in data because they can be added / removed at runtime (which\n  // would cause indices to change). Their TNodes are instead stored in tView.node.\n  if (view[TVIEW].node == null) {\n    view[TVIEW].node = createTNode(TNodeType.View, index, null, null, null) as TViewNode;\n  }\n\n  isParent = true;\n  return previousOrParentTNode = view[HOST_NODE] = view[TVIEW].node as TViewNode;\n}\n\n\n/**\n * When elements are created dynamically after a view blueprint is created (e.g. through\n * i18nApply() or ComponentFactory.create), we need to adjust the blueprint for future\n * template passes.\n */\nexport function adjustBlueprintForNewNode(view: LViewData) {\n  const tView = view[TVIEW];\n  if (tView.firstTemplatePass) {\n    tView.expandoStartIndex++;\n    tView.blueprint.push(null);\n    view.push(null);\n  }\n}\n\n\n//////////////////////////\n//// Render\n//////////////////////////\n\n/**\n * Resets the application state.\n */\nexport function resetComponentState() {\n  isParent = false;\n  previousOrParentTNode = null !;\n  elementDepthCount = 0;\n  bindingsEnabled = true;\n}\n\n/**\n *\n * @param hostNode Existing node to render into.\n * @param templateFn Template function with the instructions.\n * @param consts The number of nodes, local refs, and pipes in this template\n * @param context to pass into the template.\n * @param providedRendererFactory renderer factory to use\n * @param host The host element node to use\n * @param directives Directive defs that should be used for matching\n * @param pipes Pipe defs that should be used for matching\n */\nexport function renderTemplate<T>(\n    hostNode: RElement, templateFn: ComponentTemplate<T>, consts: number, vars: number, context: T,\n    providedRendererFactory: RendererFactory3, hostView: LViewData | null,\n    directives?: DirectiveDefListOrFactory | null, pipes?: PipeDefListOrFactory | null,\n    sanitizer?: Sanitizer | null): LViewData {\n  if (hostView == null) {\n    resetComponentState();\n    rendererFactory = providedRendererFactory;\n    renderer = providedRendererFactory.createRenderer(null, null);\n\n    // We need to create a root view so it's possible to look up the host element through its index\n    tView = createTView(-1, null, 1, 0, null, null, null);\n    viewData = createLViewData(renderer, tView, {}, LViewFlags.CheckAlways | LViewFlags.IsRoot);\n\n    const componentTView =\n        getOrCreateTView(templateFn, consts, vars, directives || null, pipes || null, null);\n    hostView =\n        createLViewData(renderer, componentTView, context, LViewFlags.CheckAlways, sanitizer);\n    hostView[HOST_NODE] = createNodeAtIndex(0, TNodeType.Element, hostNode, null, null);\n  }\n  renderComponentOrTemplate(hostView, context, templateFn);\n\n  return hostView;\n}\n\n/**\n * Used for creating the LViewNode of a dynamic embedded view,\n * either through ViewContainerRef.createEmbeddedView() or TemplateRef.createEmbeddedView().\n * Such lViewNode will then be renderer with renderEmbeddedTemplate() (see below).\n */\nexport function createEmbeddedViewAndNode<T>(\n    tView: TView, context: T, declarationView: LViewData, renderer: Renderer3,\n    queries: LQueries | null, injectorIndex: number): LViewData {\n  const _isParent = isParent;\n  const _previousOrParentTNode = previousOrParentTNode;\n  isParent = true;\n  previousOrParentTNode = null !;\n\n  const lView =\n      createLViewData(renderer, tView, context, LViewFlags.CheckAlways, getCurrentSanitizer());\n  lView[DECLARATION_VIEW] = declarationView;\n\n  if (queries) {\n    lView[QUERIES] = queries.createView();\n  }\n  createViewNode(-1, lView);\n\n  if (tView.firstTemplatePass) {\n    tView.node !.injectorIndex = injectorIndex;\n  }\n\n  isParent = _isParent;\n  previousOrParentTNode = _previousOrParentTNode;\n  return lView;\n}\n\n/**\n * Used for rendering embedded views (e.g. dynamically created views)\n *\n * Dynamically created views must store/retrieve their TViews differently from component views\n * because their template functions are nested in the template functions of their hosts, creating\n * closures. If their host template happens to be an embedded template in a loop (e.g. ngFor inside\n * an ngFor), the nesting would mean we'd have multiple instances of the template function, so we\n * can't store TViews in the template function itself (as we do for comps). Instead, we store the\n * TView for dynamically created views on their host TNode, which only has one instance.\n */\nexport function renderEmbeddedTemplate<T>(\n    viewToRender: LViewData, tView: TView, context: T, rf: RenderFlags) {\n  const _isParent = isParent;\n  const _previousOrParentTNode = previousOrParentTNode;\n  let oldView: LViewData;\n  if (viewToRender[FLAGS] & LViewFlags.IsRoot) {\n    // This is a root view inside the view tree\n    tickRootContext(viewToRender[CONTEXT] as RootContext);\n  } else {\n    try {\n      isParent = true;\n      previousOrParentTNode = null !;\n\n      oldView = enterView(viewToRender, viewToRender[HOST_NODE]);\n      namespaceHTML();\n      tView.template !(rf, context);\n      if (rf & RenderFlags.Update) {\n        refreshDescendantViews();\n      } else {\n        // This must be set to false immediately after the first creation run because in an\n        // ngFor loop, all the views will be created together before update mode runs and turns\n        // off firstTemplatePass. If we don't set it here, instances will perform directive\n        // matching, etc again and again.\n        viewToRender[TVIEW].firstTemplatePass = firstTemplatePass = false;\n      }\n    } finally {\n      // renderEmbeddedTemplate() is called twice, once for creation only and then once for\n      // update. When for creation only, leaveView() must not trigger view hooks, nor clean flags.\n      const isCreationOnly = (rf & RenderFlags.Create) === RenderFlags.Create;\n      leaveView(oldView !, isCreationOnly);\n      isParent = _isParent;\n      previousOrParentTNode = _previousOrParentTNode;\n    }\n  }\n}\n\n/**\n * Retrieves a context at the level specified and saves it as the global, contextViewData.\n * Will get the next level up if level is not specified.\n *\n * This is used to save contexts of parent views so they can be bound in embedded views, or\n * in conjunction with reference() to bind a ref from a parent view.\n *\n * @param level The relative level of the view from which to grab context compared to contextVewData\n * @returns context\n */\nexport function nextContext<T = any>(level: number = 1): T {\n  contextViewData = walkUpViews(level, contextViewData !);\n  return contextViewData[CONTEXT] as T;\n}\n\nexport function renderComponentOrTemplate<T>(\n    hostView: LViewData, componentOrContext: T, templateFn?: ComponentTemplate<T>) {\n  const oldView = enterView(hostView, hostView[HOST_NODE]);\n  try {\n    if (rendererFactory.begin) {\n      rendererFactory.begin();\n    }\n    if (templateFn) {\n      namespaceHTML();\n      templateFn(getRenderFlags(hostView), componentOrContext !);\n      refreshDescendantViews();\n    } else {\n      executeInitAndContentHooks();\n\n      // Element was stored at 0 in data and directive was stored at 0 in directives\n      // in renderComponent()\n      setHostBindings();\n      componentRefresh(HEADER_OFFSET, false);\n    }\n  } finally {\n    if (rendererFactory.end) {\n      rendererFactory.end();\n    }\n    leaveView(oldView);\n  }\n}\n\n/**\n * This function returns the default configuration of rendering flags depending on when the\n * template is in creation mode or update mode. By default, the update block is run with the\n * creation block when the view is in creation mode. Otherwise, the update block is run\n * alone.\n *\n * Dynamically created views do NOT use this configuration (update block and create block are\n * always run separately).\n */\nfunction getRenderFlags(view: LViewData): RenderFlags {\n  return view[FLAGS] & LViewFlags.CreationMode ? RenderFlags.Create | RenderFlags.Update :\n                                                 RenderFlags.Update;\n}\n\n//////////////////////////\n//// Namespace\n//////////////////////////\n\nlet _currentNamespace: string|null = null;\n\nexport function namespaceSVG() {\n  _currentNamespace = 'http://www.w3.org/2000/svg/';\n}\n\nexport function namespaceMathML() {\n  _currentNamespace = 'http://www.w3.org/1998/MathML/';\n}\n\nexport function namespaceHTML() {\n  _currentNamespace = null;\n}\n\n//////////////////////////\n//// Element\n//////////////////////////\n\n/**\n * Creates an empty element using {@link elementStart} and {@link elementEnd}\n *\n * @param index Index of the element in the data array\n * @param name Name of the DOM Node\n * @param attrs Statically bound set of attributes to be written into the DOM element on creation.\n * @param localRefs A set of local reference bindings on the element.\n */\nexport function element(\n    index: number, name: string, attrs?: TAttributes | null, localRefs?: string[] | null): void {\n  elementStart(index, name, attrs, localRefs);\n  elementEnd();\n}\n\n/**\n * Creates a logical container for other nodes (<ng-container>) backed by a comment node in the DOM.\n * The instruction must later be followed by `elementContainerEnd()` call.\n *\n * @param index Index of the element in the LViewData array\n * @param attrs Set of attributes to be used when matching directives.\n * @param localRefs A set of local reference bindings on the element.\n *\n * Even if this instruction accepts a set of attributes no actual attribute values are propagated to\n * the DOM (as a comment node can't have attributes). Attributes are here only for directive\n * matching purposes and setting initial inputs of directives.\n */\nexport function elementContainerStart(\n    index: number, attrs?: TAttributes | null, localRefs?: string[] | null): void {\n  ngDevMode && assertEqual(\n                   viewData[BINDING_INDEX], tView.bindingStartIndex,\n                   'element containers should be created before any bindings');\n\n  ngDevMode && ngDevMode.rendererCreateComment++;\n  const native = renderer.createComment(ngDevMode ? 'ng-container' : '');\n\n  ngDevMode && assertDataInRange(index - 1);\n  const tNode = createNodeAtIndex(index, TNodeType.ElementContainer, native, null, attrs || null);\n\n  appendChild(native, tNode, viewData);\n  createDirectivesAndLocals(localRefs);\n}\n\n/** Mark the end of the <ng-container>. */\nexport function elementContainerEnd(): void {\n  if (isParent) {\n    isParent = false;\n  } else {\n    ngDevMode && assertHasParent();\n    previousOrParentTNode = previousOrParentTNode.parent !;\n  }\n\n  ngDevMode && assertNodeType(previousOrParentTNode, TNodeType.ElementContainer);\n  currentQueries &&\n      (currentQueries = currentQueries.addNode(previousOrParentTNode as TElementContainerNode));\n\n  queueLifecycleHooks(previousOrParentTNode.flags, tView);\n}\n\n/**\n * Create DOM element. The instruction must later be followed by `elementEnd()` call.\n *\n * @param index Index of the element in the LViewData array\n * @param name Name of the DOM Node\n * @param attrs Statically bound set of attributes to be written into the DOM element on creation.\n * @param localRefs A set of local reference bindings on the element.\n *\n * Attributes and localRefs are passed as an array of strings where elements with an even index\n * hold an attribute name and elements with an odd index hold an attribute value, ex.:\n * ['id', 'warning5', 'class', 'alert']\n */\nexport function elementStart(\n    index: number, name: string, attrs?: TAttributes | null, localRefs?: string[] | null): void {\n  ngDevMode && assertEqual(\n                   viewData[BINDING_INDEX], tView.bindingStartIndex,\n                   'elements should be created before any bindings ');\n\n  ngDevMode && ngDevMode.rendererCreateElement++;\n\n  const native = elementCreate(name);\n\n  ngDevMode && assertDataInRange(index - 1);\n\n  const tNode = createNodeAtIndex(index, TNodeType.Element, native !, name, attrs || null);\n\n  if (attrs) {\n    setUpAttributes(native, attrs);\n  }\n\n  appendChild(native, tNode, viewData);\n  createDirectivesAndLocals(localRefs);\n\n  // any immediate children of a component or template container must be pre-emptively\n  // monkey-patched with the component view data so that the element can be inspected\n  // later on using any element discovery utility methods (see `element_discovery.ts`)\n  if (elementDepthCount === 0) {\n    attachPatchData(native, viewData);\n  }\n  elementDepthCount++;\n}\n\n/**\n * Creates a native element from a tag name, using a renderer.\n * @param name the tag name\n * @param overriddenRenderer Optional A renderer to override the default one\n * @returns the element created\n */\nexport function elementCreate(name: string, overriddenRenderer?: Renderer3): RElement {\n  let native: RElement;\n  const rendererToUse = overriddenRenderer || renderer;\n\n  if (isProceduralRenderer(rendererToUse)) {\n    native = rendererToUse.createElement(name, _currentNamespace);\n  } else {\n    if (_currentNamespace === null) {\n      native = rendererToUse.createElement(name);\n    } else {\n      native = rendererToUse.createElementNS(_currentNamespace, name);\n    }\n  }\n  return native;\n}\n\n/**\n * Creates directive instances and populates local refs.\n *\n * @param localRefs Local refs of the node in question\n * @param localRefExtractor mapping function that extracts local ref value from TNode\n */\nfunction createDirectivesAndLocals(\n    localRefs: string[] | null | undefined,\n    localRefExtractor: LocalRefExtractor = getNativeByTNode) {\n  if (!bindingsEnabled) return;\n  if (firstTemplatePass) {\n    ngDevMode && ngDevMode.firstTemplatePass++;\n    cacheMatchingDirectivesForNode(previousOrParentTNode, tView, localRefs || null);\n  } else {\n    instantiateDirectivesDirectly();\n  }\n  saveResolvedLocalsInData(localRefExtractor);\n}\n\n/**\n * On first template pass, we match each node against available directive selectors and save\n * the resulting defs in the correct instantiation order for subsequent change detection runs\n * (so dependencies are always created before the directives that inject them).\n */\nfunction cacheMatchingDirectivesForNode(\n    tNode: TNode, tView: TView, localRefs: string[] | null): void {\n  // Please make sure to have explicit type for `exportsMap`. Inferred type triggers bug in tsickle.\n  const exportsMap: ({[key: string]: number} | null) = localRefs ? {'': -1} : null;\n  const matches = tView.currentMatches = findDirectiveMatches(tNode);\n  generateExpandoBlock(tNode, matches);\n  let totalHostVars = 0;\n  if (matches) {\n    for (let i = 0; i < matches.length; i += 2) {\n      const def = matches[i] as DirectiveDef<any>;\n      const valueIndex = i + 1;\n      resolveDirective(def, valueIndex, matches);\n      totalHostVars += def.hostVars;\n      saveNameToExportMap(matches[valueIndex] as number, def, exportsMap);\n    }\n  }\n  if (exportsMap) cacheMatchingLocalNames(tNode, localRefs, exportsMap);\n  prefillHostVars(totalHostVars);\n}\n\n/**\n * Generates a new block in TView.expandoInstructions for this node.\n *\n * Each expando block starts with the element index (turned negative so we can distinguish\n * it from the hostVar count) and the directive count. See more in VIEW_DATA.md.\n */\nfunction generateExpandoBlock(tNode: TNode, matches: CurrentMatchesList | null): void {\n  const directiveCount = matches ? matches.length / 2 : 0;\n  const elementIndex = -(tNode.index - HEADER_OFFSET);\n  if (directiveCount > 0) {\n    (tView.expandoInstructions || (tView.expandoInstructions = [\n     ])).push(elementIndex, directiveCount);\n  }\n}\n\n/**\n * On the first template pass, we need to reserve space for host binding values\n * after directives are matched (so all directives are saved, then bindings).\n * Because we are updating the blueprint, we only need to do this once.\n */\nexport function prefillHostVars(totalHostVars: number): void {\n  for (let i = 0; i < totalHostVars; i++) {\n    viewData.push(NO_CHANGE);\n    tView.blueprint.push(NO_CHANGE);\n    tView.data.push(null);\n  }\n}\n\n/** Matches the current node against all available selectors. */\nfunction findDirectiveMatches(tNode: TNode): CurrentMatchesList|null {\n  const registry = tView.directiveRegistry;\n  let matches: any[]|null = null;\n  if (registry) {\n    for (let i = 0; i < registry.length; i++) {\n      const def = registry[i];\n      if (isNodeMatchingSelectorList(tNode, def.selectors !)) {\n        matches || (matches = []);\n        if (def.diPublic) def.diPublic(def);\n\n        if ((def as ComponentDef<any>).template) {\n          if (tNode.flags & TNodeFlags.isComponent) throwMultipleComponentError(tNode);\n          addComponentLogic(def as ComponentDef<any>);\n          // The component is always stored first with directives after.\n          matches.unshift(def, null);\n        } else {\n          matches.push(def, null);\n        }\n      }\n    }\n  }\n  return matches as CurrentMatchesList;\n}\n\nexport function resolveDirective(\n    def: DirectiveDef<any>, valueIndex: number, matches: CurrentMatchesList): any {\n  if (matches[valueIndex] === null) {\n    matches[valueIndex] = CIRCULAR;\n    const instance = def.factory();\n    return directiveCreate(matches[valueIndex] = viewData.length, instance, def);\n  } else if (matches[valueIndex] === CIRCULAR) {\n    // If we revisit this directive before it's resolved, we know it's circular\n    throwCyclicDependencyError(def.type);\n  }\n  return null;\n}\n\n/** Stores index of component's host element so it will be queued for view refresh during CD. */\nfunction queueComponentIndexForCheck(): void {\n  if (firstTemplatePass) {\n    (tView.components || (tView.components = [])).push(previousOrParentTNode.index);\n  }\n}\n\n/** Stores index of directive and host element so it will be queued for binding refresh during CD.\n */\nexport function queueHostBindingForCheck(\n    dirIndex: number, def: DirectiveDef<any>| ComponentDef<any>): void {\n  ngDevMode &&\n      assertEqual(firstTemplatePass, true, 'Should only be called in first template pass.');\n  tView.expandoInstructions !.push(def.hostBindings !, def.hostVars);\n}\n\n/**\n * This function instantiates the given directives.\n */\nfunction instantiateDirectivesDirectly() {\n  ngDevMode && assertEqual(\n                   firstTemplatePass, false,\n                   `Directives should only be instantiated directly after first template pass`);\n  const count = previousOrParentTNode.flags & TNodeFlags.DirectiveCountMask;\n\n  if (isContentQueryHost(previousOrParentTNode) && currentQueries) {\n    currentQueries = currentQueries.clone();\n  }\n\n  if (count > 0) {\n    const start = previousOrParentTNode.flags >> TNodeFlags.DirectiveStartingIndexShift;\n    const end = start + count;\n\n    for (let i = start; i < end; i++) {\n      const def = tView.data[i] as DirectiveDef<any>| ComponentDef<any>;\n\n      // Component view must be set on node before the factory is created so\n      // ChangeDetectorRefs have a way to store component view on creation.\n      if ((def as ComponentDef<any>).template) {\n        addComponentLogic(def as ComponentDef<any>);\n      }\n      directiveCreate(i, def.factory(), def);\n    }\n  }\n}\n\n/** Caches local names and their matching directive indices for query and template lookups. */\nfunction cacheMatchingLocalNames(\n    tNode: TNode, localRefs: string[] | null, exportsMap: {[key: string]: number}): void {\n  if (localRefs) {\n    const localNames: (string | number)[] = tNode.localNames = [];\n\n    // Local names must be stored in tNode in the same order that localRefs are defined\n    // in the template to ensure the data is loaded in the same slots as their refs\n    // in the template (for template queries).\n    for (let i = 0; i < localRefs.length; i += 2) {\n      const index = exportsMap[localRefs[i + 1]];\n      if (index == null) throw new Error(`Export of name '${localRefs[i + 1]}' not found!`);\n      localNames.push(localRefs[i], index);\n    }\n  }\n}\n\n/**\n * Builds up an export map as directives are created, so local refs can be quickly mapped\n * to their directive instances.\n */\nfunction saveNameToExportMap(\n    index: number, def: DirectiveDef<any>| ComponentDef<any>,\n    exportsMap: {[key: string]: number} | null) {\n  if (exportsMap) {\n    if (def.exportAs) exportsMap[def.exportAs] = index;\n    if ((def as ComponentDef<any>).template) exportsMap[''] = index;\n  }\n}\n\n/**\n * Takes a list of local names and indices and pushes the resolved local variable values\n * to LViewData in the same order as they are loaded in the template with load().\n */\nfunction saveResolvedLocalsInData(localRefExtractor: LocalRefExtractor): void {\n  const localNames = previousOrParentTNode.localNames;\n  const tNode = previousOrParentTNode as TElementNode | TContainerNode | TElementContainerNode;\n  if (localNames) {\n    let localIndex = previousOrParentTNode.index + 1;\n    for (let i = 0; i < localNames.length; i += 2) {\n      const index = localNames[i + 1] as number;\n      const value = index === -1 ? localRefExtractor(tNode, viewData) : viewData[index];\n      viewData[localIndex++] = value;\n    }\n  }\n}\n\n/**\n * Gets TView from a template function or creates a new TView\n * if it doesn't already exist.\n *\n * @param templateFn The template from which to get static data\n * @param consts The number of nodes, local refs, and pipes in this view\n * @param vars The number of bindings and pure function bindings in this view\n * @param directives Directive defs that should be saved on TView\n * @param pipes Pipe defs that should be saved on TView\n * @returns TView\n */\nexport function getOrCreateTView(\n    templateFn: ComponentTemplate<any>, consts: number, vars: number,\n    directives: DirectiveDefListOrFactory | null, pipes: PipeDefListOrFactory | null,\n    viewQuery: ComponentQuery<any>| null): TView {\n  // TODO(misko): reading `ngPrivateData` here is problematic for two reasons\n  // 1. It is a megamorphic call on each invocation.\n  // 2. For nested embedded views (ngFor inside ngFor) the template instance is per\n  //    outer template invocation, which means that no such property will exist\n  // Correct solution is to only put `ngPrivateData` on the Component template\n  // and not on embedded templates.\n\n  return templateFn.ngPrivateData ||\n      (templateFn.ngPrivateData =\n           createTView(-1, templateFn, consts, vars, directives, pipes, viewQuery) as never);\n}\n\n/**\n * Creates a TView instance\n *\n * @param viewIndex The viewBlockId for inline views, or -1 if it's a component/dynamic\n * @param templateFn Template function\n * @param consts The number of nodes, local refs, and pipes in this template\n * @param directives Registry of directives for this view\n * @param pipes Registry of pipes for this view\n */\nexport function createTView(\n    viewIndex: number, templateFn: ComponentTemplate<any>| null, consts: number, vars: number,\n    directives: DirectiveDefListOrFactory | null, pipes: PipeDefListOrFactory | null,\n    viewQuery: ComponentQuery<any>| null): TView {\n  ngDevMode && ngDevMode.tView++;\n  const bindingStartIndex = HEADER_OFFSET + consts;\n  // This length does not yet contain host bindings from child directives because at this point,\n  // we don't know which directives are active on this template. As soon as a directive is matched\n  // that has a host binding, we will update the blueprint with that def's hostVars count.\n  const initialViewLength = bindingStartIndex + vars;\n  const blueprint = createViewBlueprint(bindingStartIndex, initialViewLength);\n  return blueprint[TVIEW] = {\n    id: viewIndex,\n    blueprint: blueprint,\n    template: templateFn,\n    viewQuery: viewQuery,\n    node: null !,\n    data: blueprint.slice(),  // Fill in to match HEADER_OFFSET in LViewData\n    childIndex: -1,           // Children set in addToViewTree(), if any\n    bindingStartIndex: bindingStartIndex,\n    expandoStartIndex: initialViewLength,\n    expandoInstructions: null,\n    firstTemplatePass: true,\n    initHooks: null,\n    checkHooks: null,\n    contentHooks: null,\n    contentCheckHooks: null,\n    viewHooks: null,\n    viewCheckHooks: null,\n    destroyHooks: null,\n    pipeDestroyHooks: null,\n    cleanup: null,\n    contentQueries: null,\n    components: null,\n    directiveRegistry: typeof directives === 'function' ? directives() : directives,\n    pipeRegistry: typeof pipes === 'function' ? pipes() : pipes,\n    currentMatches: null,\n    firstChild: null,\n  };\n}\n\nfunction createViewBlueprint(bindingStartIndex: number, initialViewLength: number): LViewData {\n  const blueprint = new Array(initialViewLength)\n                        .fill(null, 0, bindingStartIndex)\n                        .fill(NO_CHANGE, bindingStartIndex) as LViewData;\n  blueprint[CONTAINER_INDEX] = -1;\n  blueprint[BINDING_INDEX] = bindingStartIndex;\n  return blueprint;\n}\n\nfunction setUpAttributes(native: RElement, attrs: TAttributes): void {\n  const isProc = isProceduralRenderer(renderer);\n  let i = 0;\n\n  while (i < attrs.length) {\n    const attrName = attrs[i];\n    if (attrName === AttributeMarker.SelectOnly) break;\n    if (attrName === NG_PROJECT_AS_ATTR_NAME) {\n      i += 2;\n    } else {\n      ngDevMode && ngDevMode.rendererSetAttribute++;\n      if (attrName === AttributeMarker.NamespaceURI) {\n        // Namespaced attributes\n        const namespaceURI = attrs[i + 1] as string;\n        const attrName = attrs[i + 2] as string;\n        const attrVal = attrs[i + 3] as string;\n        isProc ?\n            (renderer as ProceduralRenderer3)\n                .setAttribute(native, attrName, attrVal, namespaceURI) :\n            native.setAttributeNS(namespaceURI, attrName, attrVal);\n        i += 4;\n      } else {\n        // Standard attributes\n        const attrVal = attrs[i + 1];\n        isProc ?\n            (renderer as ProceduralRenderer3)\n                .setAttribute(native, attrName as string, attrVal as string) :\n            native.setAttribute(attrName as string, attrVal as string);\n        i += 2;\n      }\n    }\n  }\n}\n\nexport function createError(text: string, token: any) {\n  return new Error(`Renderer: ${text} [${stringify(token)}]`);\n}\n\n\n/**\n * Locates the host native element, used for bootstrapping existing nodes into rendering pipeline.\n *\n * @param elementOrSelector Render element or CSS selector to locate the element.\n */\nexport function locateHostElement(\n    factory: RendererFactory3, elementOrSelector: RElement | string): RElement|null {\n  ngDevMode && assertDataInRange(-1);\n  rendererFactory = factory;\n  const defaultRenderer = factory.createRenderer(null, null);\n  const rNode = typeof elementOrSelector === 'string' ?\n      (isProceduralRenderer(defaultRenderer) ?\n           defaultRenderer.selectRootElement(elementOrSelector) :\n           defaultRenderer.querySelector(elementOrSelector)) :\n      elementOrSelector;\n  if (ngDevMode && !rNode) {\n    if (typeof elementOrSelector === 'string') {\n      throw createError('Host node with selector not found:', elementOrSelector);\n    } else {\n      throw createError('Host node is required:', elementOrSelector);\n    }\n  }\n  return rNode;\n}\n\n/**\n * Adds an event listener to the current node.\n *\n * If an output exists on one of the node's directives, it also subscribes to the output\n * and saves the subscription for later cleanup.\n *\n * @param eventName Name of the event\n * @param listenerFn The function to be called when event emits\n * @param useCapture Whether or not to use capture in event listener.\n */\nexport function listener(\n    eventName: string, listenerFn: (e?: any) => any, useCapture = false): void {\n  const tNode = previousOrParentTNode;\n  ngDevMode && assertNodeOfPossibleTypes(\n                   tNode, TNodeType.Element, TNodeType.Container, TNodeType.ElementContainer);\n\n  // add native event listener - applicable to elements only\n  if (tNode.type === TNodeType.Element) {\n    const native = getNativeByTNode(previousOrParentTNode, viewData) as RElement;\n    ngDevMode && ngDevMode.rendererAddEventListener++;\n\n    // In order to match current behavior, native DOM event listeners must be added for all\n    // events (including outputs).\n    if (isProceduralRenderer(renderer)) {\n      const cleanupFn = renderer.listen(native, eventName, listenerFn);\n      storeCleanupFn(viewData, cleanupFn);\n    } else {\n      const wrappedListener = wrapListenerWithPreventDefault(listenerFn);\n      native.addEventListener(eventName, wrappedListener, useCapture);\n      const cleanupInstances = getCleanup(viewData);\n      cleanupInstances.push(wrappedListener);\n      if (firstTemplatePass) {\n        getTViewCleanup(viewData).push(\n            eventName, tNode.index, cleanupInstances !.length - 1, useCapture);\n      }\n    }\n  }\n\n  // subscribe to directive outputs\n  if (tNode.outputs === undefined) {\n    // if we create TNode here, inputs must be undefined so we know they still need to be\n    // checked\n    tNode.outputs = generatePropertyAliases(tNode.flags, BindingDirection.Output);\n  }\n\n  const outputs = tNode.outputs;\n  let outputData: PropertyAliasValue|undefined;\n  if (outputs && (outputData = outputs[eventName])) {\n    createOutput(outputData, listenerFn);\n  }\n}\n\n/**\n * Iterates through the outputs associated with a particular event name and subscribes to\n * each output.\n */\nfunction createOutput(outputs: PropertyAliasValue, listener: Function): void {\n  for (let i = 0; i < outputs.length; i += 2) {\n    ngDevMode && assertDataInRange(outputs[i] as number, viewData);\n    const subscription = viewData[outputs[i] as number][outputs[i + 1]].subscribe(listener);\n    storeCleanupWithContext(viewData, subscription, subscription.unsubscribe);\n  }\n}\n\n/**\n * Saves context for this cleanup function in LView.cleanupInstances.\n *\n * On the first template pass, saves in TView:\n * - Cleanup function\n * - Index of context we just saved in LView.cleanupInstances\n */\nexport function storeCleanupWithContext(\n    view: LViewData | null, context: any, cleanupFn: Function): void {\n  if (!view) view = viewData;\n  getCleanup(view).push(context);\n\n  if (view[TVIEW].firstTemplatePass) {\n    getTViewCleanup(view).push(cleanupFn, view[CLEANUP] !.length - 1);\n  }\n}\n\n/**\n * Saves the cleanup function itself in LView.cleanupInstances.\n *\n * This is necessary for functions that are wrapped with their contexts, like in renderer2\n * listeners.\n *\n * On the first template pass, the index of the cleanup function is saved in TView.\n */\nexport function storeCleanupFn(view: LViewData, cleanupFn: Function): void {\n  getCleanup(view).push(cleanupFn);\n\n  if (view[TVIEW].firstTemplatePass) {\n    getTViewCleanup(view).push(view[CLEANUP] !.length - 1, null);\n  }\n}\n\n/** Mark the end of the element. */\nexport function elementEnd(): void {\n  if (isParent) {\n    isParent = false;\n  } else {\n    ngDevMode && assertHasParent();\n    previousOrParentTNode = previousOrParentTNode.parent !;\n  }\n  ngDevMode && assertNodeType(previousOrParentTNode, TNodeType.Element);\n  currentQueries &&\n      (currentQueries = currentQueries.addNode(previousOrParentTNode as TElementNode));\n\n  queueLifecycleHooks(previousOrParentTNode.flags, tView);\n  elementDepthCount--;\n}\n\n/**\n * Updates the value of removes an attribute on an Element.\n *\n * @param number index The index of the element in the data array\n * @param name name The name of the attribute.\n * @param value value The attribute is removed when value is `null` or `undefined`.\n *                  Otherwise the attribute value is set to the stringified value.\n * @param sanitizer An optional function used to sanitize the value.\n */\nexport function elementAttribute(\n    index: number, name: string, value: any, sanitizer?: SanitizerFn): void {\n  if (value !== NO_CHANGE) {\n    const element = getNativeByIndex(index, viewData);\n    if (value == null) {\n      ngDevMode && ngDevMode.rendererRemoveAttribute++;\n      isProceduralRenderer(renderer) ? renderer.removeAttribute(element, name) :\n                                       element.removeAttribute(name);\n    } else {\n      ngDevMode && ngDevMode.rendererSetAttribute++;\n      const strValue = sanitizer == null ? stringify(value) : sanitizer(value);\n      isProceduralRenderer(renderer) ? renderer.setAttribute(element, name, strValue) :\n                                       element.setAttribute(name, strValue);\n    }\n  }\n}\n\n/**\n * Update a property on an Element.\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new @Inputs don't have to be re-compiled.\n *\n * @param index The index of the element to update in the data array\n * @param propName Name of property. Because it is going to DOM, this is not subject to\n *        renaming as part of minification.\n * @param value New value to write.\n * @param sanitizer An optional function used to sanitize the value.\n */\n\nexport function elementProperty<T>(\n    index: number, propName: string, value: T | NO_CHANGE, sanitizer?: SanitizerFn): void {\n  if (value === NO_CHANGE) return;\n  const element = getNativeByIndex(index, viewData) as RElement | RComment;\n  const tNode = getTNode(index, viewData);\n  // if tNode.inputs is undefined, a listener has created outputs, but inputs haven't\n  // yet been checked\n  if (tNode && tNode.inputs === undefined) {\n    // mark inputs as checked\n    tNode.inputs = generatePropertyAliases(tNode.flags, BindingDirection.Input);\n  }\n\n  const inputData = tNode && tNode.inputs;\n  let dataValue: PropertyAliasValue|undefined;\n  if (inputData && (dataValue = inputData[propName])) {\n    setInputsForProperty(dataValue, value);\n    if (isComponent(tNode)) markDirtyIfOnPush(index + HEADER_OFFSET);\n  } else if (tNode.type === TNodeType.Element) {\n    // It is assumed that the sanitizer is only added when the compiler determines that the property\n    // is risky, so sanitization can be done without further checks.\n    value = sanitizer != null ? (sanitizer(value) as any) : value;\n    ngDevMode && ngDevMode.rendererSetProperty++;\n    isProceduralRenderer(renderer) ?\n        renderer.setProperty(element as RElement, propName, value) :\n        ((element as RElement).setProperty ? (element as any).setProperty(propName, value) :\n                                             (element as any)[propName] = value);\n  }\n}\n\n/**\n * Enables directive matching on elements.\n *\n *  * Example:\n * ```\n * <my-comp my-directive>\n *   Should match component / directive.\n * </my-comp>\n * <div ngNonBindable>\n *   <!-- disabledBindings() -->\n *   <my-comp my-directive>\n *     Should not match component / directive because we are in ngNonBindable.\n *   </my-comp>\n *   <!-- enableBindings() -->\n * </div>\n * ```\n */\nexport function enableBindings(): void {\n  bindingsEnabled = true;\n}\n\n/**\n * Disables directive matching on element.\n *\n *  * Example:\n * ```\n * <my-comp my-directive>\n *   Should match component / directive.\n * </my-comp>\n * <div ngNonBindable>\n *   <!-- disabledBindings() -->\n *   <my-comp my-directive>\n *     Should not match component / directive because we are in ngNonBindable.\n *   </my-comp>\n *   <!-- enableBindings() -->\n * </div>\n * ```\n */\nexport function disableBindings(): void {\n  bindingsEnabled = false;\n}\n\n/**\n * Constructs a TNode object from the arguments.\n *\n * @param type The type of the node\n * @param adjustedIndex The index of the TNode in TView.data, adjusted for HEADER_OFFSET\n * @param tagName The tag name of the node\n * @param attrs The attributes defined on this node\n * @param tViews Any TViews attached to this node\n * @returns the TNode object\n */\nexport function createTNode(\n    type: TNodeType, adjustedIndex: number, tagName: string | null, attrs: TAttributes | null,\n    tViews: TView[] | null): TNode {\n  ngDevMode && ngDevMode.tNode++;\n  const parent =\n      isParent ? previousOrParentTNode : previousOrParentTNode && previousOrParentTNode.parent;\n\n  // Parents cannot cross component boundaries because components will be used in multiple places,\n  // so it's only set if the view is the same.\n  const parentInSameView = parent && viewData && parent !== viewData[HOST_NODE];\n  const tParent = parentInSameView ? parent as TElementNode | TContainerNode : null;\n\n  return {\n    type: type,\n    index: adjustedIndex,\n    injectorIndex: tParent ? tParent.injectorIndex : -1,\n    flags: 0,\n    tagName: tagName,\n    attrs: attrs,\n    localNames: null,\n    initialInputs: undefined,\n    inputs: undefined,\n    outputs: undefined,\n    tViews: tViews,\n    next: null,\n    child: null,\n    parent: tParent,\n    detached: null,\n    stylingTemplate: null,\n    projection: null\n  };\n}\n\n/**\n * Given a list of directive indices and minified input names, sets the\n * input properties on the corresponding directives.\n */\nfunction setInputsForProperty(inputs: PropertyAliasValue, value: any): void {\n  for (let i = 0; i < inputs.length; i += 2) {\n    ngDevMode && assertDataInRange(inputs[i] as number, viewData);\n    viewData[inputs[i] as number][inputs[i + 1]] = value;\n  }\n}\n\n/**\n * Consolidates all inputs or outputs of all directives on this logical node.\n *\n * @param number tNodeFlags node flags\n * @param Direction direction whether to consider inputs or outputs\n * @returns PropertyAliases|null aggregate of all properties if any, `null` otherwise\n */\nfunction generatePropertyAliases(\n    tNodeFlags: TNodeFlags, direction: BindingDirection): PropertyAliases|null {\n  const count = tNodeFlags & TNodeFlags.DirectiveCountMask;\n  let propStore: PropertyAliases|null = null;\n\n  if (count > 0) {\n    const start = tNodeFlags >> TNodeFlags.DirectiveStartingIndexShift;\n    const end = start + count;\n    const isInput = direction === BindingDirection.Input;\n    const defs = tView.data;\n\n    for (let i = start; i < end; i++) {\n      const directiveDef = defs[i] as DirectiveDef<any>;\n      const propertyAliasMap: {[publicName: string]: string} =\n          isInput ? directiveDef.inputs : directiveDef.outputs;\n      for (let publicName in propertyAliasMap) {\n        if (propertyAliasMap.hasOwnProperty(publicName)) {\n          propStore = propStore || {};\n          const internalName = propertyAliasMap[publicName];\n          const hasProperty = propStore.hasOwnProperty(publicName);\n          hasProperty ? propStore[publicName].push(i, internalName) :\n                        (propStore[publicName] = [i, internalName]);\n        }\n      }\n    }\n  }\n  return propStore;\n}\n\n/**\n * Add or remove a class in a `classList` on a DOM element.\n *\n * This instruction is meant to handle the [class.foo]=\"exp\" case\n *\n * @param index The index of the element to update in the data array\n * @param className Name of class to toggle. Because it is going to DOM, this is not subject to\n *        renaming as part of minification.\n * @param value A value indicating if a given class should be added or removed.\n */\nexport function elementClassProp<T>(\n    index: number, stylingIndex: number, value: T | NO_CHANGE): void {\n  updateElementClassProp(getStylingContext(index, viewData), stylingIndex, value ? true : false);\n}\n\n/**\n * Assign any inline style values to the element during creation mode.\n *\n * This instruction is meant to be called during creation mode to apply all styling\n * (e.g. `style=\"...\"`) values to the element. This is also where the provided index\n * value is allocated for the styling details for its corresponding element (the element\n * index is the previous index value from this one).\n *\n * (Note this function calls `elementStylingApply` immediately when called.)\n *\n *\n * @param index Index value which will be allocated to store styling data for the element.\n *        (Note that this is not the element index, but rather an index value allocated\n *        specifically for element styling--the index must be the next index after the element\n *        index.)\n * @param classDeclarations A key/value array of CSS classes that will be registered on the element.\n *   Each individual style will be used on the element as long as it is not overridden\n *   by any classes placed on the element by multiple (`[class]`) or singular (`[class.named]`)\n *   bindings. If a class binding changes its value to a falsy value then the matching initial\n *   class value that are passed in here will be applied to the element (if matched).\n * @param styleDeclarations A key/value array of CSS styles that will be registered on the element.\n *   Each individual style will be used on the element as long as it is not overridden\n *   by any styles placed on the element by multiple (`[style]`) or singular (`[style.prop]`)\n *   bindings. If a style binding changes its value to null then the initial styling\n *   values that are passed in here will be applied to the element (if matched).\n * @param styleSanitizer An optional sanitizer function that will be used (if provided)\n *   to sanitize the any CSS property values that are applied to the element (during rendering).\n */\nexport function elementStyling<T>(\n    classDeclarations?: (string | boolean | InitialStylingFlags)[] | null,\n    styleDeclarations?: (string | boolean | InitialStylingFlags)[] | null,\n    styleSanitizer?: StyleSanitizeFn | null): void {\n  const tNode = previousOrParentTNode;\n  if (!tNode.stylingTemplate) {\n    // initialize the styling template.\n    tNode.stylingTemplate =\n        createStylingContextTemplate(classDeclarations, styleDeclarations, styleSanitizer);\n  }\n  if (styleDeclarations && styleDeclarations.length ||\n      classDeclarations && classDeclarations.length) {\n    elementStylingApply(tNode.index - HEADER_OFFSET);\n  }\n}\n\n\n/**\n * Apply all styling values to the element which have been queued by any styling instructions.\n *\n * This instruction is meant to be run once one or more `elementStyle` and/or `elementStyleProp`\n * have been issued against the element. This function will also determine if any styles have\n * changed and will then skip the operation if there is nothing new to render.\n *\n * Once called then all queued styles will be flushed.\n *\n * @param index Index of the element's styling storage that will be rendered.\n *        (Note that this is not the element index, but rather an index value allocated\n *        specifically for element styling--the index must be the next index after the element\n *        index.)\n */\nexport function elementStylingApply<T>(index: number): void {\n  renderElementStyles(getStylingContext(index, viewData), renderer);\n}\n\n/**\n * Queue a given style to be rendered on an Element.\n *\n * If the style value is `null` then it will be removed from the element\n * (or assigned a different value depending if there are any styles placed\n * on the element with `elementStyle` or any styles that are present\n * from when the element was created (with `elementStyling`).\n *\n * (Note that the styling instruction will not be applied until `elementStylingApply` is called.)\n *\n * @param index Index of the element's styling storage to change in the data array.\n *        (Note that this is not the element index, but rather an index value allocated\n *        specifically for element styling--the index must be the next index after the element\n *        index.)\n * @param styleIndex Index of the style property on this element. (Monotonically increasing.)\n * @param value New value to write (null to remove).\n * @param suffix Optional suffix. Used with scalar values to add unit such as `px`.\n *        Note that when a suffix is provided then the underlying sanitizer will\n *        be ignored.\n */\nexport function elementStyleProp<T>(\n    index: number, styleIndex: number, value: T | null, suffix?: string): void {\n  let valueToAdd: string|null = null;\n  if (value) {\n    if (suffix) {\n      // when a suffix is applied then it will bypass\n      // sanitization entirely (b/c a new string is created)\n      valueToAdd = stringify(value) + suffix;\n    } else {\n      // sanitization happens by dealing with a String value\n      // this means that the string value will be passed through\n      // into the style rendering later (which is where the value\n      // will be sanitized before it is applied)\n      valueToAdd = value as any as string;\n    }\n  }\n  updateElementStyleProp(getStylingContext(index, viewData), styleIndex, valueToAdd);\n}\n\n/**\n * Queue a key/value map of styles to be rendered on an Element.\n *\n * This instruction is meant to handle the `[style]=\"exp\"` usage. When styles are applied to\n * the Element they will then be placed with respect to any styles set with `elementStyleProp`.\n * If any styles are set to `null` then they will be removed from the element (unless the same\n * style properties have been assigned to the element during creation using `elementStyling`).\n *\n * (Note that the styling instruction will not be applied until `elementStylingApply` is called.)\n *\n * @param index Index of the element's styling storage to change in the data array.\n *        (Note that this is not the element index, but rather an index value allocated\n *        specifically for element styling--the index must be the next index after the element\n *        index.)\n * @param classes A key/value style map of CSS classes that will be added to the given element.\n *        Any missing classes (that have already been applied to the element beforehand) will be\n *        removed (unset) from the element's list of CSS classes.\n * @param styles A key/value style map of the styles that will be applied to the given element.\n *        Any missing styles (that have already been applied to the element beforehand) will be\n *        removed (unset) from the element's styling.\n */\nexport function elementStylingMap<T>(\n    index: number, classes: {[key: string]: any} | string | null,\n    styles?: {[styleName: string]: any} | null): void {\n  updateStylingMap(getStylingContext(index, viewData), classes, styles);\n}\n\n//////////////////////////\n//// Text\n//////////////////////////\n\n/**\n * Create static text node\n *\n * @param index Index of the node in the data array\n * @param value Value to write. This value will be stringified.\n */\nexport function text(index: number, value?: any): void {\n  ngDevMode && assertEqual(\n                   viewData[BINDING_INDEX], tView.bindingStartIndex,\n                   'text nodes should be created before any bindings');\n  ngDevMode && ngDevMode.rendererCreateTextNode++;\n  const textNative = createTextNode(value, renderer);\n  const tNode = createNodeAtIndex(index, TNodeType.Element, textNative, null, null);\n\n  // Text nodes are self closing.\n  isParent = false;\n  appendChild(textNative, tNode, viewData);\n}\n\n/**\n * Create text node with binding\n * Bindings should be handled externally with the proper interpolation(1-8) method\n *\n * @param index Index of the node in the data array.\n * @param value Stringified value to write.\n */\nexport function textBinding<T>(index: number, value: T | NO_CHANGE): void {\n  if (value !== NO_CHANGE) {\n    ngDevMode && assertDataInRange(index + HEADER_OFFSET);\n    const element = getNativeByIndex(index, viewData) as any as RText;\n    ngDevMode && assertDefined(element, 'native element should exist');\n    ngDevMode && ngDevMode.rendererSetText++;\n    isProceduralRenderer(renderer) ? renderer.setValue(element, stringify(value)) :\n                                     element.textContent = stringify(value);\n  }\n}\n\n//////////////////////////\n//// Directive\n//////////////////////////\n\n/**\n * Create a directive and their associated content queries.\n *\n * NOTE: directives can be created in order other than the index order. They can also\n *       be retrieved before they are created in which case the value will be null.\n *\n * @param directive The directive instance.\n * @param directiveDef DirectiveDef object which contains information about the template.\n */\nexport function directiveCreate<T>(\n    directiveDefIdx: number, directive: T, directiveDef: DirectiveDef<T>| ComponentDef<T>): T {\n  const native = getNativeByTNode(previousOrParentTNode, viewData);\n  const instance = baseDirectiveCreate(directiveDefIdx, directive, directiveDef, native);\n\n  if ((directiveDef as ComponentDef<T>).template) {\n    const componentView = getComponentViewByIndex(previousOrParentTNode.index, viewData);\n    componentView[CONTEXT] = directive;\n  }\n\n  if (firstTemplatePass) {\n    // Init hooks are queued now so ngOnInit is called in host components before\n    // any projected components.\n    queueInitHooks(directiveDefIdx, directiveDef.onInit, directiveDef.doCheck, tView);\n  }\n\n  ngDevMode && assertDefined(previousOrParentTNode, 'previousOrParentTNode');\n  if (previousOrParentTNode && previousOrParentTNode.attrs) {\n    setInputsFromAttrs(directiveDefIdx, instance, directiveDef.inputs, previousOrParentTNode);\n  }\n\n  if (directiveDef.contentQueries) {\n    directiveDef.contentQueries();\n  }\n\n  return instance;\n}\n\nfunction addComponentLogic<T>(def: ComponentDef<T>): void {\n  const native = getNativeByTNode(previousOrParentTNode, viewData);\n\n  const tView = getOrCreateTView(\n      def.template, def.consts, def.vars, def.directiveDefs, def.pipeDefs, def.viewQuery);\n\n  // Only component views should be added to the view tree directly. Embedded views are\n  // accessed through their containers because they may be removed / re-added later.\n  const componentView = addToViewTree(\n      viewData, previousOrParentTNode.index as number,\n      createLViewData(\n          rendererFactory.createRenderer(native as RElement, def), tView, null,\n          def.onPush ? LViewFlags.Dirty : LViewFlags.CheckAlways, getCurrentSanitizer()));\n\n  componentView[HOST_NODE] = previousOrParentTNode as TElementNode;\n\n  // Component view will always be created before any injected LContainers,\n  // so this is a regular element, wrap it with the component view\n  componentView[HOST] = viewData[previousOrParentTNode.index];\n  viewData[previousOrParentTNode.index] = componentView;\n\n  if (firstTemplatePass) {\n    queueComponentIndexForCheck();\n    previousOrParentTNode.flags =\n        viewData.length << TNodeFlags.DirectiveStartingIndexShift | TNodeFlags.isComponent;\n  }\n}\n\n/**\n * A lighter version of directiveCreate() that is used for the root component\n *\n * This version does not contain features that we don't already support at root in\n * current Angular. Example: local refs and inputs on root component.\n */\nexport function baseDirectiveCreate<T>(\n    index: number, directive: T, directiveDef: DirectiveDef<T>| ComponentDef<T>,\n    native: RNode | null): T {\n  ngDevMode && assertEqual(\n                   viewData[BINDING_INDEX], tView.bindingStartIndex,\n                   'directives should be created before any bindings');\n  ngDevMode && assertPreviousIsParent();\n\n  attachPatchData(directive, viewData);\n  if (native) {\n    attachPatchData(native, viewData);\n  }\n\n  viewData[index] = directive;\n\n  if (firstTemplatePass) {\n    const flags = previousOrParentTNode.flags;\n    if (flags === 0) {\n      // When the first directive is created:\n      // - save the index,\n      // - set the number of directives to 1\n      previousOrParentTNode.flags =\n          index << TNodeFlags.DirectiveStartingIndexShift | flags & TNodeFlags.isComponent | 1;\n    } else {\n      // Only need to bump the size when subsequent directives are created\n      ngDevMode && assertNotEqual(\n                       flags & TNodeFlags.DirectiveCountMask, TNodeFlags.DirectiveCountMask,\n                       'Reached the max number of directives');\n      previousOrParentTNode.flags++;\n    }\n\n    tView.data.push(directiveDef);\n    tView.blueprint.push(null);\n    if (directiveDef.hostBindings) queueHostBindingForCheck(index, directiveDef);\n  } else {\n    const diPublic = directiveDef !.diPublic;\n    if (diPublic) diPublic(directiveDef !);\n  }\n\n  if (directiveDef !.attributes != null && previousOrParentTNode.type == TNodeType.Element) {\n    setUpAttributes(native as RElement, directiveDef !.attributes as string[]);\n  }\n\n  return directive;\n}\n\n/**\n * Sets initial input properties on directive instances from attribute data\n *\n * @param directiveIndex Index of the directive in directives array\n * @param instance Instance of the directive on which to set the initial inputs\n * @param inputs The list of inputs from the directive def\n * @param tNode The static data for this node\n */\nfunction setInputsFromAttrs<T>(\n    directiveIndex: number, instance: T, inputs: {[P in keyof T]: string;}, tNode: TNode): void {\n  let initialInputData = tNode.initialInputs as InitialInputData | undefined;\n  if (initialInputData === undefined || directiveIndex >= initialInputData.length) {\n    initialInputData = generateInitialInputs(directiveIndex, inputs, tNode);\n  }\n\n  const initialInputs: InitialInputs|null = initialInputData[directiveIndex];\n  if (initialInputs) {\n    for (let i = 0; i < initialInputs.length; i += 2) {\n      (instance as any)[initialInputs[i]] = initialInputs[i + 1];\n    }\n  }\n}\n\n/**\n * Generates initialInputData for a node and stores it in the template's static storage\n * so subsequent template invocations don't have to recalculate it.\n *\n * initialInputData is an array containing values that need to be set as input properties\n * for directives on this node, but only once on creation. We need this array to support\n * the case where you set an @Input property of a directive using attribute-like syntax.\n * e.g. if you have a `name` @Input, you can set it once like this:\n *\n * <my-component name=\"Bess\"></my-component>\n *\n * @param directiveIndex Index to store the initial input data\n * @param inputs The list of inputs from the directive def\n * @param tNode The static data on this node\n */\nfunction generateInitialInputs(\n    directiveIndex: number, inputs: {[key: string]: string}, tNode: TNode): InitialInputData {\n  const initialInputData: InitialInputData = tNode.initialInputs || (tNode.initialInputs = []);\n  initialInputData[directiveIndex] = null;\n\n  const attrs = tNode.attrs !;\n  let i = 0;\n  while (i < attrs.length) {\n    const attrName = attrs[i];\n    if (attrName === AttributeMarker.SelectOnly) break;\n    if (attrName === AttributeMarker.NamespaceURI) {\n      // We do not allow inputs on namespaced attributes.\n      i += 4;\n      continue;\n    }\n    const minifiedInputName = inputs[attrName];\n    const attrValue = attrs[i + 1];\n\n    if (minifiedInputName !== undefined) {\n      const inputsToStore: InitialInputs =\n          initialInputData[directiveIndex] || (initialInputData[directiveIndex] = []);\n      inputsToStore.push(minifiedInputName, attrValue as string);\n    }\n\n    i += 2;\n  }\n  return initialInputData;\n}\n\n//////////////////////////\n//// ViewContainer & View\n//////////////////////////\n\n/**\n * Creates a LContainer, either from a container instruction, or for a ViewContainerRef.\n *\n * @param hostNative The host element for the LContainer\n * @param hostTNode The host TNode for the LContainer\n * @param currentView The parent view of the LContainer\n * @param native The native comment element\n * @param isForViewContainerRef Optional a flag indicating the ViewContainerRef case\n * @returns LContainer\n */\nexport function createLContainer(\n    hostNative: RElement | RComment,\n    hostTNode: TElementNode | TContainerNode | TElementContainerNode, currentView: LViewData,\n    native: RComment, isForViewContainerRef?: boolean): LContainer {\n  return [\n    isForViewContainerRef ? -1 : 0,          // active index\n    [],                                      // views\n    currentView,                             // parent\n    null,                                    // next\n    null,                                    // queries\n    hostNative,                              // host native\n    native,                                  // native\n    getRenderParent(hostTNode, currentView)  // renderParent\n  ];\n}\n\n/**\n * Creates an LContainer for an ng-template (dynamically-inserted view), e.g.\n *\n * <ng-template #foo>\n *    <div></div>\n * </ng-template>\n *\n * @param index The index of the container in the data array\n * @param templateFn Inline template\n * @param consts The number of nodes, local refs, and pipes for this template\n * @param vars The number of bindings for this template\n * @param tagName The name of the container element, if applicable\n * @param attrs The attrs attached to the container, if applicable\n * @param localRefs A set of local reference bindings on the element.\n * @param localRefExtractor A function which extracts local-refs values from the template.\n *        Defaults to the current element associated with the local-ref.\n */\nexport function template(\n    index: number, templateFn: ComponentTemplate<any>| null, consts: number, vars: number,\n    tagName?: string | null, attrs?: TAttributes | null, localRefs?: string[] | null,\n    localRefExtractor?: LocalRefExtractor) {\n  // TODO: consider a separate node type for templates\n  const tNode = containerInternal(index, tagName || null, attrs || null);\n\n  if (firstTemplatePass) {\n    tNode.tViews = createTView(\n        -1, templateFn, consts, vars, tView.directiveRegistry, tView.pipeRegistry, null);\n  }\n\n  createDirectivesAndLocals(localRefs, localRefExtractor);\n  currentQueries &&\n      (currentQueries = currentQueries.addNode(previousOrParentTNode as TContainerNode));\n  queueLifecycleHooks(tNode.flags, tView);\n  isParent = false;\n}\n\n/**\n * Creates an LContainer for inline views, e.g.\n *\n * % if (showing) {\n *   <div></div>\n * % }\n *\n * @param index The index of the container in the data array\n */\nexport function container(index: number): void {\n  const tNode = containerInternal(index, null, null);\n  firstTemplatePass && (tNode.tViews = []);\n  isParent = false;\n}\n\nfunction containerInternal(\n    index: number, tagName: string | null, attrs: TAttributes | null): TNode {\n  ngDevMode && assertEqual(\n                   viewData[BINDING_INDEX], tView.bindingStartIndex,\n                   'container nodes should be created before any bindings');\n\n  const adjustedIndex = index + HEADER_OFFSET;\n  const comment = renderer.createComment(ngDevMode ? 'container' : '');\n  ngDevMode && ngDevMode.rendererCreateComment++;\n  const tNode = createNodeAtIndex(index, TNodeType.Container, comment, tagName, attrs);\n  const lContainer = viewData[adjustedIndex] =\n      createLContainer(viewData[adjustedIndex], tNode, viewData, comment);\n\n  appendChild(comment, tNode, viewData);\n\n  // Containers are added to the current view tree instead of their embedded views\n  // because views can be removed and re-inserted.\n  addToViewTree(viewData, index + HEADER_OFFSET, lContainer);\n\n  if (currentQueries) {\n    // prepare place for matching nodes from views inserted into a given container\n    lContainer[QUERIES] = currentQueries.container();\n  }\n\n  ngDevMode && assertNodeType(previousOrParentTNode, TNodeType.Container);\n  return tNode;\n}\n\n/**\n * Sets a container up to receive views.\n *\n * @param index The index of the container in the data array\n */\nexport function containerRefreshStart(index: number): void {\n  previousOrParentTNode = loadInternal(index, tView.data) as TNode;\n\n  ngDevMode && assertNodeType(previousOrParentTNode, TNodeType.Container);\n  isParent = true;\n\n  viewData[index + HEADER_OFFSET][ACTIVE_INDEX] = 0;\n\n  if (!checkNoChangesMode) {\n    // We need to execute init hooks here so ngOnInit hooks are called in top level views\n    // before they are called in embedded views (for backwards compatibility).\n    executeInitHooks(viewData, tView, creationMode);\n  }\n}\n\n/**\n * Marks the end of the LContainer.\n *\n * Marking the end of LContainer is the time when to child views get inserted or removed.\n */\nexport function containerRefreshEnd(): void {\n  if (isParent) {\n    isParent = false;\n  } else {\n    ngDevMode && assertNodeType(previousOrParentTNode, TNodeType.View);\n    ngDevMode && assertHasParent();\n    previousOrParentTNode = previousOrParentTNode.parent !;\n  }\n\n  ngDevMode && assertNodeType(previousOrParentTNode, TNodeType.Container);\n\n  const lContainer = viewData[previousOrParentTNode.index];\n  const nextIndex = lContainer[ACTIVE_INDEX];\n\n  // remove extra views at the end of the container\n  while (nextIndex < lContainer[VIEWS].length) {\n    removeView(lContainer, previousOrParentTNode as TContainerNode, nextIndex);\n  }\n}\n\n/**\n * Goes over dynamic embedded views (ones created through ViewContainerRef APIs) and refreshes them\n * by executing an associated template function.\n */\nfunction refreshDynamicEmbeddedViews(lViewData: LViewData) {\n  for (let current = getLViewChild(lViewData); current !== null; current = current[NEXT]) {\n    // Note: current can be an LViewData or an LContainer instance, but here we are only interested\n    // in LContainer. We can tell it's an LContainer because its length is less than the LViewData\n    // header.\n    if (current.length < HEADER_OFFSET && current[ACTIVE_INDEX] === -1) {\n      const container = current as LContainer;\n      for (let i = 0; i < container[VIEWS].length; i++) {\n        const dynamicViewData = container[VIEWS][i];\n        // The directives and pipes are not needed here as an existing view is only being refreshed.\n        ngDevMode && assertDefined(dynamicViewData[TVIEW], 'TView must be allocated');\n        renderEmbeddedTemplate(\n            dynamicViewData, dynamicViewData[TVIEW], dynamicViewData[CONTEXT] !,\n            RenderFlags.Update);\n      }\n    }\n  }\n}\n\n\n/**\n * Looks for a view with a given view block id inside a provided LContainer.\n * Removes views that need to be deleted in the process.\n *\n * @param lContainer to search for views\n * @param tContainerNode to search for views\n * @param startIdx starting index in the views array to search from\n * @param viewBlockId exact view block id to look for\n * @returns index of a found view or -1 if not found\n */\nfunction scanForView(\n    lContainer: LContainer, tContainerNode: TContainerNode, startIdx: number,\n    viewBlockId: number): LViewData|null {\n  const views = lContainer[VIEWS];\n  for (let i = startIdx; i < views.length; i++) {\n    const viewAtPositionId = views[i][TVIEW].id;\n    if (viewAtPositionId === viewBlockId) {\n      return views[i];\n    } else if (viewAtPositionId < viewBlockId) {\n      // found a view that should not be at this position - remove\n      removeView(lContainer, tContainerNode, i);\n    } else {\n      // found a view with id greater than the one we are searching for\n      // which means that required view doesn't exist and can't be found at\n      // later positions in the views array - stop the search here\n      break;\n    }\n  }\n  return null;\n}\n\n/**\n * Marks the start of an embedded view.\n *\n * @param viewBlockId The ID of this view\n * @return boolean Whether or not this view is in creation mode\n */\nexport function embeddedViewStart(viewBlockId: number, consts: number, vars: number): RenderFlags {\n  // The previous node can be a view node if we are processing an inline for loop\n  const containerTNode = previousOrParentTNode.type === TNodeType.View ?\n      previousOrParentTNode.parent ! :\n      previousOrParentTNode;\n  const lContainer = viewData[containerTNode.index] as LContainer;\n  const currentView = viewData;\n\n  ngDevMode && assertNodeType(containerTNode, TNodeType.Container);\n  let viewToRender = scanForView(\n      lContainer, containerTNode as TContainerNode, lContainer[ACTIVE_INDEX] !, viewBlockId);\n\n  if (viewToRender) {\n    isParent = true;\n    enterView(viewToRender, viewToRender[TVIEW].node);\n  } else {\n    // When we create a new LView, we always reset the state of the instructions.\n    viewToRender = createLViewData(\n        renderer,\n        getOrCreateEmbeddedTView(viewBlockId, consts, vars, containerTNode as TContainerNode), null,\n        LViewFlags.CheckAlways, getCurrentSanitizer());\n\n    if (lContainer[QUERIES]) {\n      viewToRender[QUERIES] = lContainer[QUERIES] !.createView();\n    }\n\n    createViewNode(viewBlockId, viewToRender);\n    enterView(viewToRender, viewToRender[TVIEW].node);\n  }\n  if (lContainer) {\n    if (creationMode) {\n      // it is a new view, insert it into collection of views for a given container\n      insertView(viewToRender, lContainer, currentView, lContainer[ACTIVE_INDEX] !, -1);\n    }\n    lContainer[ACTIVE_INDEX] !++;\n  }\n  return getRenderFlags(viewToRender);\n}\n\n/**\n * Initialize the TView (e.g. static data) for the active embedded view.\n *\n * Each embedded view block must create or retrieve its own TView. Otherwise, the embedded view's\n * static data for a particular node would overwrite the static data for a node in the view above\n * it with the same index (since it's in the same template).\n *\n * @param viewIndex The index of the TView in TNode.tViews\n * @param consts The number of nodes, local refs, and pipes in this template\n * @param vars The number of bindings and pure function bindings in this template\n * @param container The parent container in which to look for the view's static data\n * @returns TView\n */\nfunction getOrCreateEmbeddedTView(\n    viewIndex: number, consts: number, vars: number, parent: TContainerNode): TView {\n  ngDevMode && assertNodeType(parent, TNodeType.Container);\n  const containerTViews = parent.tViews as TView[];\n  ngDevMode && assertDefined(containerTViews, 'TView expected');\n  ngDevMode && assertEqual(Array.isArray(containerTViews), true, 'TViews should be in an array');\n  if (viewIndex >= containerTViews.length || containerTViews[viewIndex] == null) {\n    containerTViews[viewIndex] = createTView(\n        viewIndex, null, consts, vars, tView.directiveRegistry, tView.pipeRegistry, null);\n  }\n  return containerTViews[viewIndex];\n}\n\n/** Marks the end of an embedded view. */\nexport function embeddedViewEnd(): void {\n  const viewHost = viewData[HOST_NODE];\n  refreshDescendantViews();\n  leaveView(viewData[PARENT] !);\n  previousOrParentTNode = viewHost !;\n  isParent = false;\n}\n\n/////////////\n\n/**\n * Refreshes components by entering the component view and processing its bindings, queries, etc.\n *\n * @param adjustedElementIndex  Element index in LViewData[] (adjusted for HEADER_OFFSET)\n */\nexport function componentRefresh<T>(\n    adjustedElementIndex: number, parentFirstTemplatePass: boolean): void {\n  ngDevMode && assertDataInRange(adjustedElementIndex);\n  const hostView = getComponentViewByIndex(adjustedElementIndex, viewData);\n  ngDevMode && assertNodeType(tView.data[adjustedElementIndex] as TNode, TNodeType.Element);\n\n  // Only attached CheckAlways components or attached, dirty OnPush components should be checked\n  if (viewAttached(hostView) && hostView[FLAGS] & (LViewFlags.CheckAlways | LViewFlags.Dirty)) {\n    parentFirstTemplatePass && syncViewWithBlueprint(hostView);\n    detectChangesInternal(hostView, hostView[CONTEXT]);\n  }\n}\n\n/**\n * Syncs an LViewData instance with its blueprint if they have gotten out of sync.\n *\n * Typically, blueprints and their view instances should always be in sync, so the loop here\n * will be skipped. However, consider this case of two components side-by-side:\n *\n * App template:\n * ```\n * <comp></comp>\n * <comp></comp>\n * ```\n *\n * The following will happen:\n * 1. App template begins processing.\n * 2. First <comp> is matched as a component and its LViewData is created.\n * 3. Second <comp> is matched as a component and its LViewData is created.\n * 4. App template completes processing, so it's time to check child templates.\n * 5. First <comp> template is checked. It has a directive, so its def is pushed to blueprint.\n * 6. Second <comp> template is checked. Its blueprint has been updated by the first\n * <comp> template, but its LViewData was created before this update, so it is out of sync.\n *\n * Note that embedded views inside ngFor loops will never be out of sync because these views\n * are processed as soon as they are created.\n *\n * @param componentView The view to sync\n */\nfunction syncViewWithBlueprint(componentView: LViewData) {\n  const componentTView = componentView[TVIEW];\n  for (let i = componentView.length; i < componentTView.blueprint.length; i++) {\n    componentView[i] = componentTView.blueprint[i];\n  }\n}\n\n/** Returns a boolean for whether the view is attached */\nexport function viewAttached(view: LViewData): boolean {\n  return (view[FLAGS] & LViewFlags.Attached) === LViewFlags.Attached;\n}\n\n/**\n * Instruction to distribute projectable nodes among <ng-content> occurrences in a given template.\n * It takes all the selectors from the entire component's template and decides where\n * each projected node belongs (it re-distributes nodes among \"buckets\" where each \"bucket\" is\n * backed by a selector).\n *\n * This function requires CSS selectors to be provided in 2 forms: parsed (by a compiler) and text,\n * un-parsed form.\n *\n * The parsed form is needed for efficient matching of a node against a given CSS selector.\n * The un-parsed, textual form is needed for support of the ngProjectAs attribute.\n *\n * Having a CSS selector in 2 different formats is not ideal, but alternatives have even more\n * drawbacks:\n * - having only a textual form would require runtime parsing of CSS selectors;\n * - we can't have only a parsed as we can't re-construct textual form from it (as entered by a\n * template author).\n *\n * @param selectors A collection of parsed CSS selectors\n * @param rawSelectors A collection of CSS selectors in the raw, un-parsed form\n */\nexport function projectionDef(selectors?: CssSelectorList[], textSelectors?: string[]): void {\n  const componentNode = findComponentView(viewData)[HOST_NODE] as TElementNode;\n\n  if (!componentNode.projection) {\n    const noOfNodeBuckets = selectors ? selectors.length + 1 : 1;\n    const pData: (TNode | null)[] = componentNode.projection =\n        new Array(noOfNodeBuckets).fill(null);\n    const tails: (TNode | null)[] = pData.slice();\n\n    let componentChild: TNode|null = componentNode.child;\n\n    while (componentChild !== null) {\n      const bucketIndex =\n          selectors ? matchingSelectorIndex(componentChild, selectors, textSelectors !) : 0;\n      const nextNode = componentChild.next;\n\n      if (tails[bucketIndex]) {\n        tails[bucketIndex] !.next = componentChild;\n      } else {\n        pData[bucketIndex] = componentChild;\n        componentChild.next = null;\n      }\n      tails[bucketIndex] = componentChild;\n\n      componentChild = nextNode;\n    }\n  }\n}\n\n/**\n * Stack used to keep track of projection nodes in projection() instruction.\n *\n * This is deliberately created outside of projection() to avoid allocating\n * a new array each time the function is called. Instead the array will be\n * re-used by each invocation. This works because the function is not reentrant.\n */\nconst projectionNodeStack: (LViewData | TNode)[] = [];\n\n/**\n * Inserts previously re-distributed projected nodes. This instruction must be preceded by a call\n * to the projectionDef instruction.\n *\n * @param nodeIndex\n * @param selectorIndex:\n *        - 0 when the selector is `*` (or unspecified as this is the default value),\n *        - 1 based index of the selector from the {@link projectionDef}\n */\nexport function projection(nodeIndex: number, selectorIndex: number = 0, attrs?: string[]): void {\n  const tProjectionNode =\n      createNodeAtIndex(nodeIndex, TNodeType.Projection, null, null, attrs || null);\n\n  // We can't use viewData[HOST_NODE] because projection nodes can be nested in embedded views.\n  if (tProjectionNode.projection === null) tProjectionNode.projection = selectorIndex;\n\n  // `<ng-content>` has no content\n  isParent = false;\n\n  // re-distribution of projectable nodes is stored on a component's view level\n  const componentView = findComponentView(viewData);\n  const componentNode = componentView[HOST_NODE] as TElementNode;\n  let nodeToProject = (componentNode.projection as(TNode | null)[])[selectorIndex];\n  let projectedView = componentView[PARENT] !;\n  let projectionNodeIndex = -1;\n\n  while (nodeToProject) {\n    if (nodeToProject.type === TNodeType.Projection) {\n      // This node is re-projected, so we must go up the tree to get its projected nodes.\n      const currentComponentView = findComponentView(projectedView);\n      const currentComponentHost = currentComponentView[HOST_NODE] as TElementNode;\n      const firstProjectedNode =\n          (currentComponentHost.projection as(TNode | null)[])[nodeToProject.projection as number];\n\n      if (firstProjectedNode) {\n        projectionNodeStack[++projectionNodeIndex] = nodeToProject;\n        projectionNodeStack[++projectionNodeIndex] = projectedView;\n\n        nodeToProject = firstProjectedNode;\n        projectedView = currentComponentView[PARENT] !;\n        continue;\n      }\n    } else {\n      // This flag must be set now or we won't know that this node is projected\n      // if the nodes are inserted into a container later.\n      nodeToProject.flags |= TNodeFlags.isProjected;\n      appendProjectedNode(nodeToProject, tProjectionNode, viewData, projectedView);\n    }\n\n    // If we are finished with a list of re-projected nodes, we need to get\n    // back to the root projection node that was re-projected.\n    if (nodeToProject.next === null && projectedView !== componentView[PARENT] !) {\n      projectedView = projectionNodeStack[projectionNodeIndex--] as LViewData;\n      nodeToProject = projectionNodeStack[projectionNodeIndex--] as TNode;\n    }\n    nodeToProject = nodeToProject.next;\n  }\n}\n\n/**\n * Adds LViewData or LContainer to the end of the current view tree.\n *\n * This structure will be used to traverse through nested views to remove listeners\n * and call onDestroy callbacks.\n *\n * @param currentView The view where LViewData or LContainer should be added\n * @param adjustedHostIndex Index of the view's host node in LViewData[], adjusted for header\n * @param state The LViewData or LContainer to add to the view tree\n * @returns The state passed in\n */\nexport function addToViewTree<T extends LViewData|LContainer>(\n    currentView: LViewData, adjustedHostIndex: number, state: T): T {\n  if (currentView[TAIL]) {\n    currentView[TAIL] ![NEXT] = state;\n  } else if (firstTemplatePass) {\n    tView.childIndex = adjustedHostIndex;\n  }\n  currentView[TAIL] = state;\n  return state;\n}\n\n///////////////////////////////\n//// Change detection\n///////////////////////////////\n\n/** If node is an OnPush component, marks its LViewData dirty. */\nexport function markDirtyIfOnPush(viewIndex: number): void {\n  const view = getComponentViewByIndex(viewIndex, viewData);\n  if (!(view[FLAGS] & LViewFlags.CheckAlways)) {\n    view[FLAGS] |= LViewFlags.Dirty;\n  }\n}\n\n/** Wraps an event listener with preventDefault behavior. */\nexport function wrapListenerWithPreventDefault(listenerFn: (e?: any) => any): EventListener {\n  return function wrapListenerIn_preventDefault(e: Event) {\n    if (listenerFn(e) === false) {\n      e.preventDefault();\n      // Necessary for legacy browsers that don't support preventDefault (e.g. IE)\n      e.returnValue = false;\n    }\n  };\n}\n\n/** Marks current view and all ancestors dirty */\nexport function markViewDirty(view: LViewData): void {\n  let currentView: LViewData = view;\n\n  while (currentView && !(currentView[FLAGS] & LViewFlags.IsRoot)) {\n    currentView[FLAGS] |= LViewFlags.Dirty;\n    currentView = currentView[PARENT] !;\n  }\n  currentView[FLAGS] |= LViewFlags.Dirty;\n  ngDevMode && assertDefined(currentView[CONTEXT], 'rootContext should be defined');\n\n  const rootContext = currentView[CONTEXT] as RootContext;\n  const nothingScheduled = rootContext.flags === RootContextFlags.Empty;\n  rootContext.flags |= RootContextFlags.DetectChanges;\n  if (nothingScheduled) {\n    scheduleTick(rootContext);\n  }\n}\n\n/**\n * Used to schedule change detection on the whole application.\n *\n * Unlike `tick`, `scheduleTick` coalesces multiple calls into one change detection run.\n * It is usually called indirectly by calling `markDirty` when the view needs to be\n * re-rendered.\n *\n * Typically `scheduleTick` uses `requestAnimationFrame` to coalesce multiple\n * `scheduleTick` requests. The scheduling function can be overridden in\n * `renderComponent`'s `scheduler` option.\n */\nexport function scheduleTick<T>(rootContext: RootContext) {\n  if (rootContext.clean == _CLEAN_PROMISE) {\n    let res: null|((val: null) => void);\n    rootContext.clean = new Promise<null>((r) => res = r);\n    rootContext.scheduler(() => {\n      if (rootContext.flags & RootContextFlags.DetectChanges) {\n        rootContext.flags &= ~RootContextFlags.DetectChanges;\n        tickRootContext(rootContext);\n      }\n\n      if (rootContext.flags & RootContextFlags.FlushPlayers) {\n        rootContext.flags &= ~RootContextFlags.FlushPlayers;\n        const playerHandler = rootContext.playerHandler;\n        if (playerHandler) {\n          playerHandler.flushPlayers();\n        }\n      }\n\n      rootContext.clean = _CLEAN_PROMISE;\n      res !(null);\n    });\n  }\n}\n\n/**\n * Used to perform change detection on the whole application.\n *\n * This is equivalent to `detectChanges`, but invoked on root component. Additionally, `tick`\n * executes lifecycle hooks and conditionally checks components based on their\n * `ChangeDetectionStrategy` and dirtiness.\n *\n * The preferred way to trigger change detection is to call `markDirty`. `markDirty` internally\n * schedules `tick` using a scheduler in order to coalesce multiple `markDirty` calls into a\n * single change detection run. By default, the scheduler is `requestAnimationFrame`, but can\n * be changed when calling `renderComponent` and providing the `scheduler` option.\n */\nexport function tick<T>(component: T): void {\n  const rootView = getRootView(component);\n  const rootContext = rootView[CONTEXT] as RootContext;\n  tickRootContext(rootContext);\n}\n\nfunction tickRootContext(rootContext: RootContext) {\n  for (let i = 0; i < rootContext.components.length; i++) {\n    const rootComponent = rootContext.components[i];\n    renderComponentOrTemplate(readPatchedLViewData(rootComponent) !, rootComponent);\n  }\n}\n\n/**\n * Synchronously perform change detection on a component (and possibly its sub-components).\n *\n * This function triggers change detection in a synchronous way on a component. There should\n * be very little reason to call this function directly since a preferred way to do change\n * detection is to {@link markDirty} the component and wait for the scheduler to call this method\n * at some future point in time. This is because a single user action often results in many\n * components being invalidated and calling change detection on each component synchronously\n * would be inefficient. It is better to wait until all components are marked as dirty and\n * then perform single change detection across all of the components\n *\n * @param component The component which the change detection should be performed on.\n */\nexport function detectChanges<T>(component: T): void {\n  detectChangesInternal(getComponentViewByInstance(component) !, component);\n}\n\n/**\n * Synchronously perform change detection on a root view and its components.\n *\n * @param lViewData The view which the change detection should be performed on.\n */\nexport function detectChangesInRootView(lViewData: LViewData): void {\n  tickRootContext(lViewData[CONTEXT] as RootContext);\n}\n\n\n/**\n * Checks the change detector and its children, and throws if any changes are detected.\n *\n * This is used in development mode to verify that running change detection doesn't\n * introduce other changes.\n */\nexport function checkNoChanges<T>(component: T): void {\n  checkNoChangesMode = true;\n  try {\n    detectChanges(component);\n  } finally {\n    checkNoChangesMode = false;\n  }\n}\n\n/**\n * Checks the change detector on a root view and its components, and throws if any changes are\n * detected.\n *\n * This is used in development mode to verify that running change detection doesn't\n * introduce other changes.\n *\n * @param lViewData The view which the change detection should be checked on.\n */\nexport function checkNoChangesInRootView(lViewData: LViewData): void {\n  checkNoChangesMode = true;\n  try {\n    detectChangesInRootView(lViewData);\n  } finally {\n    checkNoChangesMode = false;\n  }\n}\n\n/** Checks the view of the component provided. Does not gate on dirty checks or execute doCheck. */\nexport function detectChangesInternal<T>(hostView: LViewData, component: T) {\n  const hostTView = hostView[TVIEW];\n  const oldView = enterView(hostView, hostView[HOST_NODE]);\n  const templateFn = hostTView.template !;\n  const viewQuery = hostTView.viewQuery;\n\n  try {\n    namespaceHTML();\n    createViewQuery(viewQuery, hostView[FLAGS], component);\n    templateFn(getRenderFlags(hostView), component);\n    refreshDescendantViews();\n    updateViewQuery(viewQuery, component);\n  } finally {\n    leaveView(oldView);\n  }\n}\n\nfunction createViewQuery<T>(\n    viewQuery: ComponentQuery<{}>| null, flags: LViewFlags, component: T): void {\n  if (viewQuery && (flags & LViewFlags.CreationMode)) {\n    viewQuery(RenderFlags.Create, component);\n  }\n}\n\nfunction updateViewQuery<T>(viewQuery: ComponentQuery<{}>| null, component: T): void {\n  if (viewQuery) {\n    viewQuery(RenderFlags.Update, component);\n  }\n}\n\n\n/**\n * Mark the component as dirty (needing change detection).\n *\n * Marking a component dirty will schedule a change detection on this\n * component at some point in the future. Marking an already dirty\n * component as dirty is a noop. Only one outstanding change detection\n * can be scheduled per component tree. (Two components bootstrapped with\n * separate `renderComponent` will have separate schedulers)\n *\n * When the root component is bootstrapped with `renderComponent`, a scheduler\n * can be provided.\n *\n * @param component Component to mark as dirty.\n */\nexport function markDirty<T>(component: T) {\n  ngDevMode && assertDefined(component, 'component');\n  markViewDirty(getComponentViewByInstance(component));\n}\n\n///////////////////////////////\n//// Bindings & interpolations\n///////////////////////////////\n\nexport interface NO_CHANGE {\n  // This is a brand that ensures that this type can never match anything else\n  brand: 'NO_CHANGE';\n}\n\n/** A special value which designates that a value has not changed. */\nexport const NO_CHANGE = {} as NO_CHANGE;\n\n/**\n * Creates a single value binding.\n *\n * @param value Value to diff\n */\nexport function bind<T>(value: T): T|NO_CHANGE {\n  return bindingUpdated(viewData[BINDING_INDEX]++, value) ? value : NO_CHANGE;\n}\n\n/**\n * Create interpolation bindings with a variable number of expressions.\n *\n * If there are 1 to 8 expressions `interpolation1()` to `interpolation8()` should be used instead.\n * Those are faster because there is no need to create an array of expressions and iterate over it.\n *\n * `values`:\n * - has static text at even indexes,\n * - has evaluated expressions at odd indexes.\n *\n * Returns the concatenated string when any of the arguments changes, `NO_CHANGE` otherwise.\n */\nexport function interpolationV(values: any[]): string|NO_CHANGE {\n  ngDevMode && assertLessThan(2, values.length, 'should have at least 3 values');\n  ngDevMode && assertEqual(values.length % 2, 1, 'should have an odd number of values');\n  let different = false;\n\n  for (let i = 1; i < values.length; i += 2) {\n    // Check if bindings (odd indexes) have changed\n    bindingUpdated(viewData[BINDING_INDEX]++, values[i]) && (different = true);\n  }\n\n  if (!different) {\n    return NO_CHANGE;\n  }\n\n  // Build the updated content\n  let content = values[0];\n  for (let i = 1; i < values.length; i += 2) {\n    content += stringify(values[i]) + values[i + 1];\n  }\n\n  return content;\n}\n\n/**\n * Creates an interpolation binding with 1 expression.\n *\n * @param prefix static value used for concatenation only.\n * @param v0 value checked for change.\n * @param suffix static value used for concatenation only.\n */\nexport function interpolation1(prefix: string, v0: any, suffix: string): string|NO_CHANGE {\n  const different = bindingUpdated(viewData[BINDING_INDEX]++, v0);\n  return different ? prefix + stringify(v0) + suffix : NO_CHANGE;\n}\n\n/** Creates an interpolation binding with 2 expressions. */\nexport function interpolation2(\n    prefix: string, v0: any, i0: string, v1: any, suffix: string): string|NO_CHANGE {\n  const different = bindingUpdated2(viewData[BINDING_INDEX], v0, v1);\n  viewData[BINDING_INDEX] += 2;\n\n  return different ? prefix + stringify(v0) + i0 + stringify(v1) + suffix : NO_CHANGE;\n}\n\n/** Creates an interpolation binding with 3 expressions. */\nexport function interpolation3(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, suffix: string): string|\n    NO_CHANGE {\n  const different = bindingUpdated3(viewData[BINDING_INDEX], v0, v1, v2);\n  viewData[BINDING_INDEX] += 3;\n\n  return different ? prefix + stringify(v0) + i0 + stringify(v1) + i1 + stringify(v2) + suffix :\n                     NO_CHANGE;\n}\n\n/** Create an interpolation binding with 4 expressions. */\nexport function interpolation4(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    suffix: string): string|NO_CHANGE {\n  const different = bindingUpdated4(viewData[BINDING_INDEX], v0, v1, v2, v3);\n  viewData[BINDING_INDEX] += 4;\n\n  return different ?\n      prefix + stringify(v0) + i0 + stringify(v1) + i1 + stringify(v2) + i2 + stringify(v3) +\n          suffix :\n      NO_CHANGE;\n}\n\n/** Creates an interpolation binding with 5 expressions. */\nexport function interpolation5(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    i3: string, v4: any, suffix: string): string|NO_CHANGE {\n  let different = bindingUpdated4(viewData[BINDING_INDEX], v0, v1, v2, v3);\n  different = bindingUpdated(viewData[BINDING_INDEX] + 4, v4) || different;\n  viewData[BINDING_INDEX] += 5;\n\n  return different ?\n      prefix + stringify(v0) + i0 + stringify(v1) + i1 + stringify(v2) + i2 + stringify(v3) + i3 +\n          stringify(v4) + suffix :\n      NO_CHANGE;\n}\n\n/** Creates an interpolation binding with 6 expressions. */\nexport function interpolation6(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    i3: string, v4: any, i4: string, v5: any, suffix: string): string|NO_CHANGE {\n  let different = bindingUpdated4(viewData[BINDING_INDEX], v0, v1, v2, v3);\n  different = bindingUpdated2(viewData[BINDING_INDEX] + 4, v4, v5) || different;\n  viewData[BINDING_INDEX] += 6;\n\n  return different ?\n      prefix + stringify(v0) + i0 + stringify(v1) + i1 + stringify(v2) + i2 + stringify(v3) + i3 +\n          stringify(v4) + i4 + stringify(v5) + suffix :\n      NO_CHANGE;\n}\n\n/** Creates an interpolation binding with 7 expressions. */\nexport function interpolation7(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    i3: string, v4: any, i4: string, v5: any, i5: string, v6: any, suffix: string): string|\n    NO_CHANGE {\n  let different = bindingUpdated4(viewData[BINDING_INDEX], v0, v1, v2, v3);\n  different = bindingUpdated3(viewData[BINDING_INDEX] + 4, v4, v5, v6) || different;\n  viewData[BINDING_INDEX] += 7;\n\n  return different ?\n      prefix + stringify(v0) + i0 + stringify(v1) + i1 + stringify(v2) + i2 + stringify(v3) + i3 +\n          stringify(v4) + i4 + stringify(v5) + i5 + stringify(v6) + suffix :\n      NO_CHANGE;\n}\n\n/** Creates an interpolation binding with 8 expressions. */\nexport function interpolation8(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    i3: string, v4: any, i4: string, v5: any, i5: string, v6: any, i6: string, v7: any,\n    suffix: string): string|NO_CHANGE {\n  let different = bindingUpdated4(viewData[BINDING_INDEX], v0, v1, v2, v3);\n  different = bindingUpdated4(viewData[BINDING_INDEX] + 4, v4, v5, v6, v7) || different;\n  viewData[BINDING_INDEX] += 8;\n\n  return different ?\n      prefix + stringify(v0) + i0 + stringify(v1) + i1 + stringify(v2) + i2 + stringify(v3) + i3 +\n          stringify(v4) + i4 + stringify(v5) + i5 + stringify(v6) + i6 + stringify(v7) + suffix :\n      NO_CHANGE;\n}\n\n/** Store a value in the `data` at a given `index`. */\nexport function store<T>(index: number, value: T): void {\n  // We don't store any static data for local variables, so the first time\n  // we see the template, we should store as null to avoid a sparse array\n  const adjustedIndex = index + HEADER_OFFSET;\n  if (adjustedIndex >= tView.data.length) {\n    tView.data[adjustedIndex] = null;\n  }\n  viewData[adjustedIndex] = value;\n}\n\n/**\n * Retrieves a local reference from the current contextViewData.\n *\n * If the reference to retrieve is in a parent view, this instruction is used in conjunction\n * with a nextContext() call, which walks up the tree and updates the contextViewData instance.\n *\n * @param index The index of the local ref in contextViewData.\n */\nexport function reference<T>(index: number) {\n  return loadInternal<T>(index, contextViewData);\n}\n\nfunction walkUpViews(nestingLevel: number, currentView: LViewData): LViewData {\n  while (nestingLevel > 0) {\n    ngDevMode && assertDefined(\n                     currentView[DECLARATION_VIEW],\n                     'Declaration view should be defined if nesting level is greater than 0.');\n    currentView = currentView[DECLARATION_VIEW] !;\n    nestingLevel--;\n  }\n  return currentView;\n}\n\nexport function loadQueryList<T>(queryListIdx: number): QueryList<T> {\n  ngDevMode && assertDefined(\n                   viewData[CONTENT_QUERIES],\n                   'Content QueryList array should be defined if reading a query.');\n  ngDevMode && assertDataInRange(queryListIdx, viewData[CONTENT_QUERIES] !);\n\n  return viewData[CONTENT_QUERIES] ![queryListIdx];\n}\n\n/** Retrieves a value from current `viewData`. */\nexport function load<T>(index: number): T {\n  return loadInternal<T>(index, viewData);\n}\n\n/** Gets the current binding value. */\nexport function getBinding(bindingIndex: number): any {\n  ngDevMode && assertDataInRange(viewData[bindingIndex]);\n  ngDevMode &&\n      assertNotEqual(viewData[bindingIndex], NO_CHANGE, 'Stored value should never be NO_CHANGE.');\n  return viewData[bindingIndex];\n}\n\n/** Updates binding if changed, then returns whether it was updated. */\nexport function bindingUpdated(bindingIndex: number, value: any): boolean {\n  ngDevMode && assertNotEqual(value, NO_CHANGE, 'Incoming value should never be NO_CHANGE.');\n  ngDevMode && assertLessThan(\n                   bindingIndex, viewData.length, `Slot should have been initialized to NO_CHANGE`);\n\n  if (viewData[bindingIndex] === NO_CHANGE) {\n    viewData[bindingIndex] = value;\n  } else if (isDifferent(viewData[bindingIndex], value, checkNoChangesMode)) {\n    throwErrorIfNoChangesMode(creationMode, checkNoChangesMode, viewData[bindingIndex], value);\n    viewData[bindingIndex] = value;\n  } else {\n    return false;\n  }\n  return true;\n}\n\n/** Updates binding and returns the value. */\nexport function updateBinding(bindingIndex: number, value: any): any {\n  return viewData[bindingIndex] = value;\n}\n\n/** Updates 2 bindings if changed, then returns whether either was updated. */\nexport function bindingUpdated2(bindingIndex: number, exp1: any, exp2: any): boolean {\n  const different = bindingUpdated(bindingIndex, exp1);\n  return bindingUpdated(bindingIndex + 1, exp2) || different;\n}\n\n/** Updates 3 bindings if changed, then returns whether any was updated. */\nexport function bindingUpdated3(bindingIndex: number, exp1: any, exp2: any, exp3: any): boolean {\n  const different = bindingUpdated2(bindingIndex, exp1, exp2);\n  return bindingUpdated(bindingIndex + 2, exp3) || different;\n}\n\n/** Updates 4 bindings if changed, then returns whether any was updated. */\nexport function bindingUpdated4(\n    bindingIndex: number, exp1: any, exp2: any, exp3: any, exp4: any): boolean {\n  const different = bindingUpdated2(bindingIndex, exp1, exp2);\n  return bindingUpdated2(bindingIndex + 2, exp3, exp4) || different;\n}\n\nexport function getTView(): TView {\n  return tView;\n}\n\n/**\n * Registers a QueryList, associated with a content query, for later refresh (part of a view\n * refresh).\n */\nexport function registerContentQuery<Q>(queryList: QueryList<Q>): void {\n  const savedContentQueriesLength =\n      (viewData[CONTENT_QUERIES] || (viewData[CONTENT_QUERIES] = [])).push(queryList);\n  if (firstTemplatePass) {\n    const currentDirectiveIndex = viewData.length - 1;\n    const tViewContentQueries = tView.contentQueries || (tView.contentQueries = []);\n    const lastSavedDirectiveIndex =\n        tView.contentQueries.length ? tView.contentQueries[tView.contentQueries.length - 2] : -1;\n    if (currentDirectiveIndex !== lastSavedDirectiveIndex) {\n      tViewContentQueries.push(currentDirectiveIndex, savedContentQueriesLength - 1);\n    }\n  }\n}\n\nexport function assertPreviousIsParent() {\n  assertEqual(isParent, true, 'previousOrParentTNode should be a parent');\n}\n\nfunction assertHasParent() {\n  assertDefined(previousOrParentTNode.parent, 'previousOrParentTNode should have a parent');\n}\n\nfunction assertDataInRange(index: number, arr?: any[]) {\n  if (arr == null) arr = viewData;\n  assertDataInRangeInternal(index, arr || viewData);\n}\n\nfunction assertDataNext(index: number, arr?: any[]) {\n  if (arr == null) arr = viewData;\n  assertEqual(\n      arr.length, index, `index ${index} expected to be at the end of arr (length ${arr.length})`);\n}\n\nexport const CLEAN_PROMISE = _CLEAN_PROMISE;\n"]}