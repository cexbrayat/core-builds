{"version":3,"file":"instructions.js","sourceRoot":"","sources":["../../../../../../packages/core/src/render3/instructions.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport './ng_dev_mode';\n\nimport {QueryList} from '../linker';\nimport {Sanitizer} from '../sanitization/security';\nimport {StyleSanitizeFn} from '../sanitization/style_sanitizer';\n\nimport {assertDefined, assertEqual, assertLessThan, assertNotDefined, assertNotEqual} from './assert';\nimport {attachLViewDataToNode} from './element_discovery';\nimport {throwCyclicDependencyError, throwErrorIfNoChangesMode, throwMultipleComponentError} from './errors';\nimport {executeHooks, executeInitHooks, queueInitHooks, queueLifecycleHooks} from './hooks';\nimport {ACTIVE_INDEX, LContainer, RENDER_PARENT, VIEWS} from './interfaces/container';\nimport {ComponentDefInternal, ComponentQuery, ComponentTemplate, DirectiveDefInternal, DirectiveDefListOrFactory, InitialStylingFlags, PipeDefListOrFactory, RenderFlags} from './interfaces/definition';\nimport {LInjector} from './interfaces/injector';\nimport {AttributeMarker, InitialInputData, InitialInputs, LContainerNode, LElementContainerNode, LElementNode, LNode, LNodeWithLocalRefs, LProjectionNode, LTextNode, LViewNode, LocalRefExtractor, PropertyAliasValue, PropertyAliases, TAttributes, TContainerNode, TElementNode, TNode, TNodeFlags, TNodeType} from './interfaces/node';\nimport {CssSelectorList, NG_PROJECT_AS_ATTR_NAME} from './interfaces/projection';\nimport {LQueries} from './interfaces/query';\nimport {ProceduralRenderer3, RComment, RElement, RNode, RText, Renderer3, RendererFactory3, RendererStyleFlags3, isProceduralRenderer} from './interfaces/renderer';\nimport {BINDING_INDEX, CLEANUP, CONTAINER_INDEX, CONTENT_QUERIES, CONTEXT, CurrentMatchesList, DECLARATION_VIEW, DIRECTIVES, FLAGS, HEADER_OFFSET, HOST_NODE, INJECTOR, LViewData, LViewFlags, NEXT, OpaqueViewState, PARENT, QUERIES, RENDERER, RootContext, SANITIZER, TAIL, TData, TVIEW, TView} from './interfaces/view';\nimport {assertNodeOfPossibleTypes, assertNodeType} from './node_assert';\nimport {appendChild, appendProjectedNode, canInsertNativeNode, createTextNode, findComponentHost, getChildLNode, getLViewChild, getNextLNode, getParentLNode, insertView, removeView} from './node_manipulation';\nimport {isNodeMatchingSelectorList, matchingSelectorIndex} from './node_selector_matcher';\nimport {StylingContext, allocStylingContext, createStylingContextTemplate, renderStyling as renderElementStyles, updateClassProp as updateElementClassProp, updateStyleProp as updateElementStyleProp, updateStylingMap} from './styling';\nimport {assertDataInRangeInternal, isDifferent, loadElementInternal, loadInternal, stringify} from './util';\nimport {ViewRef} from './view_ref';\n\n/**\n * Directive (D) sets a property on all component instances using this constant as a key and the\n * component's host node (LElement) as the value. This is used in methods like detectChanges to\n * facilitate jumping from an instance to the host node.\n */\nexport const NG_HOST_SYMBOL = '__ngHostLNode__';\n\n/**\n * A permanent marker promise which signifies that the current CD tree is\n * clean.\n */\nconst _CLEAN_PROMISE = Promise.resolve(null);\n\n/**\n * Function used to sanitize the value before writing it into the renderer.\n */\nexport type SanitizerFn = (value: any) => string;\n\n/**\n * TView.data needs to fill the same number of slots as the LViewData header\n * so the indices of nodes are consistent between LViewData and TView.data.\n *\n * It's much faster to keep a blueprint of the pre-filled array and slice it\n * than it is to create a new array and fill it each time a TView is created.\n */\nconst HEADER_FILLER = new Array(HEADER_OFFSET).fill(null);\n\n/**\n * Token set in currentMatches while dependencies are being resolved.\n *\n * If we visit a directive that has a value set to CIRCULAR, we know we've\n * already seen it, and thus have a circular dependency.\n */\nexport const CIRCULAR = '__CIRCULAR__';\n\n/**\n * This property gets set before entering a template.\n *\n * This renderer can be one of two varieties of Renderer3:\n *\n * - ObjectedOrientedRenderer3\n *\n * This is the native browser API style, e.g. operations are methods on individual objects\n * like HTMLElement. With this style, no additional code is needed as a facade (reducing payload\n * size).\n *\n * - ProceduralRenderer3\n *\n * In non-native browser environments (e.g. platforms such as web-workers), this is the facade\n * that enables element manipulation. This also facilitates backwards compatibility with\n * Renderer2.\n */\nlet renderer: Renderer3;\n\nexport function getRenderer(): Renderer3 {\n  // top level variables should not be exported for performance reasons (PERF_NOTES.md)\n  return renderer;\n}\n\nlet rendererFactory: RendererFactory3;\n\nexport function getRendererFactory(): RendererFactory3 {\n  // top level variables should not be exported for performance reasons (PERF_NOTES.md)\n  return rendererFactory;\n}\n\nexport function getCurrentSanitizer(): Sanitizer|null {\n  return viewData && viewData[SANITIZER];\n}\n\n/**\n * Store the element depth count. This is used to identify the root elements of the template\n * so that we can than attach `LViewData` to only those elements.\n */\nlet elementDepthCount !: number;\n\n/**\n * Returns the current OpaqueViewState instance.\n *\n * Used in conjunction with the restoreView() instruction to save a snapshot\n * of the current view and restore it when listeners are invoked. This allows\n * walking the declaration view tree in listeners to get vars from parent views.\n */\nexport function getCurrentView(): OpaqueViewState {\n  return viewData as any as OpaqueViewState;\n}\n\n/**\n * Restores `contextViewData` to the given OpaqueViewState instance.\n *\n * Used in conjunction with the getCurrentView() instruction to save a snapshot\n * of the current view and restore it when listeners are invoked. This allows\n * walking the declaration view tree in listeners to get vars from parent views.\n *\n * @param viewToRestore The OpaqueViewState instance to restore.\n */\nexport function restoreView(viewToRestore: OpaqueViewState) {\n  contextViewData = viewToRestore as any as LViewData;\n}\n\n/** Used to set the parent property when nodes are created. */\nlet previousOrParentNode: LNode;\n\nexport function getPreviousOrParentNode(): LNode {\n  // top level variables should not be exported for performance reasons (PERF_NOTES.md)\n  return previousOrParentNode;\n}\n\n/**\n * If `isParent` is:\n *  - `true`: then `previousOrParentNode` points to a parent node.\n *  - `false`: then `previousOrParentNode` points to previous node (sibling).\n */\nlet isParent: boolean;\n\nlet tView: TView;\n\nlet currentQueries: LQueries|null;\n\n/**\n * Query instructions can ask for \"current queries\" in 2 different cases:\n * - when creating view queries (at the root of a component view, before any node is created - in\n * this case currentQueries points to view queries)\n * - when creating content queries (inb this previousOrParentNode points to a node on which we\n * create content queries).\n */\nexport function getOrCreateCurrentQueries(\n    QueryType: {new (parent: null, shallow: null, deep: null): LQueries}): LQueries {\n  const tNode = previousOrParentNode.tNode;\n\n  // if this is the first content query on a node, any existing LQueries needs to be cloned\n  // in subsequent template passes, the cloning occurs before directive instantiation.\n  if (previousOrParentNode.data !== viewData && !isContentQueryHost(tNode)) {\n    currentQueries && (currentQueries = currentQueries.clone());\n    tNode.flags |= TNodeFlags.hasContentQuery;\n  }\n\n  return currentQueries || (currentQueries = new QueryType(null, null, null));\n}\n\n/**\n * This property gets set before entering a template.\n */\nlet creationMode: boolean;\n\nexport function getCreationMode(): boolean {\n  // top level variables should not be exported for performance reasons (PERF_NOTES.md)\n  return creationMode;\n}\n\n/**\n * State of the current view being processed.\n *\n * An array of nodes (text, element, container, etc), pipes, their bindings, and\n * any local variables that need to be stored between invocations.\n */\nlet viewData: LViewData;\n\n/**\n * Internal function that returns the current LViewData instance.\n *\n * The getCurrentView() instruction should be used for anything public.\n */\nexport function _getViewData(): LViewData {\n  // top level variables should not be exported for performance reasons (PERF_NOTES.md)\n  return viewData;\n}\n\n/**\n * The last viewData retrieved by nextContext().\n * Allows building nextContext() and reference() calls.\n *\n * e.g. const inner = x().$implicit; const outer = x().$implicit;\n */\nlet contextViewData: LViewData = null !;\n\n/**\n * An array of directive instances in the current view.\n *\n * These must be stored separately from LNodes because their presence is\n * unknown at compile-time and thus space cannot be reserved in data[].\n */\nlet directives: any[]|null;\n\nfunction getCleanup(view: LViewData): any[] {\n  // top level variables should not be exported for performance reasons (PERF_NOTES.md)\n  return view[CLEANUP] || (view[CLEANUP] = []);\n}\n\nfunction getTViewCleanup(view: LViewData): any[] {\n  return view[TVIEW].cleanup || (view[TVIEW].cleanup = []);\n}\n/**\n * In this mode, any changes in bindings will throw an ExpressionChangedAfterChecked error.\n *\n * Necessary to support ChangeDetectorRef.checkNoChanges().\n */\nlet checkNoChangesMode = false;\n\n/** Whether or not this is the first time the current view has been processed. */\nlet firstTemplatePass = true;\n\n/**\n * The root index from which pure function instructions should calculate their binding\n * indices. In component views, this is TView.bindingStartIndex. In a host binding\n * context, this is the TView.hostBindingStartIndex + any hostVars before the given dir.\n */\nlet bindingRootIndex: number = -1;\n\n// top level variables should not be exported for performance reasons (PERF_NOTES.md)\nexport function getBindingRoot() {\n  return bindingRootIndex;\n}\n\nconst enum BindingDirection {\n  Input,\n  Output,\n}\n\n/**\n * Swap the current state with a new state.\n *\n * For performance reasons we store the state in the top level of the module.\n * This way we minimize the number of properties to read. Whenever a new view\n * is entered we have to store the state for later, and when the view is\n * exited the state has to be restored\n *\n * @param newView New state to become active\n * @param host Element to which the View is a child of\n * @returns the previous state;\n */\nexport function enterView(newView: LViewData, host: LElementNode | LViewNode | null): LViewData {\n  const oldView: LViewData = viewData;\n  directives = newView && newView[DIRECTIVES];\n  tView = newView && newView[TVIEW];\n\n  creationMode = newView && (newView[FLAGS] & LViewFlags.CreationMode) === LViewFlags.CreationMode;\n  firstTemplatePass = newView && tView.firstTemplatePass;\n  bindingRootIndex = newView && tView.bindingStartIndex;\n  renderer = newView && newView[RENDERER];\n\n  if (host != null) {\n    previousOrParentNode = host;\n    isParent = true;\n  }\n\n  viewData = contextViewData = newView;\n  oldView && (oldView[QUERIES] = currentQueries);\n  currentQueries = newView && newView[QUERIES];\n\n  return oldView;\n}\n\n/**\n * Used in lieu of enterView to make it clear when we are exiting a child view. This makes\n * the direction of traversal (up or down the view tree) a bit clearer.\n *\n * @param newView New state to become active\n * @param creationOnly An optional boolean to indicate that the view was processed in creation mode\n * only, i.e. the first update will be done later. Only possible for dynamically created views.\n */\nexport function leaveView(newView: LViewData, creationOnly?: boolean): void {\n  if (!creationOnly) {\n    if (!checkNoChangesMode) {\n      executeHooks(directives !, tView.viewHooks, tView.viewCheckHooks, creationMode);\n    }\n    // Views are clean and in update mode after being checked, so these bits are cleared\n    viewData[FLAGS] &= ~(LViewFlags.CreationMode | LViewFlags.Dirty);\n  }\n  viewData[FLAGS] |= LViewFlags.RunInit;\n  viewData[BINDING_INDEX] = tView.bindingStartIndex;\n  enterView(newView, null);\n}\n\n/**\n * Refreshes the view, executing the following steps in that order:\n * triggers init hooks, refreshes dynamic embedded views, triggers content hooks, sets host\n * bindings, refreshes child components.\n * Note: view hooks are triggered later when leaving the view.\n */\nfunction refreshDescendantViews() {\n  // This needs to be set before children are processed to support recursive components\n  tView.firstTemplatePass = firstTemplatePass = false;\n\n  if (!checkNoChangesMode) {\n    executeInitHooks(viewData, tView, creationMode);\n  }\n  refreshDynamicEmbeddedViews(viewData);\n\n  // Content query results must be refreshed before content hooks are called.\n  refreshContentQueries(tView);\n\n  if (!checkNoChangesMode) {\n    executeHooks(directives !, tView.contentHooks, tView.contentCheckHooks, creationMode);\n  }\n\n  setHostBindings(tView.hostBindings);\n  refreshChildComponents(tView.components);\n}\n\n\n/** Sets the host bindings for the current view. */\nexport function setHostBindings(bindings: number[] | null): void {\n  if (bindings != null) {\n    bindingRootIndex = viewData[BINDING_INDEX] = tView.hostBindingStartIndex;\n    const defs = tView.directives !;\n    for (let i = 0; i < bindings.length; i += 2) {\n      const dirIndex = bindings[i];\n      const def = defs[dirIndex] as DirectiveDefInternal<any>;\n      def.hostBindings !(dirIndex, bindings[i + 1]);\n      bindingRootIndex = viewData[BINDING_INDEX] = bindingRootIndex + def.hostVars;\n    }\n  }\n}\n\n/** Refreshes content queries for all directives in the given view. */\nfunction refreshContentQueries(tView: TView): void {\n  if (tView.contentQueries != null) {\n    for (let i = 0; i < tView.contentQueries.length; i += 2) {\n      const directiveDefIdx = tView.contentQueries[i];\n      const directiveDef = tView.directives ![directiveDefIdx];\n\n      directiveDef.contentQueriesRefresh !(directiveDefIdx, tView.contentQueries[i + 1]);\n    }\n  }\n}\n\n/** Refreshes child components in the current view. */\nfunction refreshChildComponents(components: number[] | null): void {\n  if (components != null) {\n    for (let i = 0; i < components.length; i++) {\n      componentRefresh(components[i]);\n    }\n  }\n}\n\nexport function executeInitAndContentHooks(): void {\n  if (!checkNoChangesMode) {\n    executeInitHooks(viewData, tView, creationMode);\n    executeHooks(directives !, tView.contentHooks, tView.contentCheckHooks, creationMode);\n  }\n}\n\nexport function createLViewData<T>(\n    renderer: Renderer3, tView: TView, context: T | null, flags: LViewFlags,\n    sanitizer?: Sanitizer | null): LViewData {\n  const instance = tView.blueprint.slice() as LViewData;\n  instance[PARENT] = viewData;\n  instance[FLAGS] = flags | LViewFlags.CreationMode | LViewFlags.Attached | LViewFlags.RunInit;\n  instance[CONTEXT] = context;\n  instance[INJECTOR] = viewData ? viewData[INJECTOR] : null;\n  instance[RENDERER] = renderer;\n  instance[SANITIZER] = sanitizer || null;\n  return instance;\n}\n\n/**\n * Creation of LNode object is extracted to a separate function so we always create LNode object\n * with the same shape\n * (same properties assigned in the same order).\n */\nexport function createLNodeObject(\n    type: TNodeType, currentView: LViewData, parent: LNode | null,\n    native: RText | RElement | RComment | null,\n    state: any): LElementNode&LTextNode&LViewNode&LContainerNode&LProjectionNode {\n  return {\n    native: native as any,\n    view: currentView,\n    nodeInjector: parent ? parent.nodeInjector : null,\n    data: state,\n    tNode: null !,\n    dynamicLContainerNode: null\n  };\n}\n\n/**\n * A common way of creating the LNode to make sure that all of them have same shape to\n * keep the execution code monomorphic and fast.\n *\n * @param index The index at which the LNode should be saved (null if view, since they are not\n * saved).\n * @param type The type of LNode to create\n * @param native The native element for this LNode, if applicable\n * @param name The tag name of the associated native element, if applicable\n * @param attrs Any attrs for the native element, if applicable\n * @param data Any data that should be saved on the LNode\n */\nexport function createLNode(\n    index: number, type: TNodeType.Element, native: RElement | RText | null, name: string | null,\n    attrs: TAttributes | null, lViewData?: LViewData | null): LElementNode;\nexport function createLNode(\n    index: number, type: TNodeType.View, native: null, name: null, attrs: null,\n    lViewData: LViewData): LViewNode;\nexport function createLNode(\n    index: number, type: TNodeType.Container, native: RComment, name: string | null,\n    attrs: TAttributes | null, lContainer: LContainer): LContainerNode;\nexport function createLNode(\n    index: number, type: TNodeType.Projection, native: null, name: null, attrs: TAttributes | null,\n    lProjection: null): LProjectionNode;\nexport function createLNode(\n    index: number, type: TNodeType.ElementContainer, native: RComment, name: null,\n    attrs: TAttributes | null, data: null): LElementContainerNode;\nexport function createLNode(\n    index: number, type: TNodeType, native: RText | RElement | RComment | null, name: string | null,\n    attrs: TAttributes | null, state?: null | LViewData | LContainer): LElementNode&LTextNode&\n    LViewNode&LContainerNode&LProjectionNode {\n  const parent = isParent ? previousOrParentNode :\n                            previousOrParentNode && getParentLNode(previousOrParentNode) !as LNode;\n  // Parents cannot cross component boundaries because components will be used in multiple places,\n  // so it's only set if the view is the same.\n  const tParent =\n      parent && parent.view === viewData ? parent.tNode as TElementNode | TContainerNode : null;\n\n  const isState = state != null;\n  const node = createLNodeObject(type, viewData, parent, native, isState ? state as any : null);\n\n  if (index === -1 || type === TNodeType.View) {\n    // View nodes are not stored in data because they can be added / removed at runtime (which\n    // would cause indices to change). Their TNodes are instead stored in TView.node.\n    node.tNode = (state ? (state as LViewData)[TVIEW].node : null) ||\n        createTNode(type, index, null, null, tParent, null);\n  } else {\n    const adjustedIndex = index + HEADER_OFFSET;\n\n    // This is an element or container or projection node\n    const tData = tView.data;\n    ngDevMode && assertLessThan(\n                     adjustedIndex, viewData.length, `Slot should have been initialized with null`);\n\n    viewData[adjustedIndex] = node;\n\n    if (tData[adjustedIndex] == null) {\n      const tNode = tData[adjustedIndex] =\n          createTNode(type, adjustedIndex, name, attrs, tParent, null);\n      if (!isParent && previousOrParentNode) {\n        const previousTNode = previousOrParentNode.tNode;\n        previousTNode.next = tNode;\n        if (previousTNode.dynamicContainerNode) previousTNode.dynamicContainerNode.next = tNode;\n      }\n    }\n    node.tNode = tData[adjustedIndex] as TNode;\n\n    // Now link ourselves into the tree.\n    if (isParent) {\n      if (previousOrParentNode.tNode.child == null && previousOrParentNode.view === viewData ||\n          previousOrParentNode.tNode.type === TNodeType.View) {\n        // We are in the same view, which means we are adding content node to the parent View.\n        previousOrParentNode.tNode.child = node.tNode;\n      }\n    }\n  }\n\n  // View nodes and host elements need to set their host node (components set host nodes later)\n  if ((type & TNodeType.ViewOrElement) === TNodeType.ViewOrElement && isState) {\n    const lViewData = state as LViewData;\n    ngDevMode &&\n        assertEqual(\n            lViewData[HOST_NODE], null, 'lViewData[HOST_NODE] should not have been initialized');\n    lViewData[HOST_NODE] = node;\n    if (firstTemplatePass) lViewData[TVIEW].node = node.tNode;\n  }\n\n  previousOrParentNode = node;\n  isParent = true;\n  return node;\n}\n\n/**\n * When LNodes are created dynamically after a view blueprint is created (e.g. through\n * i18nApply() or ComponentFactory.create), we need to adjust the blueprint for future\n * template passes.\n */\nexport function adjustBlueprintForNewNode(view: LViewData) {\n  const tView = view[TVIEW];\n  if (tView.firstTemplatePass) {\n    tView.hostBindingStartIndex++;\n    tView.blueprint.push(null);\n    view.push(null);\n  }\n}\n\n\n//////////////////////////\n//// Render\n//////////////////////////\n\n/**\n * Resets the application state.\n */\nexport function resetComponentState() {\n  isParent = false;\n  previousOrParentNode = null !;\n  elementDepthCount = 0;\n}\n\n/**\n *\n * @param hostNode Existing node to render into.\n * @param templateFn Template function with the instructions.\n * @param consts The number of nodes, local refs, and pipes in this template\n * @param context to pass into the template.\n * @param providedRendererFactory renderer factory to use\n * @param host The host element node to use\n * @param directives Directive defs that should be used for matching\n * @param pipes Pipe defs that should be used for matching\n */\nexport function renderTemplate<T>(\n    hostNode: RElement, templateFn: ComponentTemplate<T>, consts: number, vars: number, context: T,\n    providedRendererFactory: RendererFactory3, host: LElementNode | null,\n    directives?: DirectiveDefListOrFactory | null, pipes?: PipeDefListOrFactory | null,\n    sanitizer?: Sanitizer | null): LElementNode {\n  if (host == null) {\n    resetComponentState();\n    rendererFactory = providedRendererFactory;\n    const tView =\n        getOrCreateTView(templateFn, consts, vars, directives || null, pipes || null, null);\n    host = createLNode(\n        -1, TNodeType.Element, hostNode, null, null,\n        createLViewData(\n            providedRendererFactory.createRenderer(null, null), tView, {}, LViewFlags.CheckAlways,\n            sanitizer));\n  }\n  const hostView = host.data !;\n  ngDevMode && assertDefined(hostView, 'Host node should have an LView defined in host.data.');\n  renderComponentOrTemplate(host, hostView, context, templateFn);\n  return host;\n}\n\n/**\n * Used for creating the LViewNode of a dynamic embedded view,\n * either through ViewContainerRef.createEmbeddedView() or TemplateRef.createEmbeddedView().\n * Such lViewNode will then be renderer with renderEmbeddedTemplate() (see below).\n */\nexport function createEmbeddedViewNode<T>(\n    tView: TView, context: T, declarationView: LViewData, renderer: Renderer3,\n    queries?: LQueries | null): LViewNode {\n  const _isParent = isParent;\n  const _previousOrParentNode = previousOrParentNode;\n  isParent = true;\n  previousOrParentNode = null !;\n\n  const lView =\n      createLViewData(renderer, tView, context, LViewFlags.CheckAlways, getCurrentSanitizer());\n  lView[DECLARATION_VIEW] = declarationView;\n\n  if (queries) {\n    lView[QUERIES] = queries.createView();\n  }\n  const viewNode = createLNode(-1, TNodeType.View, null, null, null, lView);\n\n  isParent = _isParent;\n  previousOrParentNode = _previousOrParentNode;\n  return viewNode;\n}\n\n/**\n * Used for rendering embedded views (e.g. dynamically created views)\n *\n * Dynamically created views must store/retrieve their TViews differently from component views\n * because their template functions are nested in the template functions of their hosts, creating\n * closures. If their host template happens to be an embedded template in a loop (e.g. ngFor inside\n * an ngFor), the nesting would mean we'd have multiple instances of the template function, so we\n * can't store TViews in the template function itself (as we do for comps). Instead, we store the\n * TView for dynamically created views on their host TNode, which only has one instance.\n */\nexport function renderEmbeddedTemplate<T>(\n    viewNode: LViewNode | LElementNode, tView: TView, context: T, rf: RenderFlags): LViewNode|\n    LElementNode {\n  const _isParent = isParent;\n  const _previousOrParentNode = previousOrParentNode;\n  let oldView: LViewData;\n  if (viewNode.data ![PARENT] == null && viewNode.data ![CONTEXT] && !tView.template) {\n    // This is a root view inside the view tree\n    tickRootContext(viewNode.data ![CONTEXT] as RootContext);\n  } else {\n    try {\n      isParent = true;\n      previousOrParentNode = null !;\n\n      oldView = enterView(viewNode.data !, viewNode);\n      namespaceHTML();\n      tView.template !(rf, context);\n      if (rf & RenderFlags.Update) {\n        refreshDescendantViews();\n      } else {\n        viewNode.data ![TVIEW].firstTemplatePass = firstTemplatePass = false;\n      }\n    } finally {\n      // renderEmbeddedTemplate() is called twice in fact, once for creation only and then once for\n      // update. When for creation only, leaveView() must not trigger view hooks, nor clean flags.\n      const isCreationOnly = (rf & RenderFlags.Create) === RenderFlags.Create;\n      leaveView(oldView !, isCreationOnly);\n      isParent = _isParent;\n      previousOrParentNode = _previousOrParentNode;\n    }\n  }\n  return viewNode;\n}\n\n/**\n * Retrieves a context at the level specified and saves it as the global, contextViewData.\n * Will get the next level up if level is not specified.\n *\n * This is used to save contexts of parent views so they can be bound in embedded views, or\n * in conjunction with reference() to bind a ref from a parent view.\n *\n * @param level The relative level of the view from which to grab context compared to contextVewData\n * @returns context\n */\nexport function nextContext<T = any>(level: number = 1): T {\n  contextViewData = walkUpViews(level, contextViewData !);\n  return contextViewData[CONTEXT] as T;\n}\n\nexport function renderComponentOrTemplate<T>(\n    node: LElementNode, hostView: LViewData, componentOrContext: T,\n    templateFn?: ComponentTemplate<T>) {\n  const oldView = enterView(hostView, node);\n  try {\n    if (rendererFactory.begin) {\n      rendererFactory.begin();\n    }\n    if (templateFn) {\n      namespaceHTML();\n      templateFn(getRenderFlags(hostView), componentOrContext !);\n      refreshDescendantViews();\n    } else {\n      executeInitAndContentHooks();\n\n      // Element was stored at 0 in data and directive was stored at 0 in directives\n      // in renderComponent()\n      setHostBindings(tView.hostBindings);\n      componentRefresh(HEADER_OFFSET);\n    }\n  } finally {\n    if (rendererFactory.end) {\n      rendererFactory.end();\n    }\n    leaveView(oldView);\n  }\n}\n\n/**\n * This function returns the default configuration of rendering flags depending on when the\n * template is in creation mode or update mode. By default, the update block is run with the\n * creation block when the view is in creation mode. Otherwise, the update block is run\n * alone.\n *\n * Dynamically created views do NOT use this configuration (update block and create block are\n * always run separately).\n */\nfunction getRenderFlags(view: LViewData): RenderFlags {\n  return view[FLAGS] & LViewFlags.CreationMode ? RenderFlags.Create | RenderFlags.Update :\n                                                 RenderFlags.Update;\n}\n\n//////////////////////////\n//// Namespace\n//////////////////////////\n\nlet _currentNamespace: string|null = null;\n\nexport function namespaceSVG() {\n  _currentNamespace = 'http://www.w3.org/2000/svg/';\n}\n\nexport function namespaceMathML() {\n  _currentNamespace = 'http://www.w3.org/1998/MathML/';\n}\n\nexport function namespaceHTML() {\n  _currentNamespace = null;\n}\n\n//////////////////////////\n//// Element\n//////////////////////////\n\n/**\n * Creates an empty element using {@link elementStart} and {@link elementEnd}\n *\n * @param index Index of the element in the data array\n * @param name Name of the DOM Node\n * @param attrs Statically bound set of attributes to be written into the DOM element on creation.\n * @param localRefs A set of local reference bindings on the element.\n */\nexport function element(\n    index: number, name: string, attrs?: TAttributes | null, localRefs?: string[] | null): void {\n  elementStart(index, name, attrs, localRefs);\n  elementEnd();\n}\n\n/**\n * Creates a logical container for other nodes (<ng-container>) backed by a comment node in the DOM.\n * The instruction must later be followed by `elementContainerEnd()` call.\n *\n * @param index Index of the element in the LViewData array\n * @param attrs Set of attributes to be used when matching directives.\n * @param localRefs A set of local reference bindings on the element.\n *\n * Even if this instruction accepts a set of attributes no actual attribute values are propagated to\n * the DOM (as a comment node can't have attributes). Attributes are here only for directive\n * matching purposes and setting initial inputs of directives.\n */\nexport function elementContainerStart(\n    index: number, attrs?: TAttributes | null, localRefs?: string[] | null): void {\n  ngDevMode && assertEqual(\n                   viewData[BINDING_INDEX], tView.bindingStartIndex,\n                   'element containers should be created before any bindings');\n\n  ngDevMode && ngDevMode.rendererCreateComment++;\n  const native = renderer.createComment(ngDevMode ? 'ng-container' : '');\n\n  ngDevMode && assertDataInRange(index - 1);\n\n  const node: LElementContainerNode =\n      createLNode(index, TNodeType.ElementContainer, native, null, attrs || null, null);\n\n  appendChild(getParentLNode(node), native, viewData);\n  createDirectivesAndLocals(node, localRefs);\n}\n\n/** Mark the end of the <ng-container>. */\nexport function elementContainerEnd(): void {\n  if (isParent) {\n    isParent = false;\n  } else {\n    ngDevMode && assertHasParent();\n    previousOrParentNode = getParentLNode(previousOrParentNode) as LElementContainerNode;\n  }\n\n  ngDevMode && assertNodeType(previousOrParentNode, TNodeType.ElementContainer);\n\n  currentQueries && (currentQueries = currentQueries.addNode(previousOrParentNode));\n\n  queueLifecycleHooks(previousOrParentNode.tNode.flags, tView);\n}\n\n/**\n * Create DOM element. The instruction must later be followed by `elementEnd()` call.\n *\n * @param index Index of the element in the LViewData array\n * @param name Name of the DOM Node\n * @param attrs Statically bound set of attributes to be written into the DOM element on creation.\n * @param localRefs A set of local reference bindings on the element.\n *\n * Attributes and localRefs are passed as an array of strings where elements with an even index\n * hold an attribute name and elements with an odd index hold an attribute value, ex.:\n * ['id', 'warning5', 'class', 'alert']\n */\nexport function elementStart(\n    index: number, name: string, attrs?: TAttributes | null, localRefs?: string[] | null): void {\n  ngDevMode && assertEqual(\n                   viewData[BINDING_INDEX], tView.bindingStartIndex,\n                   'elements should be created before any bindings ');\n\n  ngDevMode && ngDevMode.rendererCreateElement++;\n\n  const native = elementCreate(name);\n\n  ngDevMode && assertDataInRange(index - 1);\n\n  const node: LElementNode =\n      createLNode(index, TNodeType.Element, native !, name, attrs || null, null);\n\n  if (attrs) {\n    setUpAttributes(native, attrs);\n  }\n  appendChild(getParentLNode(node), native, viewData);\n  createDirectivesAndLocals(node, localRefs);\n\n  // any immediate children of a component or template container must be pre-emptively\n  // monkey-patched with the component view data so that the element can be inspected\n  // later on using any element discovery utility methods (see `element_discovery.ts`)\n  if (elementDepthCount === 0) {\n    attachLViewDataToNode(native, viewData);\n  }\n  elementDepthCount++;\n}\n\n/**\n * Creates a native element from a tag name, using a renderer.\n * @param name the tag name\n * @param overriddenRenderer Optional A renderer to override the default one\n * @returns the element created\n */\nexport function elementCreate(name: string, overriddenRenderer?: Renderer3): RElement {\n  let native: RElement;\n  const rendererToUse = overriddenRenderer || renderer;\n\n  if (isProceduralRenderer(rendererToUse)) {\n    native = rendererToUse.createElement(name, _currentNamespace);\n  } else {\n    if (_currentNamespace === null) {\n      native = rendererToUse.createElement(name);\n    } else {\n      native = rendererToUse.createElementNS(_currentNamespace, name);\n    }\n  }\n  return native;\n}\n\nfunction nativeNodeLocalRefExtractor(lNode: LNodeWithLocalRefs): RNode {\n  return lNode.native;\n}\n\n/**\n * Creates directive instances and populates local refs.\n *\n * @param lNode LNode for which directive and locals should be created\n * @param localRefs Local refs of the node in question\n * @param localRefExtractor mapping function that extracts local ref value from LNode\n */\nfunction createDirectivesAndLocals(\n    lNode: LNodeWithLocalRefs, localRefs: string[] | null | undefined,\n    localRefExtractor: LocalRefExtractor = nativeNodeLocalRefExtractor) {\n  if (firstTemplatePass) {\n    ngDevMode && ngDevMode.firstTemplatePass++;\n    cacheMatchingDirectivesForNode(lNode.tNode, tView, localRefs || null);\n  } else {\n    instantiateDirectivesDirectly();\n  }\n  saveResolvedLocalsInData(lNode, localRefExtractor);\n}\n\n/**\n * On first template pass, we match each node against available directive selectors and save\n * the resulting defs in the correct instantiation order for subsequent change detection runs\n * (so dependencies are always created before the directives that inject them).\n */\nfunction cacheMatchingDirectivesForNode(\n    tNode: TNode, tView: TView, localRefs: string[] | null): void {\n  // Please make sure to have explicit type for `exportsMap`. Inferred type triggers bug in tsickle.\n  const exportsMap: ({[key: string]: number} | null) = localRefs ? {'': -1} : null;\n  const matches = tView.currentMatches = findDirectiveMatches(tNode);\n  if (matches) {\n    for (let i = 0; i < matches.length; i += 2) {\n      const def = matches[i] as DirectiveDefInternal<any>;\n      const valueIndex = i + 1;\n      resolveDirective(def, valueIndex, matches, tView);\n      saveNameToExportMap(matches[valueIndex] as number, def, exportsMap);\n    }\n  }\n  if (exportsMap) cacheMatchingLocalNames(tNode, localRefs, exportsMap);\n}\n\n/** Matches the current node against all available selectors. */\nfunction findDirectiveMatches(tNode: TNode): CurrentMatchesList|null {\n  const registry = tView.directiveRegistry;\n  let matches: any[]|null = null;\n  if (registry) {\n    for (let i = 0; i < registry.length; i++) {\n      const def = registry[i];\n      if (isNodeMatchingSelectorList(tNode, def.selectors !)) {\n        if ((def as ComponentDefInternal<any>).template) {\n          if (tNode.flags & TNodeFlags.isComponent) throwMultipleComponentError(tNode);\n          tNode.flags = TNodeFlags.isComponent;\n        }\n        if (def.diPublic) def.diPublic(def);\n        (matches || (matches = [])).push(def, null);\n      }\n    }\n  }\n  return matches as CurrentMatchesList;\n}\n\nexport function resolveDirective(\n    def: DirectiveDefInternal<any>, valueIndex: number, matches: CurrentMatchesList,\n    tView: TView): any {\n  if (matches[valueIndex] === null) {\n    matches[valueIndex] = CIRCULAR;\n    const instance = def.factory();\n    (tView.directives || (tView.directives = [])).push(def);\n    return directiveCreate(matches[valueIndex] = tView.directives !.length - 1, instance, def);\n  } else if (matches[valueIndex] === CIRCULAR) {\n    // If we revisit this directive before it's resolved, we know it's circular\n    throwCyclicDependencyError(def.type);\n  }\n  return null;\n}\n\n/** Stores index of component's host element so it will be queued for view refresh during CD. */\nfunction queueComponentIndexForCheck(): void {\n  if (firstTemplatePass) {\n    (tView.components || (tView.components = [])).push(previousOrParentNode.tNode.index);\n  }\n}\n\n/** Stores index of directive and host element so it will be queued for binding refresh during CD.\n */\nexport function queueHostBindingForCheck(dirIndex: number, hostVars: number): void {\n  // Must subtract the header offset because hostBindings functions are generated with\n  // instructions that expect element indices that are NOT adjusted (e.g. elementProperty).\n  ngDevMode &&\n      assertEqual(firstTemplatePass, true, 'Should only be called in first template pass.');\n  for (let i = 0; i < hostVars; i++) {\n    tView.blueprint.push(NO_CHANGE);\n    viewData.push(NO_CHANGE);\n  }\n  (tView.hostBindings || (tView.hostBindings = [\n   ])).push(dirIndex, previousOrParentNode.tNode.index - HEADER_OFFSET);\n}\n\n/** Sets the context for a ChangeDetectorRef to the given instance. */\nexport function initChangeDetectorIfExisting(\n    injector: LInjector | null, instance: any, view: LViewData): void {\n  if (injector && injector.changeDetectorRef != null) {\n    (injector.changeDetectorRef as ViewRef<any>)._setComponentContext(view, instance);\n  }\n}\n\nexport function isContentQueryHost(tNode: TNode): boolean {\n  return (tNode.flags & TNodeFlags.hasContentQuery) !== 0;\n}\n\nexport function isComponent(tNode: TNode): boolean {\n  return (tNode.flags & TNodeFlags.isComponent) === TNodeFlags.isComponent;\n}\n\n/**\n * This function instantiates the given directives.\n */\nfunction instantiateDirectivesDirectly() {\n  ngDevMode && assertEqual(\n                   firstTemplatePass, false,\n                   `Directives should only be instantiated directly after first template pass`);\n  const tNode = previousOrParentNode.tNode;\n  const count = tNode.flags & TNodeFlags.DirectiveCountMask;\n\n  if (isContentQueryHost(tNode) && currentQueries) {\n    currentQueries = currentQueries.clone();\n  }\n\n  if (count > 0) {\n    const start = tNode.flags >> TNodeFlags.DirectiveStartingIndexShift;\n    const end = start + count;\n    const tDirectives = tView.directives !;\n\n    for (let i = start; i < end; i++) {\n      const def: DirectiveDefInternal<any> = tDirectives[i];\n      directiveCreate(i, def.factory(), def);\n    }\n  }\n}\n\n/** Caches local names and their matching directive indices for query and template lookups. */\nfunction cacheMatchingLocalNames(\n    tNode: TNode, localRefs: string[] | null, exportsMap: {[key: string]: number}): void {\n  if (localRefs) {\n    const localNames: (string | number)[] = tNode.localNames = [];\n\n    // Local names must be stored in tNode in the same order that localRefs are defined\n    // in the template to ensure the data is loaded in the same slots as their refs\n    // in the template (for template queries).\n    for (let i = 0; i < localRefs.length; i += 2) {\n      const index = exportsMap[localRefs[i + 1]];\n      if (index == null) throw new Error(`Export of name '${localRefs[i + 1]}' not found!`);\n      localNames.push(localRefs[i], index);\n    }\n  }\n}\n\n/**\n * Builds up an export map as directives are created, so local refs can be quickly mapped\n * to their directive instances.\n */\nfunction saveNameToExportMap(\n    index: number, def: DirectiveDefInternal<any>| ComponentDefInternal<any>,\n    exportsMap: {[key: string]: number} | null) {\n  if (exportsMap) {\n    if (def.exportAs) exportsMap[def.exportAs] = index;\n    if ((def as ComponentDefInternal<any>).template) exportsMap[''] = index;\n  }\n}\n\n/**\n * Takes a list of local names and indices and pushes the resolved local variable values\n * to LViewData in the same order as they are loaded in the template with load().\n */\nfunction saveResolvedLocalsInData(\n    lNode: LNodeWithLocalRefs, localRefExtractor: LocalRefExtractor): void {\n  const localNames = lNode.tNode.localNames;\n  if (localNames) {\n    let localIndex = lNode.tNode.index + 1;\n    for (let i = 0; i < localNames.length; i += 2) {\n      const index = localNames[i + 1] as number;\n      const value = index === -1 ? localRefExtractor(lNode) : directives ![index];\n      viewData[localIndex++] = value;\n    }\n  }\n}\n\n/**\n * Gets TView from a template function or creates a new TView\n * if it doesn't already exist.\n *\n * @param templateFn The template from which to get static data\n * @param consts The number of nodes, local refs, and pipes in this view\n * @param vars The number of bindings and pure function bindings in this view\n * @param directives Directive defs that should be saved on TView\n * @param pipes Pipe defs that should be saved on TView\n * @returns TView\n */\nfunction getOrCreateTView(\n    templateFn: ComponentTemplate<any>, consts: number, vars: number,\n    directives: DirectiveDefListOrFactory | null, pipes: PipeDefListOrFactory | null,\n    viewQuery: ComponentQuery<any>| null): TView {\n  // TODO(misko): reading `ngPrivateData` here is problematic for two reasons\n  // 1. It is a megamorphic call on each invocation.\n  // 2. For nested embedded views (ngFor inside ngFor) the template instance is per\n  //    outer template invocation, which means that no such property will exist\n  // Correct solution is to only put `ngPrivateData` on the Component template\n  // and not on embedded templates.\n\n  return templateFn.ngPrivateData ||\n      (templateFn.ngPrivateData =\n           createTView(-1, templateFn, consts, vars, directives, pipes, viewQuery) as never);\n}\n\n/**\n * Creates a TView instance\n *\n * @param viewIndex The viewBlockId for inline views, or -1 if it's a component/dynamic\n * @param templateFn Template function\n * @param consts The number of nodes, local refs, and pipes in this template\n * @param directives Registry of directives for this view\n * @param pipes Registry of pipes for this view\n */\nexport function createTView(\n    viewIndex: number, templateFn: ComponentTemplate<any>| null, consts: number, vars: number,\n    directives: DirectiveDefListOrFactory | null, pipes: PipeDefListOrFactory | null,\n    viewQuery: ComponentQuery<any>| null): TView {\n  ngDevMode && ngDevMode.tView++;\n  const bindingStartIndex = HEADER_OFFSET + consts;\n  // This length does not yet contain host bindings from child directives because at this point,\n  // we don't know which directives are active on this template. As soon as a directive is matched\n  // that has a host binding, we will update the blueprint with that def's hostVars count.\n  const initialViewLength = bindingStartIndex + vars;\n  const blueprint = createViewBlueprint(bindingStartIndex, initialViewLength);\n  return blueprint[TVIEW] = {\n    id: viewIndex,\n    blueprint: blueprint,\n    template: templateFn,\n    viewQuery: viewQuery,\n    node: null !,\n    data: HEADER_FILLER.slice(),  // Fill in to match HEADER_OFFSET in LViewData\n    childIndex: -1,               // Children set in addToViewTree(), if any\n    bindingStartIndex: bindingStartIndex,\n    hostBindingStartIndex: initialViewLength,\n    directives: null,\n    firstTemplatePass: true,\n    initHooks: null,\n    checkHooks: null,\n    contentHooks: null,\n    contentCheckHooks: null,\n    viewHooks: null,\n    viewCheckHooks: null,\n    destroyHooks: null,\n    pipeDestroyHooks: null,\n    cleanup: null,\n    hostBindings: null,\n    contentQueries: null,\n    components: null,\n    directiveRegistry: typeof directives === 'function' ? directives() : directives,\n    pipeRegistry: typeof pipes === 'function' ? pipes() : pipes,\n    currentMatches: null\n  };\n}\n\nfunction createViewBlueprint(bindingStartIndex: number, initialViewLength: number): LViewData {\n  const blueprint = new Array(initialViewLength)\n                        .fill(null, 0, bindingStartIndex)\n                        .fill(NO_CHANGE, bindingStartIndex) as LViewData;\n  blueprint[CONTAINER_INDEX] = -1;\n  blueprint[BINDING_INDEX] = bindingStartIndex;\n  return blueprint;\n}\n\nfunction setUpAttributes(native: RElement, attrs: TAttributes): void {\n  const isProc = isProceduralRenderer(renderer);\n  let i = 0;\n\n  while (i < attrs.length) {\n    const attrName = attrs[i];\n    if (attrName === AttributeMarker.SelectOnly) break;\n    if (attrName === NG_PROJECT_AS_ATTR_NAME) {\n      i += 2;\n    } else {\n      ngDevMode && ngDevMode.rendererSetAttribute++;\n      if (attrName === AttributeMarker.NamespaceURI) {\n        // Namespaced attributes\n        const namespaceURI = attrs[i + 1] as string;\n        const attrName = attrs[i + 2] as string;\n        const attrVal = attrs[i + 3] as string;\n        isProc ?\n            (renderer as ProceduralRenderer3)\n                .setAttribute(native, attrName, attrVal, namespaceURI) :\n            native.setAttributeNS(namespaceURI, attrName, attrVal);\n        i += 4;\n      } else {\n        // Standard attributes\n        const attrVal = attrs[i + 1];\n        isProc ?\n            (renderer as ProceduralRenderer3)\n                .setAttribute(native, attrName as string, attrVal as string) :\n            native.setAttribute(attrName as string, attrVal as string);\n        i += 2;\n      }\n    }\n  }\n}\n\nexport function createError(text: string, token: any) {\n  return new Error(`Renderer: ${text} [${stringify(token)}]`);\n}\n\n\n/**\n * Locates the host native element, used for bootstrapping existing nodes into rendering pipeline.\n *\n * @param elementOrSelector Render element or CSS selector to locate the element.\n */\nexport function locateHostElement(\n    factory: RendererFactory3, elementOrSelector: RElement | string): RElement|null {\n  ngDevMode && assertDataInRange(-1);\n  rendererFactory = factory;\n  const defaultRenderer = factory.createRenderer(null, null);\n  const rNode = typeof elementOrSelector === 'string' ?\n      (isProceduralRenderer(defaultRenderer) ?\n           defaultRenderer.selectRootElement(elementOrSelector) :\n           defaultRenderer.querySelector(elementOrSelector)) :\n      elementOrSelector;\n  if (ngDevMode && !rNode) {\n    if (typeof elementOrSelector === 'string') {\n      throw createError('Host node with selector not found:', elementOrSelector);\n    } else {\n      throw createError('Host node is required:', elementOrSelector);\n    }\n  }\n  return rNode;\n}\n\n/**\n * Creates the host LNode.\n *\n * @param rNode Render host element.\n * @param def ComponentDef\n *\n * @returns LElementNode created\n */\nexport function hostElement(\n    tag: string, rNode: RElement | null, def: ComponentDefInternal<any>,\n    sanitizer?: Sanitizer | null): LElementNode {\n  resetComponentState();\n  const node = createLNode(\n      0, TNodeType.Element, rNode, null, null,\n      createLViewData(\n          renderer,\n          getOrCreateTView(\n              def.template, def.consts, def.vars, def.directiveDefs, def.pipeDefs, def.viewQuery),\n          null, def.onPush ? LViewFlags.Dirty : LViewFlags.CheckAlways, sanitizer));\n\n  if (firstTemplatePass) {\n    node.tNode.flags = TNodeFlags.isComponent;\n    if (def.diPublic) def.diPublic(def);\n    tView.directives = [def];\n  }\n\n  return node;\n}\n\n/**\n * Adds an event listener to the current node.\n *\n * If an output exists on one of the node's directives, it also subscribes to the output\n * and saves the subscription for later cleanup.\n *\n * @param eventName Name of the event\n * @param listenerFn The function to be called when event emits\n * @param useCapture Whether or not to use capture in event listener.\n */\nexport function listener(\n    eventName: string, listenerFn: (e?: any) => any, useCapture = false): void {\n  ngDevMode &&\n      assertNodeOfPossibleTypes(\n          previousOrParentNode, TNodeType.Element, TNodeType.Container, TNodeType.ElementContainer);\n  const node = previousOrParentNode;\n\n  // add native event listener - applicable to elements only\n  if (previousOrParentNode.tNode.type === TNodeType.Element) {\n    const native = node.native as RElement;\n    ngDevMode && ngDevMode.rendererAddEventListener++;\n\n    // In order to match current behavior, native DOM event listeners must be added for all\n    // events (including outputs).\n    if (isProceduralRenderer(renderer)) {\n      const wrappedListener = wrapListenerWithDirtyLogic(viewData, listenerFn);\n      const cleanupFn = renderer.listen(native, eventName, wrappedListener);\n      storeCleanupFn(viewData, cleanupFn);\n    } else {\n      const wrappedListener = wrapListenerWithDirtyAndDefault(viewData, listenerFn);\n      native.addEventListener(eventName, wrappedListener, useCapture);\n      const cleanupInstances = getCleanup(viewData);\n      cleanupInstances.push(wrappedListener);\n      if (firstTemplatePass) {\n        getTViewCleanup(viewData).push(\n            eventName, node.tNode.index, cleanupInstances !.length - 1, useCapture);\n      }\n    }\n  }\n\n  // subscribe to directive outputs\n  let tNode: TNode|null = node.tNode;\n  if (tNode.outputs === undefined) {\n    // if we create TNode here, inputs must be undefined so we know they still need to be\n    // checked\n    tNode.outputs = generatePropertyAliases(node.tNode.flags, BindingDirection.Output);\n  }\n\n  const outputs = tNode.outputs;\n  let outputData: PropertyAliasValue|undefined;\n  if (outputs && (outputData = outputs[eventName])) {\n    createOutput(outputData, listenerFn);\n  }\n}\n\n/**\n * Iterates through the outputs associated with a particular event name and subscribes to\n * each output.\n */\nfunction createOutput(outputs: PropertyAliasValue, listener: Function): void {\n  for (let i = 0; i < outputs.length; i += 2) {\n    ngDevMode && assertDataInRange(outputs[i] as number, directives !);\n    const subscription = directives ![outputs[i] as number][outputs[i + 1]].subscribe(listener);\n    storeCleanupWithContext(viewData, subscription, subscription.unsubscribe);\n  }\n}\n\n/**\n * Saves context for this cleanup function in LView.cleanupInstances.\n *\n * On the first template pass, saves in TView:\n * - Cleanup function\n * - Index of context we just saved in LView.cleanupInstances\n */\nexport function storeCleanupWithContext(\n    view: LViewData | null, context: any, cleanupFn: Function): void {\n  if (!view) view = viewData;\n  getCleanup(view).push(context);\n\n  if (view[TVIEW].firstTemplatePass) {\n    getTViewCleanup(view).push(cleanupFn, view[CLEANUP] !.length - 1);\n  }\n}\n\n/**\n * Saves the cleanup function itself in LView.cleanupInstances.\n *\n * This is necessary for functions that are wrapped with their contexts, like in renderer2\n * listeners.\n *\n * On the first template pass, the index of the cleanup function is saved in TView.\n */\nexport function storeCleanupFn(view: LViewData, cleanupFn: Function): void {\n  getCleanup(view).push(cleanupFn);\n\n  if (view[TVIEW].firstTemplatePass) {\n    getTViewCleanup(view).push(view[CLEANUP] !.length - 1, null);\n  }\n}\n\n/** Mark the end of the element. */\nexport function elementEnd(): void {\n  if (isParent) {\n    isParent = false;\n  } else {\n    ngDevMode && assertHasParent();\n    previousOrParentNode = getParentLNode(previousOrParentNode) as LElementNode;\n  }\n  ngDevMode && assertNodeType(previousOrParentNode, TNodeType.Element);\n  currentQueries && (currentQueries = currentQueries.addNode(previousOrParentNode));\n  queueLifecycleHooks(previousOrParentNode.tNode.flags, tView);\n  elementDepthCount--;\n}\n\n/**\n * Updates the value of removes an attribute on an Element.\n *\n * @param number index The index of the element in the data array\n * @param name name The name of the attribute.\n * @param value value The attribute is removed when value is `null` or `undefined`.\n *                  Otherwise the attribute value is set to the stringified value.\n * @param sanitizer An optional function used to sanitize the value.\n */\nexport function elementAttribute(\n    index: number, name: string, value: any, sanitizer?: SanitizerFn): void {\n  if (value !== NO_CHANGE) {\n    const element = loadElement(index);\n    if (value == null) {\n      ngDevMode && ngDevMode.rendererRemoveAttribute++;\n      isProceduralRenderer(renderer) ? renderer.removeAttribute(element.native, name) :\n                                       element.native.removeAttribute(name);\n    } else {\n      ngDevMode && ngDevMode.rendererSetAttribute++;\n      const strValue = sanitizer == null ? stringify(value) : sanitizer(value);\n      isProceduralRenderer(renderer) ? renderer.setAttribute(element.native, name, strValue) :\n                                       element.native.setAttribute(name, strValue);\n    }\n  }\n}\n\n/**\n * Update a property on an Element.\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new @Inputs don't have to be re-compiled.\n *\n * @param index The index of the element to update in the data array\n * @param propName Name of property. Because it is going to DOM, this is not subject to\n *        renaming as part of minification.\n * @param value New value to write.\n * @param sanitizer An optional function used to sanitize the value.\n */\n\nexport function elementProperty<T>(\n    index: number, propName: string, value: T | NO_CHANGE, sanitizer?: SanitizerFn): void {\n  if (value === NO_CHANGE) return;\n  const node = loadElement(index) as LElementNode;\n  const tNode = node.tNode;\n  // if tNode.inputs is undefined, a listener has created outputs, but inputs haven't\n  // yet been checked\n  if (tNode && tNode.inputs === undefined) {\n    // mark inputs as checked\n    tNode.inputs = generatePropertyAliases(node.tNode.flags, BindingDirection.Input);\n  }\n\n  const inputData = tNode && tNode.inputs;\n  let dataValue: PropertyAliasValue|undefined;\n  if (inputData && (dataValue = inputData[propName])) {\n    setInputsForProperty(dataValue, value);\n    markDirtyIfOnPush(node);\n  } else {\n    // It is assumed that the sanitizer is only added when the compiler determines that the property\n    // is risky, so sanitization can be done without further checks.\n    value = sanitizer != null ? (sanitizer(value) as any) : value;\n    const native = node.native;\n    ngDevMode && ngDevMode.rendererSetProperty++;\n    isProceduralRenderer(renderer) ? renderer.setProperty(native, propName, value) :\n                                     (native.setProperty ? native.setProperty(propName, value) :\n                                                           (native as any)[propName] = value);\n  }\n}\n\n/**\n * Constructs a TNode object from the arguments.\n *\n * @param type The type of the node\n * @param adjustedIndex The index of the TNode in TView.data, adjusted for HEADER_OFFSET\n * @param tagName The tag name of the node\n * @param attrs The attributes defined on this node\n * @param parent The parent of this node\n * @param tViews Any TViews attached to this node\n * @returns the TNode object\n */\nexport function createTNode(\n    type: TNodeType, adjustedIndex: number, tagName: string | null, attrs: TAttributes | null,\n    parent: TElementNode | TContainerNode | null, tViews: TView[] | null): TNode {\n  ngDevMode && ngDevMode.tNode++;\n  return {\n    type: type,\n    index: adjustedIndex,\n    flags: 0,\n    tagName: tagName,\n    attrs: attrs,\n    localNames: null,\n    initialInputs: undefined,\n    inputs: undefined,\n    outputs: undefined,\n    tViews: tViews,\n    next: null,\n    child: null,\n    parent: parent,\n    dynamicContainerNode: null,\n    detached: null,\n    stylingTemplate: null,\n    projection: null\n  };\n}\n\n/**\n * Given a list of directive indices and minified input names, sets the\n * input properties on the corresponding directives.\n */\nfunction setInputsForProperty(inputs: PropertyAliasValue, value: any): void {\n  for (let i = 0; i < inputs.length; i += 2) {\n    ngDevMode && assertDataInRange(inputs[i] as number, directives !);\n    directives ![inputs[i] as number][inputs[i + 1]] = value;\n  }\n}\n\n/**\n * Consolidates all inputs or outputs of all directives on this logical node.\n *\n * @param number lNodeFlags logical node flags\n * @param Direction direction whether to consider inputs or outputs\n * @returns PropertyAliases|null aggregate of all properties if any, `null` otherwise\n */\nfunction generatePropertyAliases(\n    tNodeFlags: TNodeFlags, direction: BindingDirection): PropertyAliases|null {\n  const count = tNodeFlags & TNodeFlags.DirectiveCountMask;\n  let propStore: PropertyAliases|null = null;\n\n  if (count > 0) {\n    const start = tNodeFlags >> TNodeFlags.DirectiveStartingIndexShift;\n    const end = start + count;\n    const isInput = direction === BindingDirection.Input;\n    const defs = tView.directives !;\n\n    for (let i = start; i < end; i++) {\n      const directiveDef = defs[i] as DirectiveDefInternal<any>;\n      const propertyAliasMap: {[publicName: string]: string} =\n          isInput ? directiveDef.inputs : directiveDef.outputs;\n      for (let publicName in propertyAliasMap) {\n        if (propertyAliasMap.hasOwnProperty(publicName)) {\n          propStore = propStore || {};\n          const internalName = propertyAliasMap[publicName];\n          const hasProperty = propStore.hasOwnProperty(publicName);\n          hasProperty ? propStore[publicName].push(i, internalName) :\n                        (propStore[publicName] = [i, internalName]);\n        }\n      }\n    }\n  }\n  return propStore;\n}\n\n/**\n * Add or remove a class in a `classList` on a DOM element.\n *\n * This instruction is meant to handle the [class.foo]=\"exp\" case\n *\n * @param index The index of the element to update in the data array\n * @param className Name of class to toggle. Because it is going to DOM, this is not subject to\n *        renaming as part of minification.\n * @param value A value indicating if a given class should be added or removed.\n */\nexport function elementClassProp<T>(\n    index: number, stylingIndex: number, value: T | NO_CHANGE): void {\n  updateElementClassProp(getStylingContext(index), stylingIndex, value ? true : false);\n}\n\n/**\n * Assign any inline style values to the element during creation mode.\n *\n * This instruction is meant to be called during creation mode to apply all styling\n * (e.g. `style=\"...\"`) values to the element. This is also where the provided index\n * value is allocated for the styling details for its corresponding element (the element\n * index is the previous index value from this one).\n *\n * (Note this function calls `elementStylingApply` immediately when called.)\n *\n *\n * @param index Index value which will be allocated to store styling data for the element.\n *        (Note that this is not the element index, but rather an index value allocated\n *        specifically for element styling--the index must be the next index after the element\n *        index.)\n * @param classDeclarations A key/value array of CSS classes that will be registered on the element.\n *   Each individual style will be used on the element as long as it is not overridden\n *   by any classes placed on the element by multiple (`[class]`) or singular (`[class.named]`)\n *   bindings. If a class binding changes its value to a falsy value then the matching initial\n *   class value that are passed in here will be applied to the element (if matched).\n * @param styleDeclarations A key/value array of CSS styles that will be registered on the element.\n *   Each individual style will be used on the element as long as it is not overridden\n *   by any styles placed on the element by multiple (`[style]`) or singular (`[style.prop]`)\n *   bindings. If a style binding changes its value to null then the initial styling\n *   values that are passed in here will be applied to the element (if matched).\n * @param styleSanitizer An optional sanitizer function that will be used (if provided)\n *   to sanitize the any CSS property values that are applied to the element (during rendering).\n */\nexport function elementStyling<T>(\n    classDeclarations?: (string | boolean | InitialStylingFlags)[] | null,\n    styleDeclarations?: (string | boolean | InitialStylingFlags)[] | null,\n    styleSanitizer?: StyleSanitizeFn | null): void {\n  const tNode = previousOrParentNode.tNode;\n  if (!tNode.stylingTemplate) {\n    // initialize the styling template.\n    tNode.stylingTemplate =\n        createStylingContextTemplate(classDeclarations, styleDeclarations, styleSanitizer);\n  }\n  if (styleDeclarations && styleDeclarations.length ||\n      classDeclarations && classDeclarations.length) {\n    elementStylingApply(tNode.index - HEADER_OFFSET);\n  }\n}\n\n/**\n * Retrieve the `StylingContext` at a given index.\n *\n * This method lazily creates the `StylingContext`. This is because in most cases\n * we have styling without any bindings. Creating `StylingContext` eagerly would mean that\n * every style declaration such as `<div style=\"color: red\">` would result `StyleContext`\n * which would create unnecessary memory pressure.\n *\n * @param index Index of the style allocation. See: `elementStyling`.\n */\nfunction getStylingContext(index: number): StylingContext {\n  let stylingContext = load<StylingContext>(index);\n  if (!Array.isArray(stylingContext)) {\n    const lElement = stylingContext as any as LElementNode;\n    const tNode = lElement.tNode;\n    ngDevMode &&\n        assertDefined(tNode.stylingTemplate, 'getStylingContext() called before elementStyling()');\n    stylingContext = viewData[index + HEADER_OFFSET] =\n        allocStylingContext(lElement, tNode.stylingTemplate !);\n  }\n  return stylingContext;\n}\n\n/**\n * Apply all styling values to the element which have been queued by any styling instructions.\n *\n * This instruction is meant to be run once one or more `elementStyle` and/or `elementStyleProp`\n * have been issued against the element. This function will also determine if any styles have\n * changed and will then skip the operation if there is nothing new to render.\n *\n * Once called then all queued styles will be flushed.\n *\n * @param index Index of the element's styling storage that will be rendered.\n *        (Note that this is not the element index, but rather an index value allocated\n *        specifically for element styling--the index must be the next index after the element\n *        index.)\n */\nexport function elementStylingApply<T>(index: number): void {\n  renderElementStyles(getStylingContext(index), renderer);\n}\n\n/**\n * Queue a given style to be rendered on an Element.\n *\n * If the style value is `null` then it will be removed from the element\n * (or assigned a different value depending if there are any styles placed\n * on the element with `elementStyle` or any styles that are present\n * from when the element was created (with `elementStyling`).\n *\n * (Note that the styling instruction will not be applied until `elementStylingApply` is called.)\n *\n * @param index Index of the element's styling storage to change in the data array.\n *        (Note that this is not the element index, but rather an index value allocated\n *        specifically for element styling--the index must be the next index after the element\n *        index.)\n * @param styleIndex Index of the style property on this element. (Monotonically increasing.)\n * @param styleName Name of property. Because it is going to DOM this is not subject to\n *        renaming as part of minification.\n * @param value New value to write (null to remove).\n * @param suffix Optional suffix. Used with scalar values to add unit such as `px`.\n *        Note that when a suffix is provided then the underlying sanitizer will\n *        be ignored.\n */\nexport function elementStyleProp<T>(\n    index: number, styleIndex: number, value: T | null, suffix?: string): void {\n  let valueToAdd: string|null = null;\n  if (value) {\n    if (suffix) {\n      // when a suffix is applied then it will bypass\n      // sanitization entirely (b/c a new string is created)\n      valueToAdd = stringify(value) + suffix;\n    } else {\n      // sanitization happens by dealing with a String value\n      // this means that the string value will be passed through\n      // into the style rendering later (which is where the value\n      // will be sanitized before it is applied)\n      valueToAdd = value as any as string;\n    }\n  }\n  updateElementStyleProp(getStylingContext(index), styleIndex, valueToAdd);\n}\n\n/**\n * Queue a key/value map of styles to be rendered on an Element.\n *\n * This instruction is meant to handle the `[style]=\"exp\"` usage. When styles are applied to\n * the Element they will then be placed with respect to any styles set with `elementStyleProp`.\n * If any styles are set to `null` then they will be removed from the element (unless the same\n * style properties have been assigned to the element during creation using `elementStyling`).\n *\n * (Note that the styling instruction will not be applied until `elementStylingApply` is called.)\n *\n * @param index Index of the element's styling storage to change in the data array.\n *        (Note that this is not the element index, but rather an index value allocated\n *        specifically for element styling--the index must be the next index after the element\n *        index.)\n * @param classes A key/value style map of CSS classes that will be added to the given element.\n *        Any missing classes (that have already been applied to the element beforehand) will be\n *        removed (unset) from the element's list of CSS classes.\n * @param styles A key/value style map of the styles that will be applied to the given element.\n *        Any missing styles (that have already been applied to the element beforehand) will be\n *        removed (unset) from the element's styling.\n */\nexport function elementStylingMap<T>(\n    index: number, classes: {[key: string]: any} | string | null,\n    styles?: {[styleName: string]: any} | null): void {\n  updateStylingMap(getStylingContext(index), classes, styles);\n}\n\n//////////////////////////\n//// Text\n//////////////////////////\n\n/**\n * Create static text node\n *\n * @param index Index of the node in the data array\n * @param value Value to write. This value will be stringified.\n */\nexport function text(index: number, value?: any): void {\n  ngDevMode && assertEqual(\n                   viewData[BINDING_INDEX], tView.bindingStartIndex,\n                   'text nodes should be created before any bindings');\n  ngDevMode && ngDevMode.rendererCreateTextNode++;\n  const textNode = createTextNode(value, renderer);\n  const node = createLNode(index, TNodeType.Element, textNode, null, null);\n\n  // Text nodes are self closing.\n  isParent = false;\n  appendChild(getParentLNode(node), textNode, viewData);\n}\n\n/**\n * Create text node with binding\n * Bindings should be handled externally with the proper interpolation(1-8) method\n *\n * @param index Index of the node in the data array.\n * @param value Stringified value to write.\n */\nexport function textBinding<T>(index: number, value: T | NO_CHANGE): void {\n  if (value !== NO_CHANGE) {\n    ngDevMode && assertDataInRange(index + HEADER_OFFSET);\n    const existingNode = loadElement(index) as any as LTextNode;\n    ngDevMode && assertDefined(existingNode, 'LNode should exist');\n    ngDevMode && assertDefined(existingNode.native, 'native element should exist');\n    ngDevMode && ngDevMode.rendererSetText++;\n    isProceduralRenderer(renderer) ? renderer.setValue(existingNode.native, stringify(value)) :\n                                     existingNode.native.textContent = stringify(value);\n  }\n}\n\n//////////////////////////\n//// Directive\n//////////////////////////\n\n/**\n * Create a directive and their associated content queries.\n *\n * NOTE: directives can be created in order other than the index order. They can also\n *       be retrieved before they are created in which case the value will be null.\n *\n * @param directive The directive instance.\n * @param directiveDef DirectiveDef object which contains information about the template.\n */\nexport function directiveCreate<T>(\n    directiveDefIdx: number, directive: T,\n    directiveDef: DirectiveDefInternal<T>| ComponentDefInternal<T>): T {\n  const instance = baseDirectiveCreate(directiveDefIdx, directive, directiveDef);\n\n  ngDevMode && assertDefined(previousOrParentNode.tNode, 'previousOrParentNode.tNode');\n  const tNode = previousOrParentNode.tNode;\n\n  const isComponent = (directiveDef as ComponentDefInternal<T>).template;\n  if (isComponent) {\n    addComponentLogic(directiveDefIdx, directive, directiveDef as ComponentDefInternal<T>);\n  }\n\n  if (firstTemplatePass) {\n    // Init hooks are queued now so ngOnInit is called in host components before\n    // any projected components.\n    queueInitHooks(directiveDefIdx, directiveDef.onInit, directiveDef.doCheck, tView);\n\n    if (directiveDef.hostBindings) queueHostBindingForCheck(directiveDefIdx, directiveDef.hostVars);\n  }\n\n  if (tNode && tNode.attrs) {\n    setInputsFromAttrs(directiveDefIdx, instance, directiveDef.inputs, tNode);\n  }\n\n  if (directiveDef.contentQueries) {\n    directiveDef.contentQueries();\n  }\n\n  return instance;\n}\n\nfunction addComponentLogic<T>(\n    directiveIndex: number, instance: T, def: ComponentDefInternal<T>): void {\n  const tView = getOrCreateTView(\n      def.template, def.consts, def.vars, def.directiveDefs, def.pipeDefs, def.viewQuery);\n\n  // Only component views should be added to the view tree directly. Embedded views are\n  // accessed through their containers because they may be removed / re-added later.\n  const componentView = addToViewTree(\n      viewData, previousOrParentNode.tNode.index as number,\n      createLViewData(\n          rendererFactory.createRenderer(previousOrParentNode.native as RElement, def), tView,\n          instance, def.onPush ? LViewFlags.Dirty : LViewFlags.CheckAlways, getCurrentSanitizer()));\n\n  // We need to set the host node/data here because when the component LNode was created,\n  // we didn't yet know it was a component (just an element).\n  (previousOrParentNode as{data: LViewData}).data = componentView;\n  (componentView as LViewData)[HOST_NODE] = previousOrParentNode as LElementNode;\n\n  initChangeDetectorIfExisting(previousOrParentNode.nodeInjector, instance, componentView);\n\n  if (firstTemplatePass) queueComponentIndexForCheck();\n}\n\n/**\n * A lighter version of directiveCreate() that is used for the root component\n *\n * This version does not contain features that we don't already support at root in\n * current Angular. Example: local refs and inputs on root component.\n */\nexport function baseDirectiveCreate<T>(\n    index: number, directive: T,\n    directiveDef: DirectiveDefInternal<T>| ComponentDefInternal<T>): T {\n  ngDevMode && assertEqual(\n                   viewData[BINDING_INDEX], tView.bindingStartIndex,\n                   'directives should be created before any bindings');\n  ngDevMode && assertPreviousIsParent();\n\n  Object.defineProperty(\n      directive, NG_HOST_SYMBOL, {enumerable: false, value: previousOrParentNode});\n\n  if (directives == null) viewData[DIRECTIVES] = directives = [];\n\n  ngDevMode && assertDataNext(index, directives);\n  directives[index] = directive;\n\n  if (firstTemplatePass) {\n    const flags = previousOrParentNode.tNode.flags;\n    if ((flags & TNodeFlags.DirectiveCountMask) === 0) {\n      // When the first directive is created:\n      // - save the index,\n      // - set the number of directives to 1\n      previousOrParentNode.tNode.flags =\n          index << TNodeFlags.DirectiveStartingIndexShift | flags & TNodeFlags.isComponent | 1;\n    } else {\n      // Only need to bump the size when subsequent directives are created\n      ngDevMode && assertNotEqual(\n                       flags & TNodeFlags.DirectiveCountMask, TNodeFlags.DirectiveCountMask,\n                       'Reached the max number of directives');\n      previousOrParentNode.tNode.flags++;\n    }\n  } else {\n    const diPublic = directiveDef !.diPublic;\n    if (diPublic) diPublic(directiveDef !);\n  }\n\n  if (directiveDef !.attributes != null && previousOrParentNode.tNode.type == TNodeType.Element) {\n    setUpAttributes(\n        (previousOrParentNode as LElementNode).native, directiveDef !.attributes as string[]);\n  }\n\n  return directive;\n}\n\n/**\n * Sets initial input properties on directive instances from attribute data\n *\n * @param directiveIndex Index of the directive in directives array\n * @param instance Instance of the directive on which to set the initial inputs\n * @param inputs The list of inputs from the directive def\n * @param tNode The static data for this node\n */\nfunction setInputsFromAttrs<T>(\n    directiveIndex: number, instance: T, inputs: {[P in keyof T]: string;}, tNode: TNode): void {\n  let initialInputData = tNode.initialInputs as InitialInputData | undefined;\n  if (initialInputData === undefined || directiveIndex >= initialInputData.length) {\n    initialInputData = generateInitialInputs(directiveIndex, inputs, tNode);\n  }\n\n  const initialInputs: InitialInputs|null = initialInputData[directiveIndex];\n  if (initialInputs) {\n    for (let i = 0; i < initialInputs.length; i += 2) {\n      (instance as any)[initialInputs[i]] = initialInputs[i + 1];\n    }\n  }\n}\n\n/**\n * Generates initialInputData for a node and stores it in the template's static storage\n * so subsequent template invocations don't have to recalculate it.\n *\n * initialInputData is an array containing values that need to be set as input properties\n * for directives on this node, but only once on creation. We need this array to support\n * the case where you set an @Input property of a directive using attribute-like syntax.\n * e.g. if you have a `name` @Input, you can set it once like this:\n *\n * <my-component name=\"Bess\"></my-component>\n *\n * @param directiveIndex Index to store the initial input data\n * @param inputs The list of inputs from the directive def\n * @param tNode The static data on this node\n */\nfunction generateInitialInputs(\n    directiveIndex: number, inputs: {[key: string]: string}, tNode: TNode): InitialInputData {\n  const initialInputData: InitialInputData = tNode.initialInputs || (tNode.initialInputs = []);\n  initialInputData[directiveIndex] = null;\n\n  const attrs = tNode.attrs !;\n  let i = 0;\n  while (i < attrs.length) {\n    const attrName = attrs[i];\n    if (attrName === AttributeMarker.SelectOnly) break;\n    if (attrName === AttributeMarker.NamespaceURI) {\n      // We do not allow inputs on namespaced attributes.\n      i += 4;\n      continue;\n    }\n    const minifiedInputName = inputs[attrName];\n    const attrValue = attrs[i + 1];\n\n    if (minifiedInputName !== undefined) {\n      const inputsToStore: InitialInputs =\n          initialInputData[directiveIndex] || (initialInputData[directiveIndex] = []);\n      inputsToStore.push(minifiedInputName, attrValue as string);\n    }\n\n    i += 2;\n  }\n  return initialInputData;\n}\n\n//////////////////////////\n//// ViewContainer & View\n//////////////////////////\n\n/**\n * Creates a LContainer, either from a container instruction, or for a ViewContainerRef.\n *\n * @param parentLNode the LNode in which the container's content will be rendered\n * @param currentView The parent view of the LContainer\n * @param isForViewContainerRef Optional a flag indicating the ViewContainerRef case\n * @returns LContainer\n */\nexport function createLContainer(\n    parentLNode: LNode, currentView: LViewData, isForViewContainerRef?: boolean): LContainer {\n  ngDevMode && assertDefined(parentLNode, 'containers should have a parent');\n  let renderParent = canInsertNativeNode(parentLNode, currentView) ?\n      parentLNode as LElementNode | LViewNode :\n      null;\n  if (renderParent && renderParent.tNode.type === TNodeType.View) {\n    renderParent = getParentLNode(renderParent as LViewNode) !.data[RENDER_PARENT];\n  }\n  return [\n    isForViewContainerRef ? null : 0,  // active index\n    currentView,                       // parent\n    null,                              // next\n    null,                              // queries\n    [],                                // views\n    renderParent as LElementNode\n  ];\n}\n\n/**\n * Creates an LContainerNode for an ng-template (dynamically-inserted view), e.g.\n *\n * <ng-template #foo>\n *    <div></div>\n * </ng-template>\n *\n * @param index The index of the container in the data array\n * @param templateFn Inline template\n * @param consts The number of nodes, local refs, and pipes for this template\n * @param vars The number of bindings for this template\n * @param tagName The name of the container element, if applicable\n * @param attrs The attrs attached to the container, if applicable\n * @param localRefs A set of local reference bindings on the element.\n * @param localRefExtractor A function which extracts local-refs values from the template.\n *        Defaults to the current element associated with the local-ref.\n */\nexport function template(\n    index: number, templateFn: ComponentTemplate<any>| null, consts: number, vars: number,\n    tagName?: string | null, attrs?: TAttributes | null, localRefs?: string[] | null,\n    localRefExtractor?: LocalRefExtractor) {\n  // TODO: consider a separate node type for templates\n  const node = containerInternal(index, tagName || null, attrs || null, localRefs || null);\n\n  if (firstTemplatePass) {\n    node.tNode.tViews = createTView(\n        -1, templateFn, consts, vars, tView.directiveRegistry, tView.pipeRegistry, null);\n  }\n\n  createDirectivesAndLocals(node, localRefs, localRefExtractor);\n  currentQueries && (currentQueries = currentQueries.addNode(node));\n  queueLifecycleHooks(node.tNode.flags, tView);\n  isParent = false;\n}\n\n/**\n * Creates an LContainerNode for inline views, e.g.\n *\n * % if (showing) {\n *   <div></div>\n * % }\n *\n * @param index The index of the container in the data array\n */\nexport function container(index: number): void {\n  const node = containerInternal(index, null, null, null);\n  firstTemplatePass && (node.tNode.tViews = []);\n  isParent = false;\n}\n\nfunction containerInternal(\n    index: number, tagName: string | null, attrs: TAttributes | null,\n    localRefs: string[] | null): LContainerNode {\n  ngDevMode && assertEqual(\n                   viewData[BINDING_INDEX], tView.bindingStartIndex,\n                   'container nodes should be created before any bindings');\n\n  const currentParent = isParent ? previousOrParentNode : getParentLNode(previousOrParentNode) !;\n  const lContainer = createLContainer(currentParent, viewData);\n\n  ngDevMode && ngDevMode.rendererCreateComment++;\n  const comment = renderer.createComment(ngDevMode ? 'container' : '');\n  const node = createLNode(index, TNodeType.Container, comment, tagName, attrs, lContainer);\n  appendChild(getParentLNode(node), comment, viewData);\n\n  // Containers are added to the current view tree instead of their embedded views\n  // because views can be removed and re-inserted.\n  addToViewTree(viewData, index + HEADER_OFFSET, node.data);\n\n  if (currentQueries) {\n    // prepare place for matching nodes from views inserted into a given container\n    lContainer[QUERIES] = currentQueries.container();\n  }\n\n  ngDevMode && assertNodeType(previousOrParentNode, TNodeType.Container);\n  return node;\n}\n\n/**\n * Sets a container up to receive views.\n *\n * @param index The index of the container in the data array\n */\nexport function containerRefreshStart(index: number): void {\n  previousOrParentNode = loadElement(index) as LNode;\n  ngDevMode && assertNodeType(previousOrParentNode, TNodeType.Container);\n  isParent = true;\n  (previousOrParentNode as LContainerNode).data[ACTIVE_INDEX] = 0;\n\n  if (!checkNoChangesMode) {\n    // We need to execute init hooks here so ngOnInit hooks are called in top level views\n    // before they are called in embedded views (for backwards compatibility).\n    executeInitHooks(viewData, tView, creationMode);\n  }\n}\n\n/**\n * Marks the end of the LContainerNode.\n *\n * Marking the end of LContainerNode is the time when to child Views get inserted or removed.\n */\nexport function containerRefreshEnd(): void {\n  if (isParent) {\n    isParent = false;\n  } else {\n    ngDevMode && assertNodeType(previousOrParentNode, TNodeType.View);\n    ngDevMode && assertHasParent();\n    previousOrParentNode = getParentLNode(previousOrParentNode) !;\n  }\n  ngDevMode && assertNodeType(previousOrParentNode, TNodeType.Container);\n  const container = previousOrParentNode as LContainerNode;\n  ngDevMode && assertNodeType(container, TNodeType.Container);\n  const nextIndex = container.data[ACTIVE_INDEX] !;\n\n  // remove extra views at the end of the container\n  while (nextIndex < container.data[VIEWS].length) {\n    removeView(container, nextIndex);\n  }\n}\n\n/**\n * Goes over dynamic embedded views (ones created through ViewContainerRef APIs) and refreshes them\n * by executing an associated template function.\n */\nfunction refreshDynamicEmbeddedViews(lViewData: LViewData) {\n  for (let current = getLViewChild(lViewData); current !== null; current = current[NEXT]) {\n    // Note: current can be an LViewData or an LContainer instance, but here we are only interested\n    // in LContainer. We can tell it's an LContainer because its length is less than the LViewData\n    // header.\n    if (current.length < HEADER_OFFSET && current[ACTIVE_INDEX] === null) {\n      const container = current as LContainer;\n      for (let i = 0; i < container[VIEWS].length; i++) {\n        const lViewNode = container[VIEWS][i];\n        // The directives and pipes are not needed here as an existing view is only being refreshed.\n        const dynamicViewData = lViewNode.data;\n        ngDevMode && assertDefined(dynamicViewData[TVIEW], 'TView must be allocated');\n        renderEmbeddedTemplate(\n            lViewNode, dynamicViewData[TVIEW], dynamicViewData[CONTEXT] !, RenderFlags.Update);\n      }\n    }\n  }\n}\n\n\n/**\n * Looks for a view with a given view block id inside a provided LContainer.\n * Removes views that need to be deleted in the process.\n *\n * @param containerNode where to search for views\n * @param startIdx starting index in the views array to search from\n * @param viewBlockId exact view block id to look for\n * @returns index of a found view or -1 if not found\n */\nfunction scanForView(\n    containerNode: LContainerNode, startIdx: number, viewBlockId: number): LViewNode|null {\n  const views = containerNode.data[VIEWS];\n  for (let i = startIdx; i < views.length; i++) {\n    const viewAtPositionId = views[i].data[TVIEW].id;\n    if (viewAtPositionId === viewBlockId) {\n      return views[i];\n    } else if (viewAtPositionId < viewBlockId) {\n      // found a view that should not be at this position - remove\n      removeView(containerNode, i);\n    } else {\n      // found a view with id greater than the one we are searching for\n      // which means that required view doesn't exist and can't be found at\n      // later positions in the views array - stop the search here\n      break;\n    }\n  }\n  return null;\n}\n\n/**\n * Marks the start of an embedded view.\n *\n * @param viewBlockId The ID of this view\n * @return boolean Whether or not this view is in creation mode\n */\nexport function embeddedViewStart(viewBlockId: number, consts: number, vars: number): RenderFlags {\n  const container =\n      (isParent ? previousOrParentNode : getParentLNode(previousOrParentNode)) as LContainerNode;\n  ngDevMode && assertNodeType(container, TNodeType.Container);\n  const lContainer = container.data;\n  let viewNode: LViewNode|null = scanForView(container, lContainer[ACTIVE_INDEX] !, viewBlockId);\n\n  if (viewNode) {\n    previousOrParentNode = viewNode;\n    ngDevMode && assertNodeType(previousOrParentNode, TNodeType.View);\n    isParent = true;\n    enterView(viewNode.data, viewNode);\n  } else {\n    // When we create a new LView, we always reset the state of the instructions.\n    const newView = createLViewData(\n        renderer, getOrCreateEmbeddedTView(viewBlockId, consts, vars, container), null,\n        LViewFlags.CheckAlways, getCurrentSanitizer());\n\n    if (lContainer[QUERIES]) {\n      newView[QUERIES] = lContainer[QUERIES] !.createView();\n    }\n\n    enterView(\n        newView, viewNode = createLNode(viewBlockId, TNodeType.View, null, null, null, newView));\n  }\n  if (container) {\n    if (creationMode) {\n      // it is a new view, insert it into collection of views for a given container\n      insertView(container, viewNode, lContainer[ACTIVE_INDEX] !);\n    }\n    lContainer[ACTIVE_INDEX] !++;\n  }\n  return getRenderFlags(viewNode.data);\n}\n\n/**\n * Initialize the TView (e.g. static data) for the active embedded view.\n *\n * Each embedded view block must create or retrieve its own TView. Otherwise, the embedded view's\n * static data for a particular node would overwrite the static data for a node in the view above\n * it with the same index (since it's in the same template).\n *\n * @param viewIndex The index of the TView in TNode.tViews\n * @param consts The number of nodes, local refs, and pipes in this template\n * @param vars The number of bindings and pure function bindings in this template\n * @param parent The parent container in which to look for the view's static data\n * @returns TView\n */\nfunction getOrCreateEmbeddedTView(\n    viewIndex: number, consts: number, vars: number, parent: LContainerNode): TView {\n  ngDevMode && assertNodeType(parent, TNodeType.Container);\n  const containerTViews = (parent !.tNode as TContainerNode).tViews as TView[];\n  ngDevMode && assertDefined(containerTViews, 'TView expected');\n  ngDevMode && assertEqual(Array.isArray(containerTViews), true, 'TViews should be in an array');\n  if (viewIndex >= containerTViews.length || containerTViews[viewIndex] == null) {\n    containerTViews[viewIndex] = createTView(\n        viewIndex, null, consts, vars, tView.directiveRegistry, tView.pipeRegistry, null);\n  }\n  return containerTViews[viewIndex];\n}\n\n/** Marks the end of an embedded view. */\nexport function embeddedViewEnd(): void {\n  refreshDescendantViews();\n  isParent = false;\n  previousOrParentNode = viewData[HOST_NODE] as LViewNode;\n  leaveView(viewData[PARENT] !);\n  ngDevMode && assertEqual(isParent, false, 'isParent');\n  ngDevMode && assertNodeType(previousOrParentNode, TNodeType.View);\n}\n\n/////////////\n\n/**\n * Refreshes components by entering the component view and processing its bindings, queries, etc.\n *\n * @param adjustedElementIndex  Element index in LViewData[] (adjusted for HEADER_OFFSET)\n */\nexport function componentRefresh<T>(adjustedElementIndex: number): void {\n  ngDevMode && assertDataInRange(adjustedElementIndex);\n  const element = viewData[adjustedElementIndex] as LElementNode;\n  ngDevMode && assertNodeType(element, TNodeType.Element);\n  ngDevMode &&\n      assertDefined(element.data, `Component's host node should have an LViewData attached.`);\n  const hostView = element.data !;\n\n  // Only attached CheckAlways components or attached, dirty OnPush components should be checked\n  if (viewAttached(hostView) && hostView[FLAGS] & (LViewFlags.CheckAlways | LViewFlags.Dirty)) {\n    detectChangesInternal(hostView, element, hostView[CONTEXT]);\n  }\n}\n\n/** Returns a boolean for whether the view is attached */\nexport function viewAttached(view: LViewData): boolean {\n  return (view[FLAGS] & LViewFlags.Attached) === LViewFlags.Attached;\n}\n\n/**\n * Instruction to distribute projectable nodes among <ng-content> occurrences in a given template.\n * It takes all the selectors from the entire component's template and decides where\n * each projected node belongs (it re-distributes nodes among \"buckets\" where each \"bucket\" is\n * backed by a selector).\n *\n * This function requires CSS selectors to be provided in 2 forms: parsed (by a compiler) and text,\n * un-parsed form.\n *\n * The parsed form is needed for efficient matching of a node against a given CSS selector.\n * The un-parsed, textual form is needed for support of the ngProjectAs attribute.\n *\n * Having a CSS selector in 2 different formats is not ideal, but alternatives have even more\n * drawbacks:\n * - having only a textual form would require runtime parsing of CSS selectors;\n * - we can't have only a parsed as we can't re-construct textual form from it (as entered by a\n * template author).\n *\n * @param selectors A collection of parsed CSS selectors\n * @param rawSelectors A collection of CSS selectors in the raw, un-parsed form\n */\nexport function projectionDef(selectors?: CssSelectorList[], textSelectors?: string[]): void {\n  const componentNode: LElementNode = findComponentHost(viewData);\n\n  if (!componentNode.tNode.projection) {\n    const noOfNodeBuckets = selectors ? selectors.length + 1 : 1;\n    const pData: (TNode | null)[] = componentNode.tNode.projection =\n        new Array(noOfNodeBuckets).fill(null);\n    const tails: (TNode | null)[] = pData.slice();\n\n    let componentChild = componentNode.tNode.child;\n\n    while (componentChild !== null) {\n      const bucketIndex =\n          selectors ? matchingSelectorIndex(componentChild, selectors, textSelectors !) : 0;\n      const nextNode = componentChild.next;\n\n      if (tails[bucketIndex]) {\n        tails[bucketIndex] !.next = componentChild;\n      } else {\n        pData[bucketIndex] = componentChild;\n        componentChild.next = null;\n      }\n      tails[bucketIndex] = componentChild;\n\n      componentChild = nextNode;\n    }\n  }\n}\n\n/**\n * Stack used to keep track of projection nodes in projection() instruction.\n *\n * This is deliberately created outside of projection() to avoid allocating\n * a new array each time the function is called. Instead the array will be\n * re-used by each invocation. This works because the function is not reentrant.\n */\nconst projectionNodeStack: LProjectionNode[] = [];\n\n/**\n * Inserts previously re-distributed projected nodes. This instruction must be preceded by a call\n * to the projectionDef instruction.\n *\n * @param nodeIndex\n * @param selectorIndex:\n *        - 0 when the selector is `*` (or unspecified as this is the default value),\n *        - 1 based index of the selector from the {@link projectionDef}\n */\nexport function projection(nodeIndex: number, selectorIndex: number = 0, attrs?: string[]): void {\n  const node = createLNode(nodeIndex, TNodeType.Projection, null, null, attrs || null, null);\n\n  // We can't use viewData[HOST_NODE] because projection nodes can be nested in embedded views.\n  if (node.tNode.projection === null) node.tNode.projection = selectorIndex;\n\n  // `<ng-content>` has no content\n  isParent = false;\n\n  // re-distribution of projectable nodes is stored on a component's view level\n  const parent = getParentLNode(node);\n\n  if (canInsertNativeNode(parent, viewData)) {\n    const componentNode = findComponentHost(viewData);\n    let nodeToProject = (componentNode.tNode.projection as(TNode | null)[])[selectorIndex];\n    let projectedView = componentNode.view;\n    let projectionNodeIndex = -1;\n    let grandparent: LContainerNode;\n    const renderParent = parent.tNode.type === TNodeType.View ?\n        (grandparent = getParentLNode(parent) as LContainerNode) &&\n            grandparent.data[RENDER_PARENT] ! :\n        parent as LElementNode;\n\n    const parentView = viewData[HOST_NODE].view;\n    while (nodeToProject) {\n      if (nodeToProject.type === TNodeType.Projection) {\n        // This node is re-projected, so we must go up the tree to get its projected nodes.\n        const currentComponentHost = findComponentHost(projectedView);\n        const firstProjectedNode = (currentComponentHost.tNode.projection as(\n            TNode | null)[])[nodeToProject.projection as number];\n\n        if (firstProjectedNode) {\n          projectionNodeStack[++projectionNodeIndex] = projectedView[nodeToProject.index];\n          nodeToProject = firstProjectedNode;\n          projectedView = currentComponentHost.view;\n          continue;\n        }\n      } else {\n        const lNode = projectedView[nodeToProject.index];\n        lNode.tNode.flags |= TNodeFlags.isProjected;\n        appendProjectedNode(\n            lNode as LTextNode | LElementNode | LContainerNode, parent, viewData, renderParent,\n            parentView);\n      }\n\n      // If we are finished with a list of re-projected nodes, we need to get\n      // back to the root projection node that was re-projected.\n      if (nodeToProject.next === null && projectedView !== componentNode.view) {\n        // move down into the view of the component we're projecting right now\n        const lNode = projectionNodeStack[projectionNodeIndex--];\n        nodeToProject = lNode.tNode;\n        projectedView = lNode.view;\n      }\n      nodeToProject = nodeToProject.next;\n    }\n  }\n}\n\n/**\n * Adds LViewData or LContainer to the end of the current view tree.\n *\n * This structure will be used to traverse through nested views to remove listeners\n * and call onDestroy callbacks.\n *\n * @param currentView The view where LViewData or LContainer should be added\n * @param adjustedHostIndex Index of the view's host node in LViewData[], adjusted for header\n * @param state The LViewData or LContainer to add to the view tree\n * @returns The state passed in\n */\nexport function addToViewTree<T extends LViewData|LContainer>(\n    currentView: LViewData, adjustedHostIndex: number, state: T): T {\n  if (currentView[TAIL]) {\n    currentView[TAIL] ![NEXT] = state;\n  } else if (firstTemplatePass) {\n    tView.childIndex = adjustedHostIndex;\n  }\n  currentView[TAIL] = state;\n  return state;\n}\n\n///////////////////////////////\n//// Change detection\n///////////////////////////////\n\n/** If node is an OnPush component, marks its LViewData dirty. */\nexport function markDirtyIfOnPush(node: LElementNode): void {\n  // Because data flows down the component tree, ancestors do not need to be marked dirty\n  if (node.data && !(node.data[FLAGS] & LViewFlags.CheckAlways)) {\n    node.data[FLAGS] |= LViewFlags.Dirty;\n  }\n}\n\n/**\n * Wraps an event listener so its host view and its ancestor views will be marked dirty\n * whenever the event fires. Necessary to support OnPush components.\n */\nexport function wrapListenerWithDirtyLogic(\n    view: LViewData, listenerFn: (e?: any) => any): (e: Event) => any {\n  return function(e: any) {\n    markViewDirty(view);\n    return listenerFn(e);\n  };\n}\n\n/**\n * Wraps an event listener so its host view and its ancestor views will be marked dirty\n * whenever the event fires. Also wraps with preventDefault behavior.\n */\nexport function wrapListenerWithDirtyAndDefault(\n    view: LViewData, listenerFn: (e?: any) => any): EventListener {\n  return function wrapListenerIn_markViewDirty(e: Event) {\n    markViewDirty(view);\n    if (listenerFn(e) === false) {\n      e.preventDefault();\n      // Necessary for legacy browsers that don't support preventDefault (e.g. IE)\n      e.returnValue = false;\n    }\n  };\n}\n\n/** Marks current view and all ancestors dirty */\nexport function markViewDirty(view: LViewData): void {\n  let currentView: LViewData = view;\n\n  while (currentView[PARENT] != null) {\n    currentView[FLAGS] |= LViewFlags.Dirty;\n    currentView = currentView[PARENT] !;\n  }\n  currentView[FLAGS] |= LViewFlags.Dirty;\n  ngDevMode && assertDefined(currentView[CONTEXT], 'rootContext');\n  scheduleTick(currentView[CONTEXT] as RootContext);\n}\n\n\n/**\n * Used to schedule change detection on the whole application.\n *\n * Unlike `tick`, `scheduleTick` coalesces multiple calls into one change detection run.\n * It is usually called indirectly by calling `markDirty` when the view needs to be\n * re-rendered.\n *\n * Typically `scheduleTick` uses `requestAnimationFrame` to coalesce multiple\n * `scheduleTick` requests. The scheduling function can be overridden in\n * `renderComponent`'s `scheduler` option.\n */\nexport function scheduleTick<T>(rootContext: RootContext) {\n  if (rootContext.clean == _CLEAN_PROMISE) {\n    let res: null|((val: null) => void);\n    rootContext.clean = new Promise<null>((r) => res = r);\n    rootContext.scheduler(() => {\n      tickRootContext(rootContext);\n      res !(null);\n      rootContext.clean = _CLEAN_PROMISE;\n    });\n  }\n}\n\n/**\n * Used to perform change detection on the whole application.\n *\n * This is equivalent to `detectChanges`, but invoked on root component. Additionally, `tick`\n * executes lifecycle hooks and conditionally checks components based on their\n * `ChangeDetectionStrategy` and dirtiness.\n *\n * The preferred way to trigger change detection is to call `markDirty`. `markDirty` internally\n * schedules `tick` using a scheduler in order to coalesce multiple `markDirty` calls into a\n * single change detection run. By default, the scheduler is `requestAnimationFrame`, but can\n * be changed when calling `renderComponent` and providing the `scheduler` option.\n */\nexport function tick<T>(component: T): void {\n  const rootView = getRootView(component);\n  const rootContext = rootView[CONTEXT] as RootContext;\n  tickRootContext(rootContext);\n}\n\nfunction tickRootContext(rootContext: RootContext) {\n  for (let i = 0; i < rootContext.components.length; i++) {\n    const rootComponent = rootContext.components[i];\n    const hostNode = _getComponentHostLElementNode(rootComponent);\n\n    ngDevMode && assertDefined(hostNode.data, 'Component host node should be attached to an LView');\n    renderComponentOrTemplate(hostNode, getRootView(rootComponent), rootComponent);\n  }\n}\n\n/**\n * Retrieve the root view from any component by walking the parent `LViewData` until\n * reaching the root `LViewData`.\n *\n * @param component any component\n */\n\nexport function getRootView(component: any): LViewData {\n  ngDevMode && assertDefined(component, 'component');\n  const lElementNode = _getComponentHostLElementNode(component);\n  let lViewData = lElementNode.view;\n  while (lViewData[PARENT]) {\n    lViewData = lViewData[PARENT] !;\n  }\n  return lViewData;\n}\n\n/**\n * Synchronously perform change detection on a component (and possibly its sub-components).\n *\n * This function triggers change detection in a synchronous way on a component. There should\n * be very little reason to call this function directly since a preferred way to do change\n * detection is to {@link markDirty} the component and wait for the scheduler to call this method\n * at some future point in time. This is because a single user action often results in many\n * components being invalidated and calling change detection on each component synchronously\n * would be inefficient. It is better to wait until all components are marked as dirty and\n * then perform single change detection across all of the components\n *\n * @param component The component which the change detection should be performed on.\n */\nexport function detectChanges<T>(component: T): void {\n  const hostNode = _getComponentHostLElementNode(component);\n  ngDevMode &&\n      assertDefined(\n          hostNode.data, 'Component host node should be attached to an LViewData instance.');\n  detectChangesInternal(hostNode.data as LViewData, hostNode, component);\n}\n\n/**\n * Synchronously perform change detection on a root view and its components.\n *\n * @param lViewData The view which the change detection should be performed on.\n */\nexport function detectChangesInRootView(lViewData: LViewData): void {\n  tickRootContext(lViewData[CONTEXT] as RootContext);\n}\n\n\n/**\n * Checks the change detector and its children, and throws if any changes are detected.\n *\n * This is used in development mode to verify that running change detection doesn't\n * introduce other changes.\n */\nexport function checkNoChanges<T>(component: T): void {\n  checkNoChangesMode = true;\n  try {\n    detectChanges(component);\n  } finally {\n    checkNoChangesMode = false;\n  }\n}\n\n/**\n * Checks the change detector on a root view and its components, and throws if any changes are\n * detected.\n *\n * This is used in development mode to verify that running change detection doesn't\n * introduce other changes.\n *\n * @param lViewData The view which the change detection should be checked on.\n */\nexport function checkNoChangesInRootView(lViewData: LViewData): void {\n  checkNoChangesMode = true;\n  try {\n    detectChangesInRootView(lViewData);\n  } finally {\n    checkNoChangesMode = false;\n  }\n}\n\n/** Checks the view of the component provided. Does not gate on dirty checks or execute doCheck. */\nexport function detectChangesInternal<T>(\n    hostView: LViewData, hostNode: LElementNode, component: T) {\n  const oldView = enterView(hostView, hostNode);\n  const hostTView = hostView[TVIEW];\n  const templateFn = hostTView.template !;\n  const viewQuery = hostTView.viewQuery;\n\n  try {\n    namespaceHTML();\n    createViewQuery(viewQuery, hostView[FLAGS], component);\n    templateFn(getRenderFlags(hostView), component);\n    refreshDescendantViews();\n    updateViewQuery(viewQuery, component);\n  } finally {\n    leaveView(oldView);\n  }\n}\n\nfunction createViewQuery<T>(\n    viewQuery: ComponentQuery<{}>| null, flags: LViewFlags, component: T): void {\n  if (viewQuery && (flags & LViewFlags.CreationMode)) {\n    viewQuery(RenderFlags.Create, component);\n  }\n}\n\nfunction updateViewQuery<T>(viewQuery: ComponentQuery<{}>| null, component: T): void {\n  if (viewQuery) {\n    viewQuery(RenderFlags.Update, component);\n  }\n}\n\n\n/**\n * Mark the component as dirty (needing change detection).\n *\n * Marking a component dirty will schedule a change detection on this\n * component at some point in the future. Marking an already dirty\n * component as dirty is a noop. Only one outstanding change detection\n * can be scheduled per component tree. (Two components bootstrapped with\n * separate `renderComponent` will have separate schedulers)\n *\n * When the root component is bootstrapped with `renderComponent`, a scheduler\n * can be provided.\n *\n * @param component Component to mark as dirty.\n */\nexport function markDirty<T>(component: T) {\n  ngDevMode && assertDefined(component, 'component');\n  const lElementNode = _getComponentHostLElementNode(component);\n  markViewDirty(lElementNode.view);\n}\n\n///////////////////////////////\n//// Bindings & interpolations\n///////////////////////////////\n\nexport interface NO_CHANGE {\n  // This is a brand that ensures that this type can never match anything else\n  brand: 'NO_CHANGE';\n}\n\n/** A special value which designates that a value has not changed. */\nexport const NO_CHANGE = {} as NO_CHANGE;\n\n/**\n * Creates a single value binding.\n *\n * @param value Value to diff\n */\nexport function bind<T>(value: T): T|NO_CHANGE {\n  return bindingUpdated(viewData[BINDING_INDEX]++, value) ? value : NO_CHANGE;\n}\n\n/**\n * Create interpolation bindings with a variable number of expressions.\n *\n * If there are 1 to 8 expressions `interpolation1()` to `interpolation8()` should be used instead.\n * Those are faster because there is no need to create an array of expressions and iterate over it.\n *\n * `values`:\n * - has static text at even indexes,\n * - has evaluated expressions at odd indexes.\n *\n * Returns the concatenated string when any of the arguments changes, `NO_CHANGE` otherwise.\n */\nexport function interpolationV(values: any[]): string|NO_CHANGE {\n  ngDevMode && assertLessThan(2, values.length, 'should have at least 3 values');\n  ngDevMode && assertEqual(values.length % 2, 1, 'should have an odd number of values');\n  let different = false;\n\n  for (let i = 1; i < values.length; i += 2) {\n    // Check if bindings (odd indexes) have changed\n    bindingUpdated(viewData[BINDING_INDEX]++, values[i]) && (different = true);\n  }\n\n  if (!different) {\n    return NO_CHANGE;\n  }\n\n  // Build the updated content\n  let content = values[0];\n  for (let i = 1; i < values.length; i += 2) {\n    content += stringify(values[i]) + values[i + 1];\n  }\n\n  return content;\n}\n\n/**\n * Creates an interpolation binding with 1 expression.\n *\n * @param prefix static value used for concatenation only.\n * @param v0 value checked for change.\n * @param suffix static value used for concatenation only.\n */\nexport function interpolation1(prefix: string, v0: any, suffix: string): string|NO_CHANGE {\n  const different = bindingUpdated(viewData[BINDING_INDEX]++, v0);\n  return different ? prefix + stringify(v0) + suffix : NO_CHANGE;\n}\n\n/** Creates an interpolation binding with 2 expressions. */\nexport function interpolation2(\n    prefix: string, v0: any, i0: string, v1: any, suffix: string): string|NO_CHANGE {\n  const different = bindingUpdated2(viewData[BINDING_INDEX], v0, v1);\n  viewData[BINDING_INDEX] += 2;\n\n  return different ? prefix + stringify(v0) + i0 + stringify(v1) + suffix : NO_CHANGE;\n}\n\n/** Creates an interpolation binding with 3 expressions. */\nexport function interpolation3(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, suffix: string): string|\n    NO_CHANGE {\n  const different = bindingUpdated3(viewData[BINDING_INDEX], v0, v1, v2);\n  viewData[BINDING_INDEX] += 3;\n\n  return different ? prefix + stringify(v0) + i0 + stringify(v1) + i1 + stringify(v2) + suffix :\n                     NO_CHANGE;\n}\n\n/** Create an interpolation binding with 4 expressions. */\nexport function interpolation4(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    suffix: string): string|NO_CHANGE {\n  const different = bindingUpdated4(viewData[BINDING_INDEX], v0, v1, v2, v3);\n  viewData[BINDING_INDEX] += 4;\n\n  return different ?\n      prefix + stringify(v0) + i0 + stringify(v1) + i1 + stringify(v2) + i2 + stringify(v3) +\n          suffix :\n      NO_CHANGE;\n}\n\n/** Creates an interpolation binding with 5 expressions. */\nexport function interpolation5(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    i3: string, v4: any, suffix: string): string|NO_CHANGE {\n  let different = bindingUpdated4(viewData[BINDING_INDEX], v0, v1, v2, v3);\n  different = bindingUpdated(viewData[BINDING_INDEX] + 4, v4) || different;\n  viewData[BINDING_INDEX] += 5;\n\n  return different ?\n      prefix + stringify(v0) + i0 + stringify(v1) + i1 + stringify(v2) + i2 + stringify(v3) + i3 +\n          stringify(v4) + suffix :\n      NO_CHANGE;\n}\n\n/** Creates an interpolation binding with 6 expressions. */\nexport function interpolation6(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    i3: string, v4: any, i4: string, v5: any, suffix: string): string|NO_CHANGE {\n  let different = bindingUpdated4(viewData[BINDING_INDEX], v0, v1, v2, v3);\n  different = bindingUpdated2(viewData[BINDING_INDEX] + 4, v4, v5) || different;\n  viewData[BINDING_INDEX] += 6;\n\n  return different ?\n      prefix + stringify(v0) + i0 + stringify(v1) + i1 + stringify(v2) + i2 + stringify(v3) + i3 +\n          stringify(v4) + i4 + stringify(v5) + suffix :\n      NO_CHANGE;\n}\n\n/** Creates an interpolation binding with 7 expressions. */\nexport function interpolation7(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    i3: string, v4: any, i4: string, v5: any, i5: string, v6: any, suffix: string): string|\n    NO_CHANGE {\n  let different = bindingUpdated4(viewData[BINDING_INDEX], v0, v1, v2, v3);\n  different = bindingUpdated3(viewData[BINDING_INDEX] + 4, v4, v5, v6) || different;\n  viewData[BINDING_INDEX] += 7;\n\n  return different ?\n      prefix + stringify(v0) + i0 + stringify(v1) + i1 + stringify(v2) + i2 + stringify(v3) + i3 +\n          stringify(v4) + i4 + stringify(v5) + i5 + stringify(v6) + suffix :\n      NO_CHANGE;\n}\n\n/** Creates an interpolation binding with 8 expressions. */\nexport function interpolation8(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    i3: string, v4: any, i4: string, v5: any, i5: string, v6: any, i6: string, v7: any,\n    suffix: string): string|NO_CHANGE {\n  let different = bindingUpdated4(viewData[BINDING_INDEX], v0, v1, v2, v3);\n  different = bindingUpdated4(viewData[BINDING_INDEX] + 4, v4, v5, v6, v7) || different;\n  viewData[BINDING_INDEX] += 8;\n\n  return different ?\n      prefix + stringify(v0) + i0 + stringify(v1) + i1 + stringify(v2) + i2 + stringify(v3) + i3 +\n          stringify(v4) + i4 + stringify(v5) + i5 + stringify(v6) + i6 + stringify(v7) + suffix :\n      NO_CHANGE;\n}\n\n/** Store a value in the `data` at a given `index`. */\nexport function store<T>(index: number, value: T): void {\n  // We don't store any static data for local variables, so the first time\n  // we see the template, we should store as null to avoid a sparse array\n  const adjustedIndex = index + HEADER_OFFSET;\n  if (adjustedIndex >= tView.data.length) {\n    tView.data[adjustedIndex] = null;\n  }\n  viewData[adjustedIndex] = value;\n}\n\n/**\n * Retrieves a local reference from the current contextViewData.\n *\n * If the reference to retrieve is in a parent view, this instruction is used in conjunction\n * with a nextContext() call, which walks up the tree and updates the contextViewData instance.\n *\n * @param index The index of the local ref in contextViewData.\n */\nexport function reference<T>(index: number) {\n  return loadInternal<T>(index, contextViewData);\n}\n\nfunction walkUpViews(nestingLevel: number, currentView: LViewData): LViewData {\n  while (nestingLevel > 0) {\n    ngDevMode && assertDefined(\n                     currentView[DECLARATION_VIEW],\n                     'Declaration view should be defined if nesting level is greater than 0.');\n    currentView = currentView[DECLARATION_VIEW] !;\n    nestingLevel--;\n  }\n  return currentView;\n}\n\n/** Retrieves a value from the `directives` array. */\nexport function loadDirective<T>(index: number): T {\n  ngDevMode && assertDefined(directives, 'Directives array should be defined if reading a dir.');\n  ngDevMode && assertDataInRange(index, directives !);\n  return directives ![index];\n}\n\nexport function loadQueryList<T>(queryListIdx: number): QueryList<T> {\n  ngDevMode && assertDefined(\n                   viewData[CONTENT_QUERIES],\n                   'Content QueryList array should be defined if reading a query.');\n  ngDevMode && assertDataInRange(queryListIdx, viewData[CONTENT_QUERIES] !);\n\n  return viewData[CONTENT_QUERIES] ![queryListIdx];\n}\n\n/** Retrieves a value from current `viewData`. */\nexport function load<T>(index: number): T {\n  return loadInternal<T>(index, viewData);\n}\n\nexport function loadElement(index: number): LElementNode {\n  return loadElementInternal(index, viewData);\n}\n\n/** Gets the current binding value. */\nexport function getBinding(bindingIndex: number): any {\n  ngDevMode && assertDataInRange(viewData[bindingIndex]);\n  ngDevMode &&\n      assertNotEqual(viewData[bindingIndex], NO_CHANGE, 'Stored value should never be NO_CHANGE.');\n  return viewData[bindingIndex];\n}\n\n/** Updates binding if changed, then returns whether it was updated. */\nexport function bindingUpdated(bindingIndex: number, value: any): boolean {\n  ngDevMode && assertNotEqual(value, NO_CHANGE, 'Incoming value should never be NO_CHANGE.');\n  ngDevMode && assertLessThan(\n                   bindingIndex, viewData.length, `Slot should have been initialized to NO_CHANGE`);\n\n  if (viewData[bindingIndex] === NO_CHANGE) {\n    viewData[bindingIndex] = value;\n  } else if (isDifferent(viewData[bindingIndex], value, checkNoChangesMode)) {\n    throwErrorIfNoChangesMode(creationMode, checkNoChangesMode, viewData[bindingIndex], value);\n    viewData[bindingIndex] = value;\n  } else {\n    return false;\n  }\n  return true;\n}\n\n/** Updates binding and returns the value. */\nexport function updateBinding(bindingIndex: number, value: any): any {\n  return viewData[bindingIndex] = value;\n}\n\n/** Updates 2 bindings if changed, then returns whether either was updated. */\nexport function bindingUpdated2(bindingIndex: number, exp1: any, exp2: any): boolean {\n  const different = bindingUpdated(bindingIndex, exp1);\n  return bindingUpdated(bindingIndex + 1, exp2) || different;\n}\n\n/** Updates 3 bindings if changed, then returns whether any was updated. */\nexport function bindingUpdated3(bindingIndex: number, exp1: any, exp2: any, exp3: any): boolean {\n  const different = bindingUpdated2(bindingIndex, exp1, exp2);\n  return bindingUpdated(bindingIndex + 2, exp3) || different;\n}\n\n/** Updates 4 bindings if changed, then returns whether any was updated. */\nexport function bindingUpdated4(\n    bindingIndex: number, exp1: any, exp2: any, exp3: any, exp4: any): boolean {\n  const different = bindingUpdated2(bindingIndex, exp1, exp2);\n  return bindingUpdated2(bindingIndex + 2, exp3, exp4) || different;\n}\n\nexport function getTView(): TView {\n  return tView;\n}\n\n/**\n * Registers a QueryList, associated with a content query, for later refresh (part of a view\n * refresh).\n */\nexport function registerContentQuery<Q>(queryList: QueryList<Q>): void {\n  const savedContentQueriesLength =\n      (viewData[CONTENT_QUERIES] || (viewData[CONTENT_QUERIES] = [])).push(queryList);\n  if (firstTemplatePass) {\n    const currentDirectiveIndex = directives !.length - 1;\n    const tViewContentQueries = tView.contentQueries || (tView.contentQueries = []);\n    const lastSavedDirectiveIndex =\n        tView.contentQueries.length ? tView.contentQueries[tView.contentQueries.length - 2] : -1;\n    if (currentDirectiveIndex !== lastSavedDirectiveIndex) {\n      tViewContentQueries.push(currentDirectiveIndex, savedContentQueriesLength - 1);\n    }\n  }\n}\n\nexport function assertPreviousIsParent() {\n  assertEqual(isParent, true, 'previousOrParentNode should be a parent');\n}\n\nfunction assertHasParent() {\n  assertDefined(getParentLNode(previousOrParentNode), 'previousOrParentNode should have a parent');\n}\n\nfunction assertDataInRange(index: number, arr?: any[]) {\n  if (arr == null) arr = viewData;\n  assertDataInRangeInternal(index, arr || viewData);\n}\n\nfunction assertDataNext(index: number, arr?: any[]) {\n  if (arr == null) arr = viewData;\n  assertEqual(\n      arr.length, index, `index ${index} expected to be at the end of arr (length ${arr.length})`);\n}\n\nexport function _getComponentHostLElementNode<T>(component: T): LElementNode {\n  ngDevMode && assertDefined(component, 'expecting component got null');\n  const lElementNode = (component as any)[NG_HOST_SYMBOL] as LElementNode;\n  ngDevMode && assertDefined(component, 'object is not a component');\n  return lElementNode;\n}\n\nexport const CLEAN_PROMISE = _CLEAN_PROMISE;\n"]}