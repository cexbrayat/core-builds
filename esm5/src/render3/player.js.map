{"version":3,"file":"player.js","sourceRoot":"","sources":["../../../../../../packages/core/src/render3/player.ts"],"names":[],"mappings":";;;;AAOA,OAAO,EAAC,UAAU,EAAC,MAAM,qBAAqB,CAAC;AAC/C,OAAO,EAAC,YAAY,EAAC,MAAM,gBAAgB,CAAC;AAG5C,OAAO,EAAC,iBAAiB,EAAC,MAAM,+BAA+B,CAAC;AAChE,OAAO,EAAC,wBAAwB,EAAC,MAAM,gBAAgB,CAAC;AACxD,OAAO,EAAC,cAAc,EAAC,MAAM,QAAQ,CAAC;;;;;;AAEtC,MAAM,UAAU,SAAS,CACrB,GAAwD,EAAE,MAAc;;IAC1E,IAAM,cAAc,sBAAG,UAAU,CAAC,GAAG,CAAC,GAAG;;IACzC,IAAM,gBAAgB,sBAAG,wBAAwB,CAAC,cAAc,CAAC,MAAM,EAAE,cAAc,CAAC,GAAG;IAC3F,gBAAgB,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;IAE9B,MAAM,CAAC,gBAAgB,sBAAsB;;QAC3C,IAAM,KAAK,GAAG,gBAAgB,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC;QAC/C,IAAI,KAAK,IAAI,CAAC,EAAE;YACd,gBAAgB,CAAC,MAAM,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC;SACnC;QACD,MAAM,CAAC,OAAO,EAAE,CAAC;KAClB,CAAC,CAAC;;IAEH,IAAM,WAAW,GAAG,cAAc,CAAC,cAAc,CAAC,SAAS,CAAC,CAAC;;IAC7D,IAAM,aAAa,GACf,WAAW,CAAC,aAAa,IAAI,CAAC,WAAW,CAAC,aAAa,GAAG,IAAI,iBAAiB,EAAE,CAAC,CAAC;IACvF,aAAa,CAAC,WAAW,CAAC,MAAM,EAAE,GAAG,CAAC,CAAC;;IAEvC,IAAM,gBAAgB,GAAG,WAAW,CAAC,KAAK,kBAA2B,CAAC;;;IAItE,WAAW,CAAC,KAAK,wBAAiC,CAAC;IACnD,IAAI,gBAAgB,EAAE;QACpB,YAAY,CAAC,WAAW,CAAC,CAAC;KAC3B;CACF;;;;;AAED,MAAM,UAAU,UAAU,CAAC,GAAwD;IACjF,OAAO,wBAAwB,CAAC,GAAG,CAAC,CAAC;CACtC","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {getContext} from './context_discovery';\nimport {scheduleTick} from './instructions';\nimport {ComponentInstance, DirectiveInstance, PlayState, Player} from './interfaces/player';\nimport {RootContextFlags} from './interfaces/view';\nimport {CorePlayerHandler} from './styling/core_player_handler';\nimport {getOrCreatePlayerContext} from './styling/util';\nimport {getRootContext} from './util';\n\nexport function addPlayer(\n    ref: ComponentInstance | DirectiveInstance | HTMLElement, player: Player): void {\n  const elementContext = getContext(ref) !;\n  const animationContext = getOrCreatePlayerContext(elementContext.native, elementContext) !;\n  animationContext.push(player);\n\n  player.addEventListener(PlayState.Destroyed, () => {\n    const index = animationContext.indexOf(player);\n    if (index >= 0) {\n      animationContext.splice(index, 1);\n    }\n    player.destroy();\n  });\n\n  const rootContext = getRootContext(elementContext.lViewData);\n  const playerHandler =\n      rootContext.playerHandler || (rootContext.playerHandler = new CorePlayerHandler());\n  playerHandler.queuePlayer(player, ref);\n\n  const nothingScheduled = rootContext.flags === RootContextFlags.Empty;\n\n  // change detection may or may not happen therefore\n  // the core code needs to be kicked off to flush the animations\n  rootContext.flags |= RootContextFlags.FlushPlayers;\n  if (nothingScheduled) {\n    scheduleTick(rootContext);\n  }\n}\n\nexport function getPlayers(ref: ComponentInstance | DirectiveInstance | HTMLElement): Player[] {\n  return getOrCreatePlayerContext(ref);\n}\n"]}