{"version":3,"file":"element_discovery.js","sourceRoot":"","sources":["../../../../../../packages/core/src/render3/element_discovery.ts"],"names":[],"mappings":";;;;AAQA,OAAO,EAAC,aAAa,EAAY,MAAM,mBAAmB,CAAC;;AAG3D,WAAa,qBAAqB,GAAG,aAAa,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2BnD,MAAM,UAAU,iBAAiB,CAAC,OAAiB;;IACjD,IAAI,OAAO,qBAAG,mBAAC,OAAc,EAAC,CAAC,qBAAqB,CAAsC,EAAC;IAC3F,IAAI,OAAO,EAAE;QACX,IAAI,KAAK,CAAC,OAAO,CAAC,OAAO,CAAC,EAAE;;YAC1B,IAAM,SAAS,qBAAG,OAAoB,EAAC;;YACvC,IAAM,KAAK,GAAG,mBAAmB,CAAC,OAAO,EAAE,SAAS,CAAC,CAAC;YACtD,OAAO,GAAG,EAAC,KAAK,OAAA,EAAE,MAAM,EAAE,OAAO,EAAE,SAAS,WAAA,EAAC,CAAC;YAC9C,qBAAqB,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC;SACzC;KACF;SAAM;;QACL,IAAI,QAAM,qBAAG,OAAc,EAAC;QAC5B,OAAO,QAAM,GAAG,QAAM,CAAC,UAAU,EAAE;;YACjC,IAAM,aAAa,qBACf,mBAAC,QAAa,EAAC,CAAC,qBAAqB,CAAsC,EAAC;YAChF,IAAI,aAAa,EAAE;;gBACjB,IAAM,SAAS,GACX,KAAK,CAAC,OAAO,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC,mBAAC,aAA0B,EAAC,CAAC,CAAC,CAAC,aAAa,CAAC,SAAS,CAAC;;gBAC1F,IAAM,KAAK,GAAG,mBAAmB,CAAC,OAAO,EAAE,SAAS,CAAC,CAAC;gBACtD,IAAI,KAAK,IAAI,CAAC,EAAE;oBACd,OAAO,GAAG,EAAC,KAAK,OAAA,EAAE,MAAM,EAAE,OAAO,EAAE,SAAS,WAAA,EAAC,CAAC;oBAC9C,qBAAqB,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC;oBACxC,MAAM;iBACP;aACF;SACF;KACF;IACD,OAAO,mBAAC,OAAyB,EAAC,IAAI,IAAI,CAAC;CAC5C;;;;;;;AAGD,SAAS,mBAAmB,CAAC,OAAiB,EAAE,SAAoB;IAClE,KAAK,IAAI,CAAC,GAAG,aAAa,EAAE,CAAC,GAAG,SAAS,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;;QACrD,IAAI,MAAM,GAAG,SAAS,CAAC,CAAC,CAAC,CAAC;QAC1B,IAAI,MAAM,EAAE;;;YAGV,IAAI,KAAK,CAAC,OAAO,CAAC,MAAM,CAAC,EAAE;gBACzB,MAAM,GAAG,MAAM,yBAA8B,CAAC;aAC/C;YACD,IAAI,MAAM,CAAC,MAAM,KAAK,OAAO;gBAAE,OAAO,CAAC,CAAC;SACzC;KACF;IACD,OAAO,CAAC,CAAC,CAAC;CACX;;;;;;;AAGD,MAAM,UAAU,qBAAqB,CAAC,IAAS,EAAE,IAAgC;IAC/E,IAAI,CAAC,qBAAqB,CAAC,GAAG,IAAI,CAAC;CACpC","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {RElement} from './interfaces/renderer';\nimport {HEADER_OFFSET, LViewData} from './interfaces/view';\nimport {StylingIndex} from './styling';\n\nexport const MONKEY_PATCH_KEY_NAME = '__ng_data__';\n\n/** The internal element context which is specific to a given DOM node */\nexport interface ElementContext {\n  /** The component\\'s view data */\n  lViewData: LViewData;\n\n  /** The index of the element within the view data array */\n  index: number;\n\n  /** The instance of the DOM node */\n  native: RElement;\n}\n\n/** Returns the matching `ElementContext` data for a given DOM node.\n *\n * This function will examine the provided DOM element's monkey-patched property to figure out the\n * associated index and view data (`LViewData`).\n *\n * If the monkey-patched value is the `LViewData` instance then the element context for that\n * element will be created and the monkey-patch reference will be updated. Therefore when this\n * function is called it may mutate the provided element\\'s monkey-patch value.\n *\n * If the monkey-patch value is not detected then the code will walk up the DOM until an element\n * is found which contains a monkey-patch reference. When that occurs then the provided element\n * will be updated with a new context (which is then returned).\n */\nexport function getElementContext(element: RElement): ElementContext|null {\n  let context = (element as any)[MONKEY_PATCH_KEY_NAME] as ElementContext | LViewData | null;\n  if (context) {\n    if (Array.isArray(context)) {\n      const lViewData = context as LViewData;\n      const index = findMatchingElement(element, lViewData);\n      context = {index, native: element, lViewData};\n      attachLViewDataToNode(element, context);\n    }\n  } else {\n    let parent = element as any;\n    while (parent = parent.parentNode) {\n      const parentContext =\n          (parent as any)[MONKEY_PATCH_KEY_NAME] as ElementContext | LViewData | null;\n      if (parentContext) {\n        const lViewData =\n            Array.isArray(parentContext) ? (parentContext as LViewData) : parentContext.lViewData;\n        const index = findMatchingElement(element, lViewData);\n        if (index >= 0) {\n          context = {index, native: element, lViewData};\n          attachLViewDataToNode(element, context);\n          break;\n        }\n      }\n    }\n  }\n  return (context as ElementContext) || null;\n}\n\n/** Locates the element within the given LViewData and returns the matching index */\nfunction findMatchingElement(element: RElement, lViewData: LViewData): number {\n  for (let i = HEADER_OFFSET; i < lViewData.length; i++) {\n    let result = lViewData[i];\n    if (result) {\n      // special case for styling since when [class] and [style] bindings\n      // are used they will wrap the element into a StylingContext array\n      if (Array.isArray(result)) {\n        result = result[StylingIndex.ElementPosition];\n      }\n      if (result.native === element) return i;\n    }\n  }\n  return -1;\n}\n\n/** Assigns the given data to a DOM element using monkey-patching */\nexport function attachLViewDataToNode(node: any, data: LViewData | ElementContext) {\n  node[MONKEY_PATCH_KEY_NAME] = data;\n}\n"]}