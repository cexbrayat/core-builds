{"version":3,"file":"class_and_style_bindings.js","sourceRoot":"","sources":["../../../../../../../packages/core/src/render3/styling/class_and_style_bindings.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {StyleSanitizeFn} from '../../sanitization/style_sanitizer';\nimport {InitialStylingFlags} from '../interfaces/definition';\nimport {Renderer3, RendererStyleFlags3, isProceduralRenderer} from '../interfaces/renderer';\nimport {InitialStyles, StylingContext, StylingFlags, StylingIndex} from '../interfaces/styling';\n\nimport {EMPTY_ARR, EMPTY_OBJ, createEmptyStylingContext} from './util';\n\n/**\n * Creates a styling context template where styling information is stored.\n * Any styles that are later referenced using `updateStyleProp` must be\n * passed in within this function. Initial values for those styles are to\n * be declared after all initial style properties are declared (this change in\n * mode between declarations and initial styles is made possible using a special\n * enum value found in `definition.ts`).\n *\n * @param initialStyleDeclarations a list of style declarations and initial style values\n *    that are used later within the styling context.\n *\n *    -> ['width', 'height', SPECIAL_ENUM_VAL, 'width', '100px']\n *       This implies that `width` and `height` will be later styled and that the `width`\n *       property has an initial value of `100px`.\n *\n * @param initialClassDeclarations a list of class declarations and initial class values\n *    that are used later within the styling context.\n *\n *    -> ['foo', 'bar', SPECIAL_ENUM_VAL, 'foo', true]\n *       This implies that `foo` and `bar` will be later styled and that the `foo`\n *       class will be applied to the element as an initial class since it's true\n */\nexport function createStylingContextTemplate(\n    initialClassDeclarations?: (string | boolean | InitialStylingFlags)[] | null,\n    initialStyleDeclarations?: (string | boolean | InitialStylingFlags)[] | null,\n    styleSanitizer?: StyleSanitizeFn | null): StylingContext {\n  const initialStylingValues: InitialStyles = [null];\n  const context: StylingContext =\n      createEmptyStylingContext(null, styleSanitizer, initialStylingValues);\n\n  // we use two maps since a class name might collide with a CSS style prop\n  const stylesLookup: {[key: string]: number} = {};\n  const classesLookup: {[key: string]: number} = {};\n\n  let totalStyleDeclarations = 0;\n  if (initialStyleDeclarations) {\n    let hasPassedDeclarations = false;\n    for (let i = 0; i < initialStyleDeclarations.length; i++) {\n      const v = initialStyleDeclarations[i] as string | InitialStylingFlags;\n\n      // this flag value marks where the declarations end the initial values begin\n      if (v === InitialStylingFlags.VALUES_MODE) {\n        hasPassedDeclarations = true;\n      } else {\n        const prop = v as string;\n        if (hasPassedDeclarations) {\n          const value = initialStyleDeclarations[++i] as string;\n          initialStylingValues.push(value);\n          stylesLookup[prop] = initialStylingValues.length - 1;\n        } else {\n          totalStyleDeclarations++;\n          stylesLookup[prop] = 0;\n        }\n      }\n    }\n  }\n\n  // make where the class offsets begin\n  context[StylingIndex.ClassOffsetPosition] = totalStyleDeclarations;\n\n  if (initialClassDeclarations) {\n    let hasPassedDeclarations = false;\n    for (let i = 0; i < initialClassDeclarations.length; i++) {\n      const v = initialClassDeclarations[i] as string | boolean | InitialStylingFlags;\n      // this flag value marks where the declarations end the initial values begin\n      if (v === InitialStylingFlags.VALUES_MODE) {\n        hasPassedDeclarations = true;\n      } else {\n        const className = v as string;\n        if (hasPassedDeclarations) {\n          const value = initialClassDeclarations[++i] as boolean;\n          initialStylingValues.push(value);\n          classesLookup[className] = initialStylingValues.length - 1;\n        } else {\n          classesLookup[className] = 0;\n        }\n      }\n    }\n  }\n\n  const styleProps = Object.keys(stylesLookup);\n  const classNames = Object.keys(classesLookup);\n  const classNamesIndexStart = styleProps.length;\n  const totalProps = styleProps.length + classNames.length;\n\n  // *2 because we are filling for both single and multi style spaces\n  const maxLength = totalProps * StylingIndex.Size * 2 + StylingIndex.SingleStylesStartPosition;\n\n  // we need to fill the array from the start so that we can access\n  // both the multi and the single array positions in the same loop block\n  for (let i = StylingIndex.SingleStylesStartPosition; i < maxLength; i++) {\n    context.push(null);\n  }\n\n  const singleStart = StylingIndex.SingleStylesStartPosition;\n  const multiStart = totalProps * StylingIndex.Size + StylingIndex.SingleStylesStartPosition;\n\n  // fill single and multi-level styles\n  for (let i = 0; i < totalProps; i++) {\n    const isClassBased = i >= classNamesIndexStart;\n    const prop = isClassBased ? classNames[i - classNamesIndexStart] : styleProps[i];\n    const indexForInitial = isClassBased ? classesLookup[prop] : stylesLookup[prop];\n    const initialValue = initialStylingValues[indexForInitial];\n\n    const indexForMulti = i * StylingIndex.Size + multiStart;\n    const indexForSingle = i * StylingIndex.Size + singleStart;\n    const initialFlag = prepareInitialFlag(prop, isClassBased, styleSanitizer || null);\n\n    setFlag(context, indexForSingle, pointers(initialFlag, indexForInitial, indexForMulti));\n    setProp(context, indexForSingle, prop);\n    setValue(context, indexForSingle, null);\n\n    const flagForMulti =\n        initialFlag | (initialValue !== null ? StylingFlags.Dirty : StylingFlags.None);\n    setFlag(context, indexForMulti, pointers(flagForMulti, indexForInitial, indexForSingle));\n    setProp(context, indexForMulti, prop);\n    setValue(context, indexForMulti, null);\n  }\n\n  // there is no initial value flag for the master index since it doesn't\n  // reference an initial style value\n  setFlag(context, StylingIndex.MasterFlagPosition, pointers(0, 0, multiStart));\n  setContextDirty(context, initialStylingValues.length > 1);\n\n  return context;\n}\n\n/**\n * Sets and resolves all `multi` styling on an `StylingContext` so that they can be\n * applied to the element once `renderStyling` is called.\n *\n * All missing styles/class (any values that are not provided in the new `styles`\n * or `classes` params) will resolve to `null` within their respective positions\n * in the context.\n *\n * @param context The styling context that will be updated with the\n *    newly provided style values.\n * @param classes The key/value map of CSS class names that will be used for the update.\n * @param styles The key/value map of CSS styles that will be used for the update.\n */\nexport function updateStylingMap(\n    context: StylingContext, classes: {[key: string]: any} | string | null,\n    styles?: {[key: string]: any} | null): void {\n  styles = styles || null;\n  // early exit (this is what's done to avoid using ctx.bind() to cache the value)\n  const ignoreAllClassUpdates = classes === context[StylingIndex.PreviousMultiClassValue];\n  const ignoreAllStyleUpdates = styles === context[StylingIndex.PreviousMultiStyleValue];\n  if (ignoreAllClassUpdates && ignoreAllStyleUpdates) return;\n\n  let classNames: string[] = EMPTY_ARR;\n  let applyAllClasses = false;\n\n  // each time a string-based value pops up then it shouldn't require a deep\n  // check of what's changed.\n  if (!ignoreAllClassUpdates) {\n    context[StylingIndex.PreviousMultiClassValue] = classes;\n    if (typeof classes == 'string') {\n      classNames = classes.split(/\\s+/);\n      // this boolean is used to avoid having to create a key/value map of `true` values\n      // since a classname string implies that all those classes are added\n      applyAllClasses = true;\n    } else {\n      classNames = classes ? Object.keys(classes) : EMPTY_ARR;\n    }\n  }\n\n  classes = (classes || EMPTY_OBJ) as{[key: string]: any};\n\n  if (!ignoreAllStyleUpdates) {\n    context[StylingIndex.PreviousMultiStyleValue] = styles;\n  }\n\n  const styleProps = styles ? Object.keys(styles) : EMPTY_ARR;\n  styles = styles || EMPTY_OBJ;\n\n  const classesStartIndex = styleProps.length;\n  const multiStartIndex = getMultiStartIndex(context);\n\n  let dirty = false;\n  let ctxIndex = multiStartIndex;\n\n  let propIndex = 0;\n  const propLimit = styleProps.length + classNames.length;\n\n  // the main loop here will try and figure out how the shape of the provided\n  // styles differ with respect to the context. Later if the context/styles/classes\n  // are off-balance then they will be dealt in another loop after this one\n  while (ctxIndex < context.length && propIndex < propLimit) {\n    const isClassBased = propIndex >= classesStartIndex;\n    const processValue =\n        (!isClassBased && !ignoreAllStyleUpdates) || (isClassBased && !ignoreAllClassUpdates);\n\n    // when there is a cache-hit for a string-based class then we should\n    // avoid doing any work diffing any of the changes\n    if (processValue) {\n      const adjustedPropIndex = isClassBased ? propIndex - classesStartIndex : propIndex;\n      const newProp: string =\n          isClassBased ? classNames[adjustedPropIndex] : styleProps[adjustedPropIndex];\n      const newValue: string|boolean =\n          isClassBased ? (applyAllClasses ? true : classes[newProp]) : styles[newProp];\n\n      const prop = getProp(context, ctxIndex);\n      if (prop === newProp) {\n        const value = getValue(context, ctxIndex);\n        const flag = getPointers(context, ctxIndex);\n        if (hasValueChanged(flag, value, newValue)) {\n          setValue(context, ctxIndex, newValue);\n\n          const initialValue = getInitialValue(context, flag);\n\n          // there is no point in setting this to dirty if the previously\n          // rendered value was being referenced by the initial style (or null)\n          if (hasValueChanged(flag, initialValue, newValue)) {\n            setDirty(context, ctxIndex, true);\n            dirty = true;\n          }\n        }\n      } else {\n        const indexOfEntry = findEntryPositionByProp(context, newProp, ctxIndex);\n        if (indexOfEntry > 0) {\n          // it was found at a later point ... just swap the values\n          const valueToCompare = getValue(context, indexOfEntry);\n          const flagToCompare = getPointers(context, indexOfEntry);\n          swapMultiContextEntries(context, ctxIndex, indexOfEntry);\n          if (hasValueChanged(flagToCompare, valueToCompare, newValue)) {\n            const initialValue = getInitialValue(context, flagToCompare);\n            setValue(context, ctxIndex, newValue);\n            if (hasValueChanged(flagToCompare, initialValue, newValue)) {\n              setDirty(context, ctxIndex, true);\n              dirty = true;\n            }\n          }\n        } else {\n          // we only care to do this if the insertion is in the middle\n          const newFlag = prepareInitialFlag(newProp, isClassBased, getStyleSanitizer(context));\n          insertNewMultiProperty(context, ctxIndex, isClassBased, newProp, newFlag, newValue);\n          dirty = true;\n        }\n      }\n    }\n\n    ctxIndex += StylingIndex.Size;\n    propIndex++;\n  }\n\n  // this means that there are left-over values in the context that\n  // were not included in the provided styles/classes and in this\n  // case the  goal is to \"remove\" them from the context (by nullifying)\n  while (ctxIndex < context.length) {\n    const flag = getPointers(context, ctxIndex);\n    const isClassBased = (flag & StylingFlags.Class) === StylingFlags.Class;\n    const processValue =\n        (!isClassBased && !ignoreAllStyleUpdates) || (isClassBased && !ignoreAllClassUpdates);\n    if (processValue) {\n      const value = getValue(context, ctxIndex);\n      const doRemoveValue = valueExists(value, isClassBased);\n      if (doRemoveValue) {\n        setDirty(context, ctxIndex, true);\n        setValue(context, ctxIndex, null);\n        dirty = true;\n      }\n    }\n    ctxIndex += StylingIndex.Size;\n  }\n\n  // this means that there are left-over properties in the context that\n  // were not detected in the context during the loop above. In that\n  // case we want to add the new entries into the list\n  const sanitizer = getStyleSanitizer(context);\n  while (propIndex < propLimit) {\n    const isClassBased = propIndex >= classesStartIndex;\n    const processValue =\n        (!isClassBased && !ignoreAllStyleUpdates) || (isClassBased && !ignoreAllClassUpdates);\n    if (processValue) {\n      const adjustedPropIndex = isClassBased ? propIndex - classesStartIndex : propIndex;\n      const prop = isClassBased ? classNames[adjustedPropIndex] : styleProps[adjustedPropIndex];\n      const value: string|boolean =\n          isClassBased ? (applyAllClasses ? true : classes[prop]) : styles[prop];\n      const flag = prepareInitialFlag(prop, isClassBased, sanitizer) | StylingFlags.Dirty;\n      context.push(flag, prop, value);\n      dirty = true;\n    }\n    propIndex++;\n  }\n\n  if (dirty) {\n    setContextDirty(context, true);\n  }\n}\n\n/**\n * Sets and resolves a single styling property/value on the provided `StylingContext` so\n * that they can be applied to the element once `renderStyling` is called.\n *\n * Note that prop-level styling values are considered higher priority than any styling that\n * has been applied using `updateStylingMap`, therefore, when styling values are rendered\n * then any styles/classes that have been applied using this function will be considered first\n * (then multi values second and then initial values as a backup).\n *\n * @param context The styling context that will be updated with the\n *    newly provided style value.\n * @param index The index of the property which is being updated.\n * @param value The CSS style value that will be assigned\n */\nexport function updateStyleProp(\n    context: StylingContext, index: number, value: string | boolean | null): void {\n  const singleIndex = StylingIndex.SingleStylesStartPosition + index * StylingIndex.Size;\n  const currValue = getValue(context, singleIndex);\n  const currFlag = getPointers(context, singleIndex);\n\n  // didn't change ... nothing to make a note of\n  if (hasValueChanged(currFlag, currValue, value)) {\n    // the value will always get updated (even if the dirty flag is skipped)\n    setValue(context, singleIndex, value);\n    const indexForMulti = getMultiOrSingleIndex(currFlag);\n\n    // if the value is the same in the multi-area then there's no point in re-assembling\n    const valueForMulti = getValue(context, indexForMulti);\n    if (!valueForMulti || hasValueChanged(currFlag, valueForMulti, value)) {\n      let multiDirty = false;\n      let singleDirty = true;\n\n      const isClassBased = (currFlag & StylingFlags.Class) === StylingFlags.Class;\n\n      // only when the value is set to `null` should the multi-value get flagged\n      if (!valueExists(value, isClassBased) && valueExists(valueForMulti, isClassBased)) {\n        multiDirty = true;\n        singleDirty = false;\n      }\n\n      setDirty(context, indexForMulti, multiDirty);\n      setDirty(context, singleIndex, singleDirty);\n      setContextDirty(context, true);\n    }\n  }\n}\n\n/**\n * This method will toggle the referenced CSS class (by the provided index)\n * within the given context.\n *\n * @param context The styling context that will be updated with the\n *    newly provided class value.\n * @param index The index of the CSS class which is being updated.\n * @param addOrRemove Whether or not to add or remove the CSS class\n */\nexport function updateClassProp(\n    context: StylingContext, index: number, addOrRemove: boolean): void {\n  const adjustedIndex = index + context[StylingIndex.ClassOffsetPosition];\n  updateStyleProp(context, adjustedIndex, addOrRemove);\n}\n\n/**\n * Renders all queued styling using a renderer onto the given element.\n *\n * This function works by rendering any styles (that have been applied\n * using `updateStylingMap`) and any classes (that have been applied using\n * `updateStyleProp`) onto the provided element using the provided renderer.\n * Just before the styles/classes are rendered a final key/value style map\n * will be assembled (if `styleStore` or `classStore` are provided).\n *\n * @param lElement the element that the styles will be rendered on\n * @param context The styling context that will be used to determine\n *      what styles will be rendered\n * @param renderer the renderer that will be used to apply the styling\n * @param styleStore if provided, the updated style values will be applied\n *    to this key/value map instead of being renderered via the renderer.\n * @param classStore if provided, the updated class values will be applied\n *    to this key/value map instead of being renderered via the renderer.\n */\nexport function renderStyling(\n    context: StylingContext, renderer: Renderer3, styleStore?: {[key: string]: any},\n    classStore?: {[key: string]: boolean}) {\n  if (isContextDirty(context)) {\n    const native = context[StylingIndex.ElementPosition] !;\n    const multiStartIndex = getMultiStartIndex(context);\n    const styleSanitizer = getStyleSanitizer(context);\n    for (let i = StylingIndex.SingleStylesStartPosition; i < context.length;\n         i += StylingIndex.Size) {\n      // there is no point in rendering styles that have not changed on screen\n      if (isDirty(context, i)) {\n        const prop = getProp(context, i);\n        const value = getValue(context, i);\n        const flag = getPointers(context, i);\n        const isClassBased = flag & StylingFlags.Class ? true : false;\n        const isInSingleRegion = i < multiStartIndex;\n\n        let valueToApply: string|boolean|null = value;\n\n        // VALUE DEFER CASE 1: Use a multi value instead of a null single value\n        // this check implies that a single value was removed and we\n        // should now defer to a multi value and use that (if set).\n        if (isInSingleRegion && !valueExists(valueToApply, isClassBased)) {\n          // single values ALWAYS have a reference to a multi index\n          const multiIndex = getMultiOrSingleIndex(flag);\n          valueToApply = getValue(context, multiIndex);\n        }\n\n        // VALUE DEFER CASE 2: Use the initial value if all else fails (is falsy)\n        // the initial value will always be a string or null,\n        // therefore we can safely adopt it incase there's nothing else\n        // note that this should always be a falsy check since `false` is used\n        // for both class and style comparisons (styles can't be false and false\n        // classes are turned off and should therefore defer to their initial values)\n        if (!valueExists(valueToApply, isClassBased)) {\n          valueToApply = getInitialValue(context, flag);\n        }\n\n        if (isClassBased) {\n          setClass(native, prop, valueToApply ? true : false, renderer, classStore);\n        } else {\n          const sanitizer = (flag & StylingFlags.Sanitize) ? styleSanitizer : null;\n          setStyle(native, prop, valueToApply as string | null, renderer, sanitizer, styleStore);\n        }\n        setDirty(context, i, false);\n      }\n    }\n\n    setContextDirty(context, false);\n  }\n}\n\n/**\n * This function renders a given CSS prop/value entry using the\n * provided renderer. If a `store` value is provided then\n * that will be used a render context instead of the provided\n * renderer.\n *\n * @param native the DOM Element\n * @param prop the CSS style property that will be rendered\n * @param value the CSS style value that will be rendered\n * @param renderer\n * @param store an optional key/value map that will be used as a context to render styles on\n */\nfunction setStyle(\n    native: any, prop: string, value: string | null, renderer: Renderer3,\n    sanitizer: StyleSanitizeFn | null, store?: {[key: string]: any}) {\n  value = sanitizer && value ? sanitizer(prop, value) : value;\n  if (store) {\n    store[prop] = value;\n  } else if (value) {\n    ngDevMode && ngDevMode.rendererSetStyle++;\n    isProceduralRenderer(renderer) ?\n        renderer.setStyle(native, prop, value, RendererStyleFlags3.DashCase) :\n        native['style'].setProperty(prop, value);\n  } else {\n    ngDevMode && ngDevMode.rendererRemoveStyle++;\n    isProceduralRenderer(renderer) ?\n        renderer.removeStyle(native, prop, RendererStyleFlags3.DashCase) :\n        native['style'].removeProperty(prop);\n  }\n}\n\n/**\n * This function renders a given CSS class value using the provided\n * renderer (by adding or removing it from the provided element).\n * If a `store` value is provided then that will be used a render\n * context instead of the provided renderer.\n *\n * @param native the DOM Element\n * @param prop the CSS style property that will be rendered\n * @param value the CSS style value that will be rendered\n * @param renderer\n * @param store an optional key/value map that will be used as a context to render styles on\n */\nfunction setClass(\n    native: any, className: string, add: boolean, renderer: Renderer3,\n    store?: {[key: string]: boolean}) {\n  if (store) {\n    store[className] = add;\n  } else if (add) {\n    ngDevMode && ngDevMode.rendererAddClass++;\n    isProceduralRenderer(renderer) ? renderer.addClass(native, className) :\n                                     native['classList'].add(className);\n  } else {\n    ngDevMode && ngDevMode.rendererRemoveClass++;\n    isProceduralRenderer(renderer) ? renderer.removeClass(native, className) :\n                                     native['classList'].remove(className);\n  }\n}\n\nfunction setDirty(context: StylingContext, index: number, isDirtyYes: boolean) {\n  const adjustedIndex =\n      index >= StylingIndex.SingleStylesStartPosition ? (index + StylingIndex.FlagsOffset) : index;\n  if (isDirtyYes) {\n    (context[adjustedIndex] as number) |= StylingFlags.Dirty;\n  } else {\n    (context[adjustedIndex] as number) &= ~StylingFlags.Dirty;\n  }\n}\n\nfunction isDirty(context: StylingContext, index: number): boolean {\n  const adjustedIndex =\n      index >= StylingIndex.SingleStylesStartPosition ? (index + StylingIndex.FlagsOffset) : index;\n  return ((context[adjustedIndex] as number) & StylingFlags.Dirty) == StylingFlags.Dirty;\n}\n\nfunction isClassBased(context: StylingContext, index: number): boolean {\n  const adjustedIndex =\n      index >= StylingIndex.SingleStylesStartPosition ? (index + StylingIndex.FlagsOffset) : index;\n  return ((context[adjustedIndex] as number) & StylingFlags.Class) == StylingFlags.Class;\n}\n\nfunction isSanitizable(context: StylingContext, index: number): boolean {\n  const adjustedIndex =\n      index >= StylingIndex.SingleStylesStartPosition ? (index + StylingIndex.FlagsOffset) : index;\n  return ((context[adjustedIndex] as number) & StylingFlags.Sanitize) == StylingFlags.Sanitize;\n}\n\nfunction pointers(configFlag: number, staticIndex: number, dynamicIndex: number) {\n  return (configFlag & StylingFlags.BitMask) | (staticIndex << StylingFlags.BitCountSize) |\n      (dynamicIndex << (StylingIndex.BitCountSize + StylingFlags.BitCountSize));\n}\n\nfunction getInitialValue(context: StylingContext, flag: number): string|null {\n  const index = getInitialIndex(flag);\n  return context[StylingIndex.InitialStylesPosition][index] as null | string;\n}\n\nfunction getInitialIndex(flag: number): number {\n  return (flag >> StylingFlags.BitCountSize) & StylingIndex.BitMask;\n}\n\nfunction getMultiOrSingleIndex(flag: number): number {\n  const index =\n      (flag >> (StylingIndex.BitCountSize + StylingFlags.BitCountSize)) & StylingIndex.BitMask;\n  return index >= StylingIndex.SingleStylesStartPosition ? index : -1;\n}\n\nfunction getMultiStartIndex(context: StylingContext): number {\n  return getMultiOrSingleIndex(context[StylingIndex.MasterFlagPosition]) as number;\n}\n\nfunction getStyleSanitizer(context: StylingContext): StyleSanitizeFn|null {\n  return context[StylingIndex.StyleSanitizerPosition];\n}\n\nfunction setProp(context: StylingContext, index: number, prop: string) {\n  context[index + StylingIndex.PropertyOffset] = prop;\n}\n\nfunction setValue(context: StylingContext, index: number, value: string | null | boolean) {\n  context[index + StylingIndex.ValueOffset] = value;\n}\n\nfunction setFlag(context: StylingContext, index: number, flag: number) {\n  const adjustedIndex =\n      index === StylingIndex.MasterFlagPosition ? index : (index + StylingIndex.FlagsOffset);\n  context[adjustedIndex] = flag;\n}\n\nfunction getPointers(context: StylingContext, index: number): number {\n  const adjustedIndex =\n      index === StylingIndex.MasterFlagPosition ? index : (index + StylingIndex.FlagsOffset);\n  return context[adjustedIndex] as number;\n}\n\nfunction getValue(context: StylingContext, index: number): string|boolean|null {\n  return context[index + StylingIndex.ValueOffset] as string | boolean | null;\n}\n\nfunction getProp(context: StylingContext, index: number): string {\n  return context[index + StylingIndex.PropertyOffset] as string;\n}\n\nexport function isContextDirty(context: StylingContext): boolean {\n  return isDirty(context, StylingIndex.MasterFlagPosition);\n}\n\nexport function setContextDirty(context: StylingContext, isDirtyYes: boolean): void {\n  setDirty(context, StylingIndex.MasterFlagPosition, isDirtyYes);\n}\n\nfunction findEntryPositionByProp(\n    context: StylingContext, prop: string, startIndex?: number): number {\n  for (let i = (startIndex || 0) + StylingIndex.PropertyOffset; i < context.length;\n       i += StylingIndex.Size) {\n    const thisProp = context[i];\n    if (thisProp == prop) {\n      return i - StylingIndex.PropertyOffset;\n    }\n  }\n  return -1;\n}\n\nfunction swapMultiContextEntries(context: StylingContext, indexA: number, indexB: number) {\n  const tmpValue = getValue(context, indexA);\n  const tmpProp = getProp(context, indexA);\n  const tmpFlag = getPointers(context, indexA);\n\n  let flagA = tmpFlag;\n  let flagB = getPointers(context, indexB);\n\n  const singleIndexA = getMultiOrSingleIndex(flagA);\n  if (singleIndexA >= 0) {\n    const _flag = getPointers(context, singleIndexA);\n    const _initial = getInitialIndex(_flag);\n    setFlag(context, singleIndexA, pointers(_flag, _initial, indexB));\n  }\n\n  const singleIndexB = getMultiOrSingleIndex(flagB);\n  if (singleIndexB >= 0) {\n    const _flag = getPointers(context, singleIndexB);\n    const _initial = getInitialIndex(_flag);\n    setFlag(context, singleIndexB, pointers(_flag, _initial, indexA));\n  }\n\n  setValue(context, indexA, getValue(context, indexB));\n  setProp(context, indexA, getProp(context, indexB));\n  setFlag(context, indexA, getPointers(context, indexB));\n\n  setValue(context, indexB, tmpValue);\n  setProp(context, indexB, tmpProp);\n  setFlag(context, indexB, tmpFlag);\n}\n\nfunction updateSinglePointerValues(context: StylingContext, indexStartPosition: number) {\n  for (let i = indexStartPosition; i < context.length; i += StylingIndex.Size) {\n    const multiFlag = getPointers(context, i);\n    const singleIndex = getMultiOrSingleIndex(multiFlag);\n    if (singleIndex > 0) {\n      const singleFlag = getPointers(context, singleIndex);\n      const initialIndexForSingle = getInitialIndex(singleFlag);\n      const flagValue = (isDirty(context, singleIndex) ? StylingFlags.Dirty : StylingFlags.None) |\n          (isClassBased(context, singleIndex) ? StylingFlags.Class : StylingFlags.None) |\n          (isSanitizable(context, singleIndex) ? StylingFlags.Sanitize : StylingFlags.None);\n      const updatedFlag = pointers(flagValue, initialIndexForSingle, i);\n      setFlag(context, singleIndex, updatedFlag);\n    }\n  }\n}\n\nfunction insertNewMultiProperty(\n    context: StylingContext, index: number, classBased: boolean, name: string, flag: number,\n    value: string | boolean): void {\n  const doShift = index < context.length;\n\n  // prop does not exist in the list, add it in\n  context.splice(\n      index, 0, flag | StylingFlags.Dirty | (classBased ? StylingFlags.Class : StylingFlags.None),\n      name, value);\n\n  if (doShift) {\n    // because the value was inserted midway into the array then we\n    // need to update all the shifted multi values' single value\n    // pointers to point to the newly shifted location\n    updateSinglePointerValues(context, index + StylingIndex.Size);\n  }\n}\n\nfunction valueExists(value: string | null | boolean, isClassBased?: boolean) {\n  if (isClassBased) {\n    return value ? true : false;\n  }\n  return value !== null;\n}\n\nfunction prepareInitialFlag(\n    name: string, isClassBased: boolean, sanitizer?: StyleSanitizeFn | null) {\n  if (isClassBased) {\n    return StylingFlags.Class;\n  } else if (sanitizer && sanitizer(name)) {\n    return StylingFlags.Sanitize;\n  }\n  return StylingFlags.None;\n}\n\nfunction hasValueChanged(\n    flag: number, a: string | boolean | null, b: string | boolean | null): boolean {\n  const isClassBased = flag & StylingFlags.Class;\n  const hasValues = a && b;\n  const usesSanitizer = flag & StylingFlags.Sanitize;\n  // the toString() comparison ensures that a value is checked\n  // ... otherwise (during sanitization bypassing) the === comparsion\n  // would fail since a new String() instance is created\n  if (!isClassBased && hasValues && usesSanitizer) {\n    // we know for sure we're dealing with strings at this point\n    return (a as string).toString() !== (b as string).toString();\n  }\n\n  // everything else is safe to check with a normal equality check\n  return a !== b;\n}\n"]}