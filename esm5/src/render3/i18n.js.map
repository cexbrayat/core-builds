{"version":3,"file":"i18n.js","sourceRoot":"","sources":["../../../../../../packages/core/src/render3/i18n.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {assertEqual, assertLessThan} from './assert';\nimport {NO_CHANGE, _getViewData, adjustBlueprintForNewNode, bindingUpdated, bindingUpdated2, bindingUpdated3, bindingUpdated4, createLNode, getPreviousOrParentNode, getRenderer, load, resetComponentState} from './instructions';\nimport {RENDER_PARENT} from './interfaces/container';\nimport {LContainerNode, LNode, TContainerNode, TElementNode, TNodeType} from './interfaces/node';\nimport {BINDING_INDEX, HEADER_OFFSET, TVIEW} from './interfaces/view';\nimport {appendChild, createTextNode, getParentLNode, removeChild} from './node_manipulation';\nimport {stringify} from './util';\n\n/**\n * A list of flags to encode the i18n instructions used to translate the template.\n * We shift the flags by 29 so that 30 & 31 & 32 bits contains the instructions.\n */\nexport const enum I18nInstructions {\n  Text = 1 << 29,\n  Element = 2 << 29,\n  Expression = 3 << 29,\n  TemplateRoot = 4 << 29,\n  Any = 5 << 29,\n  CloseNode = 6 << 29,\n  RemoveNode = 7 << 29,\n  /** Used to decode the number encoded with the instruction. */\n  IndexMask = (1 << 29) - 1,\n  /** Used to test the type of instruction. */\n  InstructionMask = ~((1 << 29) - 1),\n}\n\n/**\n * Represents the instructions used to translate the template.\n * Instructions can be a placeholder index, a static text or a simple bit field (`I18nFlag`).\n * When the instruction is the flag `Text`, it is always followed by its text value.\n */\nexport type I18nInstruction = number | string;\n/**\n * Represents the instructions used to translate attributes containing expressions.\n * Even indexes contain static strings, while odd indexes contain the index of the expression whose\n * value will be concatenated into the final translation.\n */\nexport type I18nExpInstruction = number | string;\n/** Mapping of placeholder names to their absolute indexes in their templates. */\nexport type PlaceholderMap = {\n  [name: string]: number\n};\nconst i18nTagRegex = /{\\$([^}]+)}/g;\n\n/**\n * Takes a translation string, the initial list of placeholders (elements and expressions) and the\n * indexes of their corresponding expression nodes to return a list of instructions for each\n * template function.\n *\n * Because embedded templates have different indexes for each placeholder, each parameter (except\n * the translation) is an array, where each value corresponds to a different template, by order of\n * appearance.\n *\n * @param translation A translation string where placeholders are represented by `{$name}`\n * @param elements An array containing, for each template, the maps of element placeholders and\n * their indexes.\n * @param expressions An array containing, for each template, the maps of expression placeholders\n * and their indexes.\n * @param templateRoots An array of template roots whose content should be ignored when\n * generating the instructions for their parent template.\n * @param lastChildIndex The index of the last child of the i18n node. Used when the i18n block is\n * an ng-container.\n *\n * @returns A list of instructions used to translate each template.\n */\nexport function i18nMapping(\n    translation: string, elements: (PlaceholderMap | null)[] | null,\n    expressions?: (PlaceholderMap | null)[] | null, templateRoots?: string[] | null,\n    lastChildIndex?: number | null): I18nInstruction[][] {\n  const translationParts = translation.split(i18nTagRegex);\n  const nbTemplates = templateRoots ? templateRoots.length + 1 : 1;\n  const instructions: I18nInstruction[][] = (new Array(nbTemplates)).fill(undefined);\n\n  generateMappingInstructions(\n      0, 0, translationParts, instructions, elements, expressions, templateRoots, lastChildIndex);\n\n  return instructions;\n}\n\n/**\n * Internal function that reads the translation parts and generates a set of instructions for each\n * template.\n *\n * See `i18nMapping()` for more details.\n *\n * @param tmplIndex The order of appearance of the template.\n * 0 for the root template, following indexes match the order in `templateRoots`.\n * @param partIndex The current index in `translationParts`.\n * @param translationParts The translation string split into an array of placeholders and text\n * elements.\n * @param instructions The current list of instructions to update.\n * @param elements An array containing, for each template, the maps of element placeholders and\n * their indexes.\n * @param expressions An array containing, for each template, the maps of expression placeholders\n * and their indexes.\n * @param templateRoots An array of template roots whose content should be ignored when\n * generating the instructions for their parent template.\n * @param lastChildIndex The index of the last child of the i18n node. Used when the i18n block is\n * an ng-container.\n *\n * @returns the current index in `translationParts`\n */\nfunction generateMappingInstructions(\n    tmplIndex: number, partIndex: number, translationParts: string[],\n    instructions: I18nInstruction[][], elements: (PlaceholderMap | null)[] | null,\n    expressions?: (PlaceholderMap | null)[] | null, templateRoots?: string[] | null,\n    lastChildIndex?: number | null): number {\n  const tmplInstructions: I18nInstruction[] = [];\n  const phVisited: string[] = [];\n  let openedTagCount = 0;\n  let maxIndex = 0;\n  let currentElements: PlaceholderMap|null =\n      elements && elements[tmplIndex] ? elements[tmplIndex] : null;\n  let currentExpressions: PlaceholderMap|null =\n      expressions && expressions[tmplIndex] ? expressions[tmplIndex] : null;\n\n  instructions[tmplIndex] = tmplInstructions;\n\n  for (; partIndex < translationParts.length; partIndex++) {\n    // The value can either be text or the name of a placeholder (element/template root/expression)\n    const value = translationParts[partIndex];\n\n    // Odd indexes are placeholders\n    if (partIndex & 1) {\n      let phIndex;\n      if (currentElements && currentElements[value] !== undefined) {\n        phIndex = currentElements[value];\n        // The placeholder represents a DOM element, add an instruction to move it\n        let templateRootIndex = templateRoots ? templateRoots.indexOf(value) : -1;\n        if (templateRootIndex !== -1 && (templateRootIndex + 1) !== tmplIndex) {\n          // This is a template root, it has no closing tag, not treating it as an element\n          tmplInstructions.push(phIndex | I18nInstructions.TemplateRoot);\n        } else {\n          tmplInstructions.push(phIndex | I18nInstructions.Element);\n          openedTagCount++;\n        }\n        phVisited.push(value);\n      } else if (currentExpressions && currentExpressions[value] !== undefined) {\n        phIndex = currentExpressions[value];\n        // The placeholder represents an expression, add an instruction to move it\n        tmplInstructions.push(phIndex | I18nInstructions.Expression);\n        phVisited.push(value);\n      } else {\n        // It is a closing tag\n        tmplInstructions.push(I18nInstructions.CloseNode);\n\n        if (tmplIndex > 0) {\n          openedTagCount--;\n\n          // If we have reached the closing tag for this template, exit the loop\n          if (openedTagCount === 0) {\n            break;\n          }\n        }\n      }\n\n      if (phIndex !== undefined && phIndex > maxIndex) {\n        maxIndex = phIndex;\n      }\n\n      if (templateRoots) {\n        const newTmplIndex = templateRoots.indexOf(value) + 1;\n        if (newTmplIndex !== 0 && newTmplIndex !== tmplIndex) {\n          partIndex = generateMappingInstructions(\n              newTmplIndex, partIndex, translationParts, instructions, elements, expressions,\n              templateRoots, lastChildIndex);\n        }\n      }\n\n    } else if (value) {\n      // It's a non-empty string, create a text node\n      tmplInstructions.push(I18nInstructions.Text, value);\n    }\n  }\n\n  // Add instructions to remove elements that are not used in the translation\n  if (elements) {\n    const tmplElements = elements[tmplIndex];\n\n    if (tmplElements) {\n      const phKeys = Object.keys(tmplElements);\n\n      for (let i = 0; i < phKeys.length; i++) {\n        const ph = phKeys[i];\n\n        if (phVisited.indexOf(ph) === -1) {\n          let index = tmplElements[ph];\n          // Add an instruction to remove the element\n          tmplInstructions.push(index | I18nInstructions.RemoveNode);\n\n          if (index > maxIndex) {\n            maxIndex = index;\n          }\n        }\n      }\n    }\n  }\n\n  // Add instructions to remove expressions that are not used in the translation\n  if (expressions) {\n    const tmplExpressions = expressions[tmplIndex];\n\n    if (tmplExpressions) {\n      const phKeys = Object.keys(tmplExpressions);\n\n      for (let i = 0; i < phKeys.length; i++) {\n        const ph = phKeys[i];\n\n        if (phVisited.indexOf(ph) === -1) {\n          let index = tmplExpressions[ph];\n          if (ngDevMode) {\n            assertLessThan(\n                index.toString(2).length, 28, `Index ${index} is too big and will overflow`);\n          }\n          // Add an instruction to remove the expression\n          tmplInstructions.push(index | I18nInstructions.RemoveNode);\n\n          if (index > maxIndex) {\n            maxIndex = index;\n          }\n        }\n      }\n    }\n  }\n\n  if (tmplIndex === 0 && typeof lastChildIndex === 'number') {\n    // The current parent is an ng-container and it has more children after the translation that we\n    // need to append to keep the order of the DOM nodes correct\n    for (let i = maxIndex + 1; i <= lastChildIndex; i++) {\n      if (ngDevMode) {\n        assertLessThan(i.toString(2).length, 28, `Index ${i} is too big and will overflow`);\n      }\n      tmplInstructions.push(i | I18nInstructions.Any);\n    }\n  }\n\n  return partIndex;\n}\n\nfunction appendI18nNode(node: LNode, parentNode: LNode, previousNode: LNode) {\n  if (ngDevMode) {\n    ngDevMode.rendererMoveNode++;\n  }\n\n  const viewData = _getViewData();\n\n  appendChild(parentNode, node.native || null, viewData);\n\n  // On first pass, re-organize node tree to put this node in the correct position.\n  const firstTemplatePass = node.view[TVIEW].firstTemplatePass;\n  if (firstTemplatePass) {\n    if (previousNode === parentNode && node.tNode !== parentNode.tNode.child) {\n      node.tNode.next = parentNode.tNode.child;\n      parentNode.tNode.child = node.tNode;\n    } else if (previousNode !== parentNode && node.tNode !== previousNode.tNode.next) {\n      node.tNode.next = previousNode.tNode.next;\n      previousNode.tNode.next = node.tNode;\n    } else {\n      node.tNode.next = null;\n    }\n\n    if (parentNode.view === node.view) node.tNode.parent = parentNode.tNode as TElementNode;\n  }\n\n  // Template containers also have a comment node for the `ViewContainerRef` that should be moved\n  if (node.tNode.type === TNodeType.Container && node.dynamicLContainerNode) {\n    appendChild(parentNode, node.dynamicLContainerNode.native || null, viewData);\n    if (firstTemplatePass) {\n      node.tNode.dynamicContainerNode = node.dynamicLContainerNode.tNode;\n      node.dynamicLContainerNode.tNode.parent = node.tNode as TContainerNode;\n    }\n    return node.dynamicLContainerNode;\n  }\n\n  return node;\n}\n\n/**\n * Takes a list of instructions generated by `i18nMapping()` to transform the template accordingly.\n *\n * @param startIndex Index of the first element to translate (for instance the first child of the\n * element with the i18n attribute).\n * @param instructions The list of instructions to apply on the current view.\n */\nexport function i18nApply(startIndex: number, instructions: I18nInstruction[]): void {\n  const viewData = _getViewData();\n  if (ngDevMode) {\n    assertEqual(\n        viewData[BINDING_INDEX], viewData[TVIEW].bindingStartIndex,\n        'i18nApply should be called before any binding');\n  }\n\n  if (!instructions) {\n    return;\n  }\n\n  const renderer = getRenderer();\n  let localParentNode: LNode = getParentLNode(load(startIndex)) || getPreviousOrParentNode();\n  let localPreviousNode: LNode = localParentNode;\n  resetComponentState();  // We don't want to add to the tree with the wrong previous node\n\n  for (let i = 0; i < instructions.length; i++) {\n    const instruction = instructions[i] as number;\n    switch (instruction & I18nInstructions.InstructionMask) {\n      case I18nInstructions.Element:\n        const element: LNode = load(instruction & I18nInstructions.IndexMask);\n        localPreviousNode = appendI18nNode(element, localParentNode, localPreviousNode);\n        localParentNode = element;\n        break;\n      case I18nInstructions.Expression:\n      case I18nInstructions.TemplateRoot:\n      case I18nInstructions.Any:\n        const node: LNode = load(instruction & I18nInstructions.IndexMask);\n        localPreviousNode = appendI18nNode(node, localParentNode, localPreviousNode);\n        break;\n      case I18nInstructions.Text:\n        if (ngDevMode) {\n          ngDevMode.rendererCreateTextNode++;\n        }\n        const value = instructions[++i];\n        const textRNode = createTextNode(value, renderer);\n        // If we were to only create a `RNode` then projections won't move the text.\n        // Create text node at the current end of viewData. Must subtract header offset because\n        // createLNode takes a raw index (not adjusted by header offset).\n        adjustBlueprintForNewNode(viewData);\n        const lastNodeIndex = viewData.length - 1;\n        const textLNode =\n            createLNode(lastNodeIndex - HEADER_OFFSET, TNodeType.Element, textRNode, null, null);\n        localPreviousNode = appendI18nNode(textLNode, localParentNode, localPreviousNode);\n        resetComponentState();\n        break;\n      case I18nInstructions.CloseNode:\n        localPreviousNode = localParentNode;\n        localParentNode = getParentLNode(localParentNode) !;\n        break;\n      case I18nInstructions.RemoveNode:\n        if (ngDevMode) {\n          ngDevMode.rendererRemoveNode++;\n        }\n        const index = instruction & I18nInstructions.IndexMask;\n        const removedNode: LNode|LContainerNode = load(index);\n        const parentNode = getParentLNode(removedNode) !;\n        removeChild(parentNode, removedNode.native || null, viewData);\n\n        // For template containers we also need to remove their `ViewContainerRef` from the DOM\n        if (removedNode.tNode.type === TNodeType.Container && removedNode.dynamicLContainerNode) {\n          removeChild(parentNode, removedNode.dynamicLContainerNode.native || null, viewData);\n          removedNode.dynamicLContainerNode.tNode.detached = true;\n          removedNode.dynamicLContainerNode.data[RENDER_PARENT] = null;\n        }\n        break;\n    }\n  }\n}\n\n/**\n * Takes a translation string and the initial list of expressions and returns a list of instructions\n * that will be used to translate an attribute.\n * Even indexes contain static strings, while odd indexes contain the index of the expression whose\n * value will be concatenated into the final translation.\n */\nexport function i18nExpMapping(\n    translation: string, placeholders: PlaceholderMap): I18nExpInstruction[] {\n  const staticText: I18nExpInstruction[] = translation.split(i18nTagRegex);\n  // odd indexes are placeholders\n  for (let i = 1; i < staticText.length; i += 2) {\n    staticText[i] = placeholders[staticText[i]];\n  }\n  return staticText;\n}\n\n/**\n * Checks if the value of an expression has changed and replaces it by its value in a translation,\n * or returns NO_CHANGE.\n *\n * @param instructions A list of instructions that will be used to translate an attribute.\n * @param v0 value checked for change.\n *\n * @returns The concatenated string when any of the arguments changes, `NO_CHANGE` otherwise.\n */\nexport function i18nInterpolation1(instructions: I18nExpInstruction[], v0: any): string|NO_CHANGE {\n  const different = bindingUpdated(_getViewData()[BINDING_INDEX]++, v0);\n\n  if (!different) {\n    return NO_CHANGE;\n  }\n\n  let res = '';\n  for (let i = 0; i < instructions.length; i++) {\n    // Odd indexes are bindings\n    if (i & 1) {\n      res += stringify(v0);\n    } else {\n      res += instructions[i];\n    }\n  }\n\n  return res;\n}\n\n/**\n * Checks if the values of up to 2 expressions have changed and replaces them by their values in a\n * translation, or returns NO_CHANGE.\n *\n * @param instructions A list of instructions that will be used to translate an attribute.\n * @param v0 value checked for change.\n * @param v1 value checked for change.\n *\n * @returns The concatenated string when any of the arguments changes, `NO_CHANGE` otherwise.\n */\nexport function i18nInterpolation2(instructions: I18nExpInstruction[], v0: any, v1: any): string|\n    NO_CHANGE {\n  const viewData = _getViewData();\n  const different = bindingUpdated2(viewData[BINDING_INDEX], v0, v1);\n  viewData[BINDING_INDEX] += 2;\n\n  if (!different) {\n    return NO_CHANGE;\n  }\n\n  let res = '';\n  for (let i = 0; i < instructions.length; i++) {\n    // Odd indexes are bindings\n    if (i & 1) {\n      // Extract bits\n      const idx = instructions[i] as number;\n      const b1 = idx & 1;\n      // Get the value from the argument vx where x = idx\n      const value = b1 ? v1 : v0;\n\n      res += stringify(value);\n    } else {\n      res += instructions[i];\n    }\n  }\n\n  return res;\n}\n\n/**\n * Checks if the values of up to 3 expressions have changed and replaces them by their values in a\n * translation, or returns NO_CHANGE.\n *\n * @param instructions A list of instructions that will be used to translate an attribute.\n * @param v0 value checked for change.\n * @param v1 value checked for change.\n * @param v2 value checked for change.\n *\n * @returns The concatenated string when any of the arguments changes, `NO_CHANGE` otherwise.\n */\nexport function i18nInterpolation3(\n    instructions: I18nExpInstruction[], v0: any, v1: any, v2: any): string|NO_CHANGE {\n  const viewData = _getViewData();\n  const different = bindingUpdated3(viewData[BINDING_INDEX], v0, v1, v2);\n  viewData[BINDING_INDEX] += 3;\n\n  if (!different) {\n    return NO_CHANGE;\n  }\n\n  let res = '';\n  for (let i = 0; i < instructions.length; i++) {\n    // Odd indexes are bindings\n    if (i & 1) {\n      // Extract bits\n      const idx = instructions[i] as number;\n      const b2 = idx & 2;\n      const b1 = idx & 1;\n      // Get the value from the argument vx where x = idx\n      const value = b2 ? v2 : (b1 ? v1 : v0);\n\n      res += stringify(value);\n    } else {\n      res += instructions[i];\n    }\n  }\n\n  return res;\n}\n\n/**\n * Checks if the values of up to 4 expressions have changed and replaces them by their values in a\n * translation, or returns NO_CHANGE.\n *\n * @param instructions A list of instructions that will be used to translate an attribute.\n * @param v0 value checked for change.\n * @param v1 value checked for change.\n * @param v2 value checked for change.\n * @param v3 value checked for change.\n *\n * @returns The concatenated string when any of the arguments changes, `NO_CHANGE` otherwise.\n */\nexport function i18nInterpolation4(\n    instructions: I18nExpInstruction[], v0: any, v1: any, v2: any, v3: any): string|NO_CHANGE {\n  const viewData = _getViewData();\n  const different = bindingUpdated4(viewData[BINDING_INDEX], v0, v1, v2, v3);\n  viewData[BINDING_INDEX] += 4;\n\n  if (!different) {\n    return NO_CHANGE;\n  }\n\n  let res = '';\n  for (let i = 0; i < instructions.length; i++) {\n    // Odd indexes are bindings\n    if (i & 1) {\n      // Extract bits\n      const idx = instructions[i] as number;\n      const b2 = idx & 2;\n      const b1 = idx & 1;\n      // Get the value from the argument vx where x = idx\n      const value = b2 ? (b1 ? v3 : v2) : (b1 ? v1 : v0);\n\n      res += stringify(value);\n    } else {\n      res += instructions[i];\n    }\n  }\n\n  return res;\n}\n\n/**\n * Checks if the values of up to 5 expressions have changed and replaces them by their values in a\n * translation, or returns NO_CHANGE.\n *\n * @param instructions A list of instructions that will be used to translate an attribute.\n * @param v0 value checked for change.\n * @param v1 value checked for change.\n * @param v2 value checked for change.\n * @param v3 value checked for change.\n * @param v4 value checked for change.\n *\n * @returns The concatenated string when any of the arguments changes, `NO_CHANGE` otherwise.\n */\nexport function i18nInterpolation5(\n    instructions: I18nExpInstruction[], v0: any, v1: any, v2: any, v3: any, v4: any): string|\n    NO_CHANGE {\n  const viewData = _getViewData();\n  let different = bindingUpdated4(viewData[BINDING_INDEX], v0, v1, v2, v3);\n  different = bindingUpdated(viewData[BINDING_INDEX] + 4, v4) || different;\n  viewData[BINDING_INDEX] += 5;\n\n  if (!different) {\n    return NO_CHANGE;\n  }\n\n  let res = '';\n  for (let i = 0; i < instructions.length; i++) {\n    // Odd indexes are bindings\n    if (i & 1) {\n      // Extract bits\n      const idx = instructions[i] as number;\n      const b4 = idx & 4;\n      const b2 = idx & 2;\n      const b1 = idx & 1;\n      // Get the value from the argument vx where x = idx\n      const value = b4 ? v4 : (b2 ? (b1 ? v3 : v2) : (b1 ? v1 : v0));\n\n      res += stringify(value);\n    } else {\n      res += instructions[i];\n    }\n  }\n\n  return res;\n}\n\n/**\n * Checks if the values of up to 6 expressions have changed and replaces them by their values in a\n * translation, or returns NO_CHANGE.\n *\n * @param instructions A list of instructions that will be used to translate an attribute.\n * @param v0 value checked for change.\n * @param v1 value checked for change.\n * @param v2 value checked for change.\n * @param v3 value checked for change.\n * @param v4 value checked for change.\n * @param v5 value checked for change.\n *\n * @returns The concatenated string when any of the arguments changes, `NO_CHANGE` otherwise.\n */ export function\ni18nInterpolation6(\n    instructions: I18nExpInstruction[], v0: any, v1: any, v2: any, v3: any, v4: any, v5: any):\n    string|NO_CHANGE {\n  const viewData = _getViewData();\n  let different = bindingUpdated4(viewData[BINDING_INDEX], v0, v1, v2, v3);\n  different = bindingUpdated2(viewData[BINDING_INDEX] + 4, v4, v5) || different;\n  viewData[BINDING_INDEX] += 6;\n\n  if (!different) {\n    return NO_CHANGE;\n  }\n\n  let res = '';\n  for (let i = 0; i < instructions.length; i++) {\n    // Odd indexes are bindings\n    if (i & 1) {\n      // Extract bits\n      const idx = instructions[i] as number;\n      const b4 = idx & 4;\n      const b2 = idx & 2;\n      const b1 = idx & 1;\n      // Get the value from the argument vx where x = idx\n      const value = b4 ? (b1 ? v5 : v4) : (b2 ? (b1 ? v3 : v2) : (b1 ? v1 : v0));\n\n      res += stringify(value);\n    } else {\n      res += instructions[i];\n    }\n  }\n\n  return res;\n}\n\n/**\n * Checks if the values of up to 7 expressions have changed and replaces them by their values in a\n * translation, or returns NO_CHANGE.\n *\n * @param instructions A list of instructions that will be used to translate an attribute.\n * @param v0 value checked for change.\n * @param v1 value checked for change.\n * @param v2 value checked for change.\n * @param v3 value checked for change.\n * @param v4 value checked for change.\n * @param v5 value checked for change.\n * @param v6 value checked for change.\n *\n * @returns The concatenated string when any of the arguments changes, `NO_CHANGE` otherwise.\n */\nexport function i18nInterpolation7(\n    instructions: I18nExpInstruction[], v0: any, v1: any, v2: any, v3: any, v4: any, v5: any,\n    v6: any): string|NO_CHANGE {\n  const viewData = _getViewData();\n  let different = bindingUpdated4(viewData[BINDING_INDEX], v0, v1, v2, v3);\n  different = bindingUpdated3(viewData[BINDING_INDEX] + 4, v4, v5, v6) || different;\n  viewData[BINDING_INDEX] += 7;\n\n  if (!different) {\n    return NO_CHANGE;\n  }\n\n  let res = '';\n  for (let i = 0; i < instructions.length; i++) {\n    // Odd indexes are bindings\n    if (i & 1) {\n      // Extract bits\n      const idx = instructions[i] as number;\n      const b4 = idx & 4;\n      const b2 = idx & 2;\n      const b1 = idx & 1;\n      // Get the value from the argument vx where x = idx\n      const value = b4 ? (b2 ? v6 : (b1 ? v5 : v4)) : (b2 ? (b1 ? v3 : v2) : (b1 ? v1 : v0));\n\n      res += stringify(value);\n    } else {\n      res += instructions[i];\n    }\n  }\n\n  return res;\n}\n\n/**\n * Checks if the values of up to 8 expressions have changed and replaces them by their values in a\n * translation, or returns NO_CHANGE.\n *\n * @param instructions A list of instructions that will be used to translate an attribute.\n * @param v0 value checked for change.\n * @param v1 value checked for change.\n * @param v2 value checked for change.\n * @param v3 value checked for change.\n * @param v4 value checked for change.\n * @param v5 value checked for change.\n * @param v6 value checked for change.\n * @param v7 value checked for change.\n *\n * @returns The concatenated string when any of the arguments changes, `NO_CHANGE` otherwise.\n */\nexport function i18nInterpolation8(\n    instructions: I18nExpInstruction[], v0: any, v1: any, v2: any, v3: any, v4: any, v5: any,\n    v6: any, v7: any): string|NO_CHANGE {\n  const viewData = _getViewData();\n  let different = bindingUpdated4(viewData[BINDING_INDEX], v0, v1, v2, v3);\n  different = bindingUpdated4(viewData[BINDING_INDEX] + 4, v4, v5, v6, v7) || different;\n  viewData[BINDING_INDEX] += 8;\n\n  if (!different) {\n    return NO_CHANGE;\n  }\n\n  let res = '';\n  for (let i = 0; i < instructions.length; i++) {\n    // Odd indexes are bindings\n    if (i & 1) {\n      // Extract bits\n      const idx = instructions[i] as number;\n      const b4 = idx & 4;\n      const b2 = idx & 2;\n      const b1 = idx & 1;\n      // Get the value from the argument vx where x = idx\n      const value =\n          b4 ? (b2 ? (b1 ? v7 : v6) : (b1 ? v5 : v4)) : (b2 ? (b1 ? v3 : v2) : (b1 ? v1 : v0));\n\n      res += stringify(value);\n    } else {\n      res += instructions[i];\n    }\n  }\n\n  return res;\n}\n\n/**\n * Create a translated interpolation binding with a variable number of expressions.\n *\n * If there are 1 to 8 expressions then `i18nInterpolation()` should be used instead. It is faster\n * because there is no need to create an array of expressions and iterate over it.\n *\n * @returns The concatenated string when any of the arguments changes, `NO_CHANGE` otherwise.\n */\nexport function i18nInterpolationV(instructions: I18nExpInstruction[], values: any[]): string|\n    NO_CHANGE {\n  const viewData = _getViewData();\n  let different = false;\n  for (let i = 0; i < values.length; i++) {\n    // Check if bindings have changed\n    bindingUpdated(viewData[BINDING_INDEX]++, values[i]) && (different = true);\n  }\n\n  if (!different) {\n    return NO_CHANGE;\n  }\n\n  let res = '';\n  for (let i = 0; i < instructions.length; i++) {\n    // Odd indexes are placeholders\n    if (i & 1) {\n      res += stringify(values[instructions[i] as number]);\n    } else {\n      res += instructions[i];\n    }\n  }\n\n  return res;\n}\n"]}