{"version":3,"file":"injector.js","sourceRoot":"","sources":["../../../../../../packages/core/src/di/injector.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Type} from '../type';\nimport {stringify} from '../util';\n\nimport {InjectableDef, defineInjectable} from './defs';\nimport {resolveForwardRef} from './forward_ref';\nimport {InjectionToken} from './injection_token';\nimport {Inject, Optional, Self, SkipSelf} from './metadata';\nimport {ConstructorProvider, ExistingProvider, FactoryProvider, StaticClassProvider, StaticProvider, ValueProvider} from './provider';\n\nexport const SOURCE = '__source';\nconst _THROW_IF_NOT_FOUND = new Object();\nexport const THROW_IF_NOT_FOUND = _THROW_IF_NOT_FOUND;\n\n/**\n * An InjectionToken that gets the current `Injector` for `createInjector()`-style injectors.\n *\n * Requesting this token instead of `Injector` allows `StaticInjector` to be tree-shaken from a\n * project.\n *\n * @experimental\n */\nexport const INJECTOR = new InjectionToken<Injector>('INJECTOR');\n\nexport class NullInjector implements Injector {\n  get(token: any, notFoundValue: any = _THROW_IF_NOT_FOUND): any {\n    if (notFoundValue === _THROW_IF_NOT_FOUND) {\n      // Intentionally left behind: With dev tools open the debugger will stop here. There is no\n      // reason why correctly written application should cause this exception.\n      // TODO(misko): uncomment the next line once `ngDevMode` works with closure.\n      // if(ngDevMode) debugger;\n      throw new Error(`NullInjectorError: No provider for ${stringify(token)}!`);\n    }\n    return notFoundValue;\n  }\n}\n\n/**\n * Concrete injectors implement this interface.\n *\n * For more details, see the [\"Dependency Injection Guide\"](guide/dependency-injection).\n *\n * @usageNotes\n * ### Example\n *\n * {@example core/di/ts/injector_spec.ts region='Injector'}\n *\n * `Injector` returns itself when given `Injector` as a token:\n *\n * {@example core/di/ts/injector_spec.ts region='injectInjector'}\n *\n *\n */\nexport abstract class Injector {\n  static THROW_IF_NOT_FOUND = _THROW_IF_NOT_FOUND;\n  static NULL: Injector = new NullInjector();\n\n  /**\n   * Retrieves an instance from the injector based on the provided token.\n   * @returns The instance from the injector if defined, otherwise the `notFoundValue`.\n   * @throws When the `notFoundValue` is `undefined` or `Injector.THROW_IF_NOT_FOUND`.\n   */\n  abstract get<T>(token: Type<T>|InjectionToken<T>, notFoundValue?: T, flags?: InjectFlags): T;\n  /**\n   * @deprecated from v4.0.0 use Type<T> or InjectionToken<T>\n   * @suppress {duplicate}\n   */\n  abstract get(token: any, notFoundValue?: any): any;\n\n  /**\n   * @deprecated from v5 use the new signature Injector.create(options)\n   */\n  static create(providers: StaticProvider[], parent?: Injector): Injector;\n\n  static create(options: {providers: StaticProvider[], parent?: Injector, name?: string}): Injector;\n\n  /**\n   * Create a new Injector which is configure using `StaticProvider`s.\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * {@example core/di/ts/provider_spec.ts region='ConstructorProvider'}\n   */\n  static create(\n      options: StaticProvider[]|{providers: StaticProvider[], parent?: Injector, name?: string},\n      parent?: Injector): Injector {\n    if (Array.isArray(options)) {\n      return new StaticInjector(options, parent);\n    } else {\n      return new StaticInjector(options.providers, options.parent, options.name || null);\n    }\n  }\n\n  static ngInjectableDef = defineInjectable({\n    providedIn: 'any' as any,\n    factory: () => inject(INJECTOR),\n  });\n}\n\n\n\nconst IDENT = function<T>(value: T): T {\n  return value;\n};\nconst EMPTY = <any[]>[];\nconst CIRCULAR = IDENT;\nconst MULTI_PROVIDER_FN = function(): any[] {\n  return Array.prototype.slice.call(arguments);\n};\nconst GET_PROPERTY_NAME = {} as any;\nexport const USE_VALUE =\n    getClosureSafeProperty<ValueProvider>({provide: String, useValue: GET_PROPERTY_NAME});\nconst NG_TOKEN_PATH = 'ngTokenPath';\nconst NG_TEMP_TOKEN_PATH = 'ngTempTokenPath';\nconst enum OptionFlags {\n  Optional = 1 << 0,\n  CheckSelf = 1 << 1,\n  CheckParent = 1 << 2,\n  Default = CheckSelf | CheckParent\n}\nconst NULL_INJECTOR = Injector.NULL;\nconst NEW_LINE = /\\n/gm;\nconst NO_NEW_LINE = 'ɵ';\n\nexport class StaticInjector implements Injector {\n  readonly parent: Injector;\n  readonly source: string|null;\n\n  private _records: Map<any, Record>;\n\n  constructor(\n      providers: StaticProvider[], parent: Injector = NULL_INJECTOR, source: string|null = null) {\n    this.parent = parent;\n    this.source = source;\n    const records = this._records = new Map<any, Record>();\n    records.set(\n        Injector, <Record>{token: Injector, fn: IDENT, deps: EMPTY, value: this, useNew: false});\n    records.set(\n        INJECTOR, <Record>{token: INJECTOR, fn: IDENT, deps: EMPTY, value: this, useNew: false});\n    recursivelyProcessProviders(records, providers);\n  }\n\n  get<T>(token: Type<T>|InjectionToken<T>, notFoundValue?: T, flags?: InjectFlags): T;\n  get(token: any, notFoundValue?: any): any;\n  get(token: any, notFoundValue?: any, flags: InjectFlags = InjectFlags.Default): any {\n    const record = this._records.get(token);\n    try {\n      return tryResolveToken(token, record, this._records, this.parent, notFoundValue, flags);\n    } catch (e) {\n      const tokenPath: any[] = e[NG_TEMP_TOKEN_PATH];\n      if (token[SOURCE]) {\n        tokenPath.unshift(token[SOURCE]);\n      }\n      e.message = formatError('\\n' + e.message, tokenPath, this.source);\n      e[NG_TOKEN_PATH] = tokenPath;\n      e[NG_TEMP_TOKEN_PATH] = null;\n      throw e;\n    }\n  }\n\n  toString() {\n    const tokens = <string[]>[], records = this._records;\n    records.forEach((v, token) => tokens.push(stringify(token)));\n    return `StaticInjector[${tokens.join(', ')}]`;\n  }\n}\n\ntype SupportedProvider =\n    ValueProvider | ExistingProvider | StaticClassProvider | ConstructorProvider | FactoryProvider;\n\ninterface Record {\n  fn: Function;\n  useNew: boolean;\n  deps: DependencyRecord[];\n  value: any;\n}\n\ninterface DependencyRecord {\n  token: any;\n  options: number;\n}\n\ntype TokenPath = Array<any>;\n\nfunction resolveProvider(provider: SupportedProvider): Record {\n  const deps = computeDeps(provider);\n  let fn: Function = IDENT;\n  let value: any = EMPTY;\n  let useNew: boolean = false;\n  let provide = resolveForwardRef(provider.provide);\n  if (USE_VALUE in provider) {\n    // We need to use USE_VALUE in provider since provider.useValue could be defined as undefined.\n    value = (provider as ValueProvider).useValue;\n  } else if ((provider as FactoryProvider).useFactory) {\n    fn = (provider as FactoryProvider).useFactory;\n  } else if ((provider as ExistingProvider).useExisting) {\n    // Just use IDENT\n  } else if ((provider as StaticClassProvider).useClass) {\n    useNew = true;\n    fn = resolveForwardRef((provider as StaticClassProvider).useClass);\n  } else if (typeof provide == 'function') {\n    useNew = true;\n    fn = provide;\n  } else {\n    throw staticError(\n        'StaticProvider does not have [useValue|useFactory|useExisting|useClass] or [provide] is not newable',\n        provider);\n  }\n  return {deps, fn, useNew, value};\n}\n\nfunction multiProviderMixError(token: any) {\n  return staticError('Cannot mix multi providers and regular providers', token);\n}\n\nfunction recursivelyProcessProviders(records: Map<any, Record>, provider: StaticProvider) {\n  if (provider) {\n    provider = resolveForwardRef(provider);\n    if (provider instanceof Array) {\n      // if we have an array recurse into the array\n      for (let i = 0; i < provider.length; i++) {\n        recursivelyProcessProviders(records, provider[i]);\n      }\n    } else if (typeof provider === 'function') {\n      // Functions were supported in ReflectiveInjector, but are not here. For safety give useful\n      // error messages\n      throw staticError('Function/Class not supported', provider);\n    } else if (provider && typeof provider === 'object' && provider.provide) {\n      // At this point we have what looks like a provider: {provide: ?, ....}\n      let token = resolveForwardRef(provider.provide);\n      const resolvedProvider = resolveProvider(provider);\n      if (provider.multi === true) {\n        // This is a multi provider.\n        let multiProvider: Record|undefined = records.get(token);\n        if (multiProvider) {\n          if (multiProvider.fn !== MULTI_PROVIDER_FN) {\n            throw multiProviderMixError(token);\n          }\n        } else {\n          // Create a placeholder factory which will look up the constituents of the multi provider.\n          records.set(token, multiProvider = <Record>{\n            token: provider.provide,\n            deps: [],\n            useNew: false,\n            fn: MULTI_PROVIDER_FN,\n            value: EMPTY\n          });\n        }\n        // Treat the provider as the token.\n        token = provider;\n        multiProvider.deps.push({token, options: OptionFlags.Default});\n      }\n      const record = records.get(token);\n      if (record && record.fn == MULTI_PROVIDER_FN) {\n        throw multiProviderMixError(token);\n      }\n      records.set(token, resolvedProvider);\n    } else {\n      throw staticError('Unexpected provider', provider);\n    }\n  }\n}\n\nfunction tryResolveToken(\n    token: any, record: Record | undefined, records: Map<any, Record>, parent: Injector,\n    notFoundValue: any, flags: InjectFlags): any {\n  try {\n    return resolveToken(token, record, records, parent, notFoundValue, flags);\n  } catch (e) {\n    // ensure that 'e' is of type Error.\n    if (!(e instanceof Error)) {\n      e = new Error(e);\n    }\n    const path: any[] = e[NG_TEMP_TOKEN_PATH] = e[NG_TEMP_TOKEN_PATH] || [];\n    path.unshift(token);\n    if (record && record.value == CIRCULAR) {\n      // Reset the Circular flag.\n      record.value = EMPTY;\n    }\n    throw e;\n  }\n}\n\nfunction resolveToken(\n    token: any, record: Record | undefined, records: Map<any, Record>, parent: Injector,\n    notFoundValue: any, flags: InjectFlags): any {\n  let value;\n  if (record && !(flags & InjectFlags.SkipSelf)) {\n    // If we don't have a record, this implies that we don't own the provider hence don't know how\n    // to resolve it.\n    value = record.value;\n    if (value == CIRCULAR) {\n      throw Error(NO_NEW_LINE + 'Circular dependency');\n    } else if (value === EMPTY) {\n      record.value = CIRCULAR;\n      let obj = undefined;\n      let useNew = record.useNew;\n      let fn = record.fn;\n      let depRecords = record.deps;\n      let deps = EMPTY;\n      if (depRecords.length) {\n        deps = [];\n        for (let i = 0; i < depRecords.length; i++) {\n          const depRecord: DependencyRecord = depRecords[i];\n          const options = depRecord.options;\n          const childRecord =\n              options & OptionFlags.CheckSelf ? records.get(depRecord.token) : undefined;\n          deps.push(tryResolveToken(\n              // Current Token to resolve\n              depRecord.token,\n              // A record which describes how to resolve the token.\n              // If undefined, this means we don't have such a record\n              childRecord,\n              // Other records we know about.\n              records,\n              // If we don't know how to resolve dependency and we should not check parent for it,\n              // than pass in Null injector.\n              !childRecord && !(options & OptionFlags.CheckParent) ? NULL_INJECTOR : parent,\n              options & OptionFlags.Optional ? null : Injector.THROW_IF_NOT_FOUND,\n              InjectFlags.Default));\n        }\n      }\n      record.value = value = useNew ? new (fn as any)(...deps) : fn.apply(obj, deps);\n    }\n  } else if (!(flags & InjectFlags.Self)) {\n    value = parent.get(token, notFoundValue, InjectFlags.Default);\n  }\n  return value;\n}\n\n\nfunction computeDeps(provider: StaticProvider): DependencyRecord[] {\n  let deps: DependencyRecord[] = EMPTY;\n  const providerDeps: any[] =\n      (provider as ExistingProvider & StaticClassProvider & ConstructorProvider).deps;\n  if (providerDeps && providerDeps.length) {\n    deps = [];\n    for (let i = 0; i < providerDeps.length; i++) {\n      let options = OptionFlags.Default;\n      let token = resolveForwardRef(providerDeps[i]);\n      if (token instanceof Array) {\n        for (let j = 0, annotations = token; j < annotations.length; j++) {\n          const annotation = annotations[j];\n          if (annotation instanceof Optional || annotation == Optional) {\n            options = options | OptionFlags.Optional;\n          } else if (annotation instanceof SkipSelf || annotation == SkipSelf) {\n            options = options & ~OptionFlags.CheckSelf;\n          } else if (annotation instanceof Self || annotation == Self) {\n            options = options & ~OptionFlags.CheckParent;\n          } else if (annotation instanceof Inject) {\n            token = (annotation as Inject).token;\n          } else {\n            token = resolveForwardRef(annotation);\n          }\n        }\n      }\n      deps.push({token, options});\n    }\n  } else if ((provider as ExistingProvider).useExisting) {\n    const token = resolveForwardRef((provider as ExistingProvider).useExisting);\n    deps = [{token, options: OptionFlags.Default}];\n  } else if (!providerDeps && !(USE_VALUE in provider)) {\n    // useValue & useExisting are the only ones which are exempt from deps all others need it.\n    throw staticError('\\'deps\\' required', provider);\n  }\n  return deps;\n}\n\nfunction formatError(text: string, obj: any, source: string | null = null): string {\n  text = text && text.charAt(0) === '\\n' && text.charAt(1) == NO_NEW_LINE ? text.substr(2) : text;\n  let context = stringify(obj);\n  if (obj instanceof Array) {\n    context = obj.map(stringify).join(' -> ');\n  } else if (typeof obj === 'object') {\n    let parts = <string[]>[];\n    for (let key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        let value = obj[key];\n        parts.push(\n            key + ':' + (typeof value === 'string' ? JSON.stringify(value) : stringify(value)));\n      }\n    }\n    context = `{${parts.join(', ')}}`;\n  }\n  return `StaticInjectorError${source ? '(' + source + ')' : ''}[${context}]: ${text.replace(NEW_LINE, '\\n  ')}`;\n}\n\nfunction staticError(text: string, obj: any): Error {\n  return new Error(formatError(text, obj));\n}\n\nfunction getClosureSafeProperty<T>(objWithPropertyToExtract: T): string {\n  for (let key in objWithPropertyToExtract) {\n    if (objWithPropertyToExtract[key] === GET_PROPERTY_NAME) {\n      return key;\n    }\n  }\n  throw Error('!prop');\n}\n\n/**\n * Injection flags for DI.\n */\nexport const enum InjectFlags {\n  Default = 0b0000,\n\n  /**\n   * Specifies that an injector should retrieve a dependency from any injector until reaching the\n   * host element of the current component. (Only used with Element Injector)\n   */\n  Host = 0b0001,\n  /** Don't descend into ancestors of the node requesting injection. */\n  Self = 0b0010,\n  /** Skip the node that is requesting injection. */\n  SkipSelf = 0b0100,\n  /** Inject `defaultValue` instead if token not found. */\n  Optional = 0b1000,\n}\n\n/**\n * Current injector value used by `inject`.\n * - `undefined`: it is an error to call `inject`\n * - `null`: `inject` can be called but there is no injector (limp-mode).\n * - Injector instance: Use the injector for resolution.\n */\nlet _currentInjector: Injector|undefined|null = undefined;\n\nexport function setCurrentInjector(injector: Injector | null | undefined): Injector|undefined|null {\n  const former = _currentInjector;\n  _currentInjector = injector;\n  return former;\n}\n\n/**\n * Injects a token from the currently active injector.\n *\n * This function must be used in the context of a factory function such as one defined for an\n * `InjectionToken`, and will throw an error if not called from such a context.\n *\n * @usageNotes\n * ### Example\n *\n * {@example core/di/ts/injector_spec.ts region='ShakeableInjectionToken'}\n *\n * Within such a factory function `inject` is utilized to request injection of a dependency, instead\n * of providing an additional array of dependencies as was common to do with `useFactory` providers.\n * `inject` is faster and more type-safe.\n *\n * @experimental\n */\nexport function inject<T>(token: Type<T>| InjectionToken<T>): T;\nexport function inject<T>(token: Type<T>| InjectionToken<T>, flags?: InjectFlags): T|null;\nexport function inject<T>(token: Type<T>| InjectionToken<T>, flags = InjectFlags.Default): T|null {\n  if (_currentInjector === undefined) {\n    throw new Error(`inject() must be called from an injection context`);\n  } else if (_currentInjector === null) {\n    const injectableDef: InjectableDef<T> = (token as any).ngInjectableDef;\n    if (injectableDef && injectableDef.providedIn == 'root') {\n      return injectableDef.value === undefined ? injectableDef.value = injectableDef.factory() :\n                                                 injectableDef.value;\n    }\n    if (flags & InjectFlags.Optional) return null;\n    throw new Error(`Injector: NOT_FOUND [${stringify(token)}]`);\n  } else {\n    return _currentInjector.get(token, flags & InjectFlags.Optional ? null : undefined, flags);\n  }\n}\n\nexport function injectArgs(types: (Type<any>| InjectionToken<any>| any[])[]): any[] {\n  const args: any[] = [];\n  for (let i = 0; i < types.length; i++) {\n    const arg = types[i];\n    if (Array.isArray(arg)) {\n      if (arg.length === 0) {\n        throw new Error('Arguments array must have arguments.');\n      }\n      let type: Type<any>|undefined = undefined;\n      let flags: InjectFlags = InjectFlags.Default;\n\n      for (let j = 0; j < arg.length; j++) {\n        const meta = arg[j];\n        if (meta instanceof Optional || meta.ngMetadataName === 'Optional') {\n          flags |= InjectFlags.Optional;\n        } else if (meta instanceof SkipSelf || meta.ngMetadataName === 'SkipSelf') {\n          flags |= InjectFlags.SkipSelf;\n        } else if (meta instanceof Self || meta.ngMetadataName === 'Self') {\n          flags |= InjectFlags.Self;\n        } else if (meta instanceof Inject) {\n          type = meta.token;\n        } else {\n          type = meta;\n        }\n      }\n\n      args.push(inject(type !, flags));\n    } else {\n      args.push(inject(arg));\n    }\n  }\n  return args;\n}\n"]}