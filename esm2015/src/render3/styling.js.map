{"version":3,"file":"styling.js","sourceRoot":"","sources":["../../../../../packages/core/src/render3/styling.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {StyleSanitizeFn} from '../sanitization/style_sanitizer';\nimport {InitialStylingFlags} from './interfaces/definition';\nimport {LElementNode} from './interfaces/node';\nimport {Renderer3, RendererStyleFlags3, isProceduralRenderer} from './interfaces/renderer';\n\n\n/**\n * The styling context acts as a styling manifest (shaped as an array) for determining which\n * styling properties have been assigned via the provided `updateStylingMap`, `updateStyleProp`\n * and `updateClassProp` functions. There are also two initialization functions\n * `allocStylingContext` and `createStylingContextTemplate` which are used to initialize\n * and/or clone the context.\n *\n * The context is an array where the first two cells are used for static data (initial styling)\n * and dirty flags / index offsets). The remaining set of cells is used for multi (map) and single\n * (prop) style values.\n *\n * each value from here onwards is mapped as so:\n * [i] = mutation/type flag for the style/class value\n * [i + 1] = prop string (or null incase it has been removed)\n * [i + 2] = value string (or null incase it has been removed)\n *\n * There are three types of styling types stored in this context:\n *   initial: any styles that are passed in once the context is created\n *            (these are stored in the first cell of the array and the first\n *             value of this array is always `null` even if no initial styling exists.\n *             the `null` value is there so that any new styles have a parent to point\n *             to. This way we can always assume that there is a parent.)\n *\n *   single: any styles that are updated using `updateStyleProp` or `updateClassProp` (fixed set)\n *\n *   multi: any styles that are updated using `updateStylingMap` (dynamic set)\n *\n * Note that context is only used to collect style information. Only when `renderStyling`\n * is called is when the styling payload will be rendered (or built as a key/value map).\n *\n * When the context is created, depending on what initial styling values are passed in, the\n * context itself will be pre-filled with slots based on the initial style properties. Say\n * for example we have a series of initial styles that look like so:\n *\n *   style=\"width:100px; height:200px;\"\n *   class=\"foo\"\n *\n * Then the initial state of the context (once initialized) will look like so:\n *\n * ```\n * context = [\n *   element,\n *   styleSanitizer | null,\n *   [null, '100px', '200px', true],  // property names are not needed since they have already been\n * written to DOM.\n *\n *   configMasterVal,\n *   1, // this instructs how many `style` values there are so that class index values can be\n * offsetted\n *   'last class string applied',\n *\n *   // 6\n *   'width',\n *   pointers(1, 15);  // Point to static `width`: `100px` and multi `width`.\n *   null,\n *\n *   // 9\n *   'height',\n *   pointers(2, 18); // Point to static `height`: `200px` and multi `height`.\n *   null,\n *\n *   // 12\n *   'foo',\n *   pointers(1, 21);  // Point to static `foo`: `true` and multi `foo`.\n *   null,\n *\n *   // 15\n *   'width',\n *   pointers(1, 6);  // Point to static `width`: `100px` and single `width`.\n *   null,\n *\n *   // 18\n *   'height',\n *   pointers(2, 9);  // Point to static `height`: `200px` and single `height`.\n *   null,\n *\n *   // 21\n *   'foo',\n *   pointers(3, 12);  // Point to static `foo`: `true` and single `foo`.\n *   null,\n * ]\n *\n * function pointers(staticIndex: number, dynamicIndex: number) {\n *   // combine the two indices into a single word.\n *   return (staticIndex << StylingFlags.BitCountSize) |\n *     (dynamicIndex << (StylingIndex.BitCountSize + StylingFlags.BitCountSize));\n * }\n * ```\n *\n * The values are duplicated so that space is set aside for both multi ([style] and [class])\n * and single ([style.prop] or [class.named]) values. The respective config values\n * (configValA, configValB, etc...) are a combination of the StylingFlags with two index\n * values: the `initialIndex` (which points to the index location of the style value in\n * the initial styles array in slot 0) and the `dynamicIndex` (which points to the\n * matching single/multi index position in the context array for the same prop).\n *\n * This means that every time `updateStyleProp` or `updateClassProp` are called then they\n * must be called using an index value (not a property string) which references the index\n * value of the initial style prop/class when the context was created. This also means that\n * `updateStyleProp` or `updateClassProp` cannot be called with a new property (only\n * `updateStylingMap` can include new CSS properties that will be added to the context).\n */\nexport interface StylingContext extends\n    Array<InitialStyles|number|string|boolean|LElementNode|StyleSanitizeFn|null> {\n  /**\n   * Location of element that is used as a target for this context.\n   */\n  [0]: LElementNode|null;\n\n  /**\n   * The style sanitizer that is used within this context\n   */\n  [1]: StyleSanitizeFn|null;\n\n  /**\n   * Location of initial data shared by all instances of this style.\n   */\n  [2]: InitialStyles;\n\n  /**\n   * A numeric value representing the configuration status (whether the context is dirty or not)\n   * mixed together (using bit shifting) with a index value which tells the starting index value\n   * of where the multi style entries begin.\n   */\n  [3]: number;\n\n  /**\n   * A numeric value representing the class index offset value. Whenever a single class is\n   * applied (using `elementClassProp`) it should have an styling index value that doesn't\n   * need to take into account any style values that exist in the context.\n   */\n  [4]: number;\n\n  /**\n   * The last CLASS STRING VALUE that was interpreted by elementStylingMap. This is cached\n   * So that the algorithm can exit early incase the string has not changed.\n   */\n  [5]: string|null;\n}\n\n/**\n * The initial styles is populated whether or not there are any initial styles passed into\n * the context during allocation. The 0th value must be null so that index values of `0` within\n * the context flags can always point to a null value safely when nothing is set.\n *\n * All other entries in this array are of `string` value and correspond to the values that\n * were extracted from the `style=\"\"` attribute in the HTML code for the provided template.\n */\nexport interface InitialStyles extends Array<string|null|boolean> { [0]: null; }\n\n/**\n * Used to set the context to be dirty or not both on the master flag (position 1)\n * or for each single/multi property that exists in the context.\n */\nexport const enum StylingFlags {\n  // Implies no configurations\n  None = 0b000,\n  // Whether or not the entry or context itself is dirty\n  Dirty = 0b001,\n  // Whether or not this is a class-based assignment\n  Class = 0b010,\n  // Whether or not a sanitizer was applied to this property\n  Sanitize = 0b100,\n  // The max amount of bits used to represent these configuration values\n  BitCountSize = 3,\n  // There are only three bits here\n  BitMask = 0b111\n}\n\n/** Used as numeric pointer values to determine what cells to update in the `StylingContext` */\nexport const enum StylingIndex {\n  // Position of where the initial styles are stored in the styling context\n  ElementPosition = 0,\n  // Position of where the style sanitizer is stored within the styling context\n  StyleSanitizerPosition = 1,\n  // Position of where the initial styles are stored in the styling context\n  InitialStylesPosition = 2,\n  // Index of location where the start of single properties are stored. (`updateStyleProp`)\n  MasterFlagPosition = 3,\n  // Index of location where the class index offset value is located\n  ClassOffsetPosition = 4,\n  // Position of where the last string-based CSS class value was stored\n  CachedCssClassString = 5,\n  // Location of single (prop) value entries are stored within the context\n  SingleStylesStartPosition = 6,\n  // Multi and single entries are stored in `StylingContext` as: Flag; PropertyName;  PropertyValue\n  FlagsOffset = 0,\n  PropertyOffset = 1,\n  ValueOffset = 2,\n  // Size of each multi or single entry (flag + prop + value)\n  Size = 3,\n  // Each flag has a binary digit length of this value\n  BitCountSize = 14,  // (32 - 3) / 2 = ~14\n  // The binary digit value as a mask\n  BitMask = 0b11111111111111  // 14 bits\n}\n\n/**\n * Used clone a copy of a pre-computed template of a styling context.\n *\n * A pre-computed template is designed to be computed once for a given element\n * (instructions.ts has logic for caching this).\n */\nexport function allocStylingContext(\n    lElement: LElementNode | null, templateStyleContext: StylingContext): StylingContext {\n  // each instance gets a copy\n  const context = templateStyleContext.slice() as any as StylingContext;\n  context[StylingIndex.ElementPosition] = lElement;\n  return context;\n}\n\n/**\n * Creates a styling context template where styling information is stored.\n * Any styles that are later referenced using `updateStyleProp` must be\n * passed in within this function. Initial values for those styles are to\n * be declared after all initial style properties are declared (this change in\n * mode between declarations and initial styles is made possible using a special\n * enum value found in `definition.ts`).\n *\n * @param initialStyleDeclarations a list of style declarations and initial style values\n *    that are used later within the styling context.\n *\n *    -> ['width', 'height', SPECIAL_ENUM_VAL, 'width', '100px']\n *       This implies that `width` and `height` will be later styled and that the `width`\n *       property has an initial value of `100px`.\n *\n * @param initialClassDeclarations a list of class declarations and initial class values\n *    that are used later within the styling context.\n *\n *    -> ['foo', 'bar', SPECIAL_ENUM_VAL, 'foo', true]\n *       This implies that `foo` and `bar` will be later styled and that the `foo`\n *       class will be applied to the element as an initial class since it's true\n */\nexport function createStylingContextTemplate(\n    initialClassDeclarations?: (string | boolean | InitialStylingFlags)[] | null,\n    initialStyleDeclarations?: (string | boolean | InitialStylingFlags)[] | null,\n    styleSanitizer?: StyleSanitizeFn | null): StylingContext {\n  const initialStylingValues: InitialStyles = [null];\n  const context: StylingContext = [null, styleSanitizer || null, initialStylingValues, 0, 0, null];\n\n  // we use two maps since a class name might collide with a CSS style prop\n  const stylesLookup: {[key: string]: number} = {};\n  const classesLookup: {[key: string]: number} = {};\n\n  let totalStyleDeclarations = 0;\n  if (initialStyleDeclarations) {\n    let hasPassedDeclarations = false;\n    for (let i = 0; i < initialStyleDeclarations.length; i++) {\n      const v = initialStyleDeclarations[i] as string | InitialStylingFlags;\n\n      // this flag value marks where the declarations end the initial values begin\n      if (v === InitialStylingFlags.VALUES_MODE) {\n        hasPassedDeclarations = true;\n      } else {\n        const prop = v as string;\n        if (hasPassedDeclarations) {\n          const value = initialStyleDeclarations[++i] as string;\n          initialStylingValues.push(value);\n          stylesLookup[prop] = initialStylingValues.length - 1;\n        } else {\n          totalStyleDeclarations++;\n          stylesLookup[prop] = 0;\n        }\n      }\n    }\n  }\n\n  // make where the class offsets begin\n  context[StylingIndex.ClassOffsetPosition] = totalStyleDeclarations;\n\n  if (initialClassDeclarations) {\n    let hasPassedDeclarations = false;\n    for (let i = 0; i < initialClassDeclarations.length; i++) {\n      const v = initialClassDeclarations[i] as string | boolean | InitialStylingFlags;\n      // this flag value marks where the declarations end the initial values begin\n      if (v === InitialStylingFlags.VALUES_MODE) {\n        hasPassedDeclarations = true;\n      } else {\n        const className = v as string;\n        if (hasPassedDeclarations) {\n          const value = initialClassDeclarations[++i] as boolean;\n          initialStylingValues.push(value);\n          classesLookup[className] = initialStylingValues.length - 1;\n        } else {\n          classesLookup[className] = 0;\n        }\n      }\n    }\n  }\n\n  const styleProps = Object.keys(stylesLookup);\n  const classNames = Object.keys(classesLookup);\n  const classNamesIndexStart = styleProps.length;\n  const totalProps = styleProps.length + classNames.length;\n\n  // *2 because we are filling for both single and multi style spaces\n  const maxLength = totalProps * StylingIndex.Size * 2 + StylingIndex.SingleStylesStartPosition;\n\n  // we need to fill the array from the start so that we can access\n  // both the multi and the single array positions in the same loop block\n  for (let i = StylingIndex.SingleStylesStartPosition; i < maxLength; i++) {\n    context.push(null);\n  }\n\n  const singleStart = StylingIndex.SingleStylesStartPosition;\n  const multiStart = totalProps * StylingIndex.Size + StylingIndex.SingleStylesStartPosition;\n\n  // fill single and multi-level styles\n  for (let i = 0; i < totalProps; i++) {\n    const isClassBased = i >= classNamesIndexStart;\n    const prop = isClassBased ? classNames[i - classNamesIndexStart] : styleProps[i];\n    const indexForInitial = isClassBased ? classesLookup[prop] : stylesLookup[prop];\n    const initialValue = initialStylingValues[indexForInitial];\n\n    const indexForMulti = i * StylingIndex.Size + multiStart;\n    const indexForSingle = i * StylingIndex.Size + singleStart;\n    const initialFlag = prepareInitialFlag(prop, isClassBased, styleSanitizer || null);\n\n    setFlag(context, indexForSingle, pointers(initialFlag, indexForInitial, indexForMulti));\n    setProp(context, indexForSingle, prop);\n    setValue(context, indexForSingle, null);\n\n    const flagForMulti =\n        initialFlag | (initialValue !== null ? StylingFlags.Dirty : StylingFlags.None);\n    setFlag(context, indexForMulti, pointers(flagForMulti, indexForInitial, indexForSingle));\n    setProp(context, indexForMulti, prop);\n    setValue(context, indexForMulti, null);\n  }\n\n  // there is no initial value flag for the master index since it doesn't\n  // reference an initial style value\n  setFlag(context, StylingIndex.MasterFlagPosition, pointers(0, 0, multiStart));\n  setContextDirty(context, initialStylingValues.length > 1);\n\n  return context;\n}\n\nconst EMPTY_ARR: any[] = [];\nconst EMPTY_OBJ: {[key: string]: any} = {};\n/**\n * Sets and resolves all `multi` styling on an `StylingContext` so that they can be\n * applied to the element once `renderStyling` is called.\n *\n * All missing styles/class (any values that are not provided in the new `styles`\n * or `classes` params) will resolve to `null` within their respective positions\n * in the context.\n *\n * @param context The styling context that will be updated with the\n *    newly provided style values.\n * @param classes The key/value map of CSS class names that will be used for the update.\n * @param styles The key/value map of CSS styles that will be used for the update.\n */\nexport function updateStylingMap(\n    context: StylingContext, classes: {[key: string]: any} | string | null,\n    styles?: {[key: string]: any} | null): void {\n  let classNames: string[] = EMPTY_ARR;\n  let applyAllClasses = false;\n  let ignoreAllClassUpdates = false;\n\n  // each time a string-based value pops up then it shouldn't require a deep\n  // check of what's changed.\n  if (typeof classes == 'string') {\n    const cachedClassString = context[StylingIndex.CachedCssClassString] as string | null;\n    if (cachedClassString && cachedClassString === classes) {\n      ignoreAllClassUpdates = true;\n    } else {\n      context[StylingIndex.CachedCssClassString] = classes;\n      classNames = classes.split(/\\s+/);\n      // this boolean is used to avoid having to create a key/value map of `true` values\n      // since a classname string implies that all those classes are added\n      applyAllClasses = true;\n    }\n  } else {\n    classNames = classes ? Object.keys(classes) : EMPTY_ARR;\n    context[StylingIndex.CachedCssClassString] = null;\n  }\n\n  classes = (classes || EMPTY_OBJ) as{[key: string]: any};\n\n  const styleProps = styles ? Object.keys(styles) : EMPTY_ARR;\n  styles = styles || EMPTY_OBJ;\n\n  const classesStartIndex = styleProps.length;\n  const multiStartIndex = getMultiStartIndex(context);\n\n  let dirty = false;\n  let ctxIndex = multiStartIndex;\n\n  let propIndex = 0;\n  const propLimit = styleProps.length + classNames.length;\n\n  // the main loop here will try and figure out how the shape of the provided\n  // styles differ with respect to the context. Later if the context/styles/classes\n  // are off-balance then they will be dealt in another loop after this one\n  while (ctxIndex < context.length && propIndex < propLimit) {\n    const isClassBased = propIndex >= classesStartIndex;\n\n    // when there is a cache-hit for a string-based class then we should\n    // avoid doing any work diffing any of the changes\n    if (!ignoreAllClassUpdates || !isClassBased) {\n      const adjustedPropIndex = isClassBased ? propIndex - classesStartIndex : propIndex;\n      const newProp: string =\n          isClassBased ? classNames[adjustedPropIndex] : styleProps[adjustedPropIndex];\n      const newValue: string|boolean =\n          isClassBased ? (applyAllClasses ? true : classes[newProp]) : styles[newProp];\n\n      const prop = getProp(context, ctxIndex);\n      if (prop === newProp) {\n        const value = getValue(context, ctxIndex);\n        const flag = getPointers(context, ctxIndex);\n        if (hasValueChanged(flag, value, newValue)) {\n          setValue(context, ctxIndex, newValue);\n\n          const initialValue = getInitialValue(context, flag);\n\n          // there is no point in setting this to dirty if the previously\n          // rendered value was being referenced by the initial style (or null)\n          if (initialValue !== newValue) {\n            setDirty(context, ctxIndex, true);\n            dirty = true;\n          }\n        }\n      } else {\n        const indexOfEntry = findEntryPositionByProp(context, newProp, ctxIndex);\n        if (indexOfEntry > 0) {\n          // it was found at a later point ... just swap the values\n          const valueToCompare = getValue(context, indexOfEntry);\n          const flagToCompare = getPointers(context, indexOfEntry);\n          swapMultiContextEntries(context, ctxIndex, indexOfEntry);\n          if (valueToCompare !== newValue) {\n            const initialValue = getInitialValue(context, flagToCompare);\n            setValue(context, ctxIndex, newValue);\n            if (initialValue !== newValue) {\n              setDirty(context, ctxIndex, true);\n              dirty = true;\n            }\n          }\n        } else {\n          // we only care to do this if the insertion is in the middle\n          const newFlag = prepareInitialFlag(newProp, isClassBased, getStyleSanitizer(context));\n          insertNewMultiProperty(context, ctxIndex, isClassBased, newProp, newFlag, newValue);\n          dirty = true;\n        }\n      }\n    }\n\n    ctxIndex += StylingIndex.Size;\n    propIndex++;\n  }\n\n  // this means that there are left-over values in the context that\n  // were not included in the provided styles/classes and in this\n  // case the  goal is to \"remove\" them from the context (by nullifying)\n  while (ctxIndex < context.length) {\n    const flag = getPointers(context, ctxIndex);\n    const isClassBased = (flag & StylingFlags.Class) === StylingFlags.Class;\n    if (ignoreAllClassUpdates && isClassBased) break;\n\n    const value = getValue(context, ctxIndex);\n    const doRemoveValue = valueExists(value, isClassBased);\n    if (doRemoveValue) {\n      setDirty(context, ctxIndex, true);\n      setValue(context, ctxIndex, null);\n      dirty = true;\n    }\n    ctxIndex += StylingIndex.Size;\n  }\n\n  // this means that there are left-over properties in the context that\n  // were not detected in the context during the loop above. In that\n  // case we want to add the new entries into the list\n  const sanitizer = getStyleSanitizer(context);\n  while (propIndex < propLimit) {\n    const isClassBased = propIndex >= classesStartIndex;\n    if (ignoreAllClassUpdates && isClassBased) break;\n\n    const adjustedPropIndex = isClassBased ? propIndex - classesStartIndex : propIndex;\n    const prop = isClassBased ? classNames[adjustedPropIndex] : styleProps[adjustedPropIndex];\n    const value: string|boolean =\n        isClassBased ? (applyAllClasses ? true : classes[prop]) : styles[prop];\n    const flag = prepareInitialFlag(prop, isClassBased, sanitizer) | StylingFlags.Dirty;\n    context.push(flag, prop, value);\n    propIndex++;\n    dirty = true;\n  }\n\n  if (dirty) {\n    setContextDirty(context, true);\n  }\n}\n\n/**\n * Sets and resolves a single styling property/value on the provided `StylingContext` so\n * that they can be applied to the element once `renderStyling` is called.\n *\n * Note that prop-level styling values are considered higher priority than any styling that\n * has been applied using `updateStylingMap`, therefore, when styling values are rendered\n * then any styles/classes that have been applied using this function will be considered first\n * (then multi values second and then initial values as a backup).\n *\n * @param context The styling context that will be updated with the\n *    newly provided style value.\n * @param index The index of the property which is being updated.\n * @param value The CSS style value that will be assigned\n */\nexport function updateStyleProp(\n    context: StylingContext, index: number, value: string | boolean | null): void {\n  const singleIndex = StylingIndex.SingleStylesStartPosition + index * StylingIndex.Size;\n  const currValue = getValue(context, singleIndex);\n  const currFlag = getPointers(context, singleIndex);\n\n  // didn't change ... nothing to make a note of\n  if (hasValueChanged(currFlag, currValue, value)) {\n    // the value will always get updated (even if the dirty flag is skipped)\n    setValue(context, singleIndex, value);\n    const indexForMulti = getMultiOrSingleIndex(currFlag);\n\n    // if the value is the same in the multi-area then there's no point in re-assembling\n    const valueForMulti = getValue(context, indexForMulti);\n    if (!valueForMulti || valueForMulti !== value) {\n      let multiDirty = false;\n      let singleDirty = true;\n\n      const isClassBased = (currFlag & StylingFlags.Class) === StylingFlags.Class;\n\n      // only when the value is set to `null` should the multi-value get flagged\n      if (!valueExists(value, isClassBased) && valueExists(valueForMulti, isClassBased)) {\n        multiDirty = true;\n        singleDirty = false;\n      }\n\n      setDirty(context, indexForMulti, multiDirty);\n      setDirty(context, singleIndex, singleDirty);\n      setContextDirty(context, true);\n    }\n  }\n}\n\n/**\n * This method will toggle the referenced CSS class (by the provided index)\n * within the given context.\n *\n * @param context The styling context that will be updated with the\n *    newly provided class value.\n * @param index The index of the CSS class which is being updated.\n * @param addOrRemove Whether or not to add or remove the CSS class\n */\nexport function updateClassProp(\n    context: StylingContext, index: number, addOrRemove: boolean): void {\n  const adjustedIndex = index + context[StylingIndex.ClassOffsetPosition];\n  updateStyleProp(context, adjustedIndex, addOrRemove);\n}\n\n/**\n * Renders all queued styling using a renderer onto the given element.\n *\n * This function works by rendering any styles (that have been applied\n * using `updateStylingMap`) and any classes (that have been applied using\n * `updateStyleProp`) onto the provided element using the provided renderer.\n * Just before the styles/classes are rendered a final key/value style map\n * will be assembled (if `styleStore` or `classStore` are provided).\n *\n * @param lElement the element that the styles will be rendered on\n * @param context The styling context that will be used to determine\n *      what styles will be rendered\n * @param renderer the renderer that will be used to apply the styling\n * @param styleStore if provided, the updated style values will be applied\n *    to this key/value map instead of being renderered via the renderer.\n * @param classStore if provided, the updated class values will be applied\n *    to this key/value map instead of being renderered via the renderer.\n */\nexport function renderStyling(\n    context: StylingContext, renderer: Renderer3, styleStore?: {[key: string]: any},\n    classStore?: {[key: string]: boolean}) {\n  if (isContextDirty(context)) {\n    const native = context[StylingIndex.ElementPosition] !.native;\n    const multiStartIndex = getMultiStartIndex(context);\n    const styleSanitizer = getStyleSanitizer(context);\n    for (let i = StylingIndex.SingleStylesStartPosition; i < context.length;\n         i += StylingIndex.Size) {\n      // there is no point in rendering styles that have not changed on screen\n      if (isDirty(context, i)) {\n        const prop = getProp(context, i);\n        const value = getValue(context, i);\n        const flag = getPointers(context, i);\n        const isClassBased = flag & StylingFlags.Class ? true : false;\n        const isInSingleRegion = i < multiStartIndex;\n\n        let valueToApply: string|boolean|null = value;\n\n        // VALUE DEFER CASE 1: Use a multi value instead of a null single value\n        // this check implies that a single value was removed and we\n        // should now defer to a multi value and use that (if set).\n        if (isInSingleRegion && !valueExists(valueToApply, isClassBased)) {\n          // single values ALWAYS have a reference to a multi index\n          const multiIndex = getMultiOrSingleIndex(flag);\n          valueToApply = getValue(context, multiIndex);\n        }\n\n        // VALUE DEFER CASE 2: Use the initial value if all else fails (is falsy)\n        // the initial value will always be a string or null,\n        // therefore we can safely adopt it incase there's nothing else\n        // note that this should always be a falsy check since `false` is used\n        // for both class and style comparisons (styles can't be false and false\n        // classes are turned off and should therefore defer to their initial values)\n        if (!valueExists(valueToApply, isClassBased)) {\n          valueToApply = getInitialValue(context, flag);\n        }\n\n        if (isClassBased) {\n          setClass(native, prop, valueToApply ? true : false, renderer, classStore);\n        } else {\n          const sanitizer = (flag & StylingFlags.Sanitize) ? styleSanitizer : null;\n          setStyle(native, prop, valueToApply as string | null, renderer, sanitizer, styleStore);\n        }\n        setDirty(context, i, false);\n      }\n    }\n\n    setContextDirty(context, false);\n  }\n}\n\n/**\n * This function renders a given CSS prop/value entry using the\n * provided renderer. If a `store` value is provided then\n * that will be used a render context instead of the provided\n * renderer.\n *\n * @param native the DOM Element\n * @param prop the CSS style property that will be rendered\n * @param value the CSS style value that will be rendered\n * @param renderer\n * @param store an optional key/value map that will be used as a context to render styles on\n */\nfunction setStyle(\n    native: any, prop: string, value: string | null, renderer: Renderer3,\n    sanitizer: StyleSanitizeFn | null, store?: {[key: string]: any}) {\n  value = sanitizer && value ? sanitizer(prop, value) : value;\n  if (store) {\n    store[prop] = value;\n  } else if (value) {\n    ngDevMode && ngDevMode.rendererSetStyle++;\n    isProceduralRenderer(renderer) ?\n        renderer.setStyle(native, prop, value, RendererStyleFlags3.DashCase) :\n        native['style'].setProperty(prop, value);\n  } else {\n    ngDevMode && ngDevMode.rendererRemoveStyle++;\n    isProceduralRenderer(renderer) ?\n        renderer.removeStyle(native, prop, RendererStyleFlags3.DashCase) :\n        native['style'].removeProperty(prop);\n  }\n}\n\n/**\n * This function renders a given CSS class value using the provided\n * renderer (by adding or removing it from the provided element).\n * If a `store` value is provided then that will be used a render\n * context instead of the provided renderer.\n *\n * @param native the DOM Element\n * @param prop the CSS style property that will be rendered\n * @param value the CSS style value that will be rendered\n * @param renderer\n * @param store an optional key/value map that will be used as a context to render styles on\n */\nfunction setClass(\n    native: any, className: string, add: boolean, renderer: Renderer3,\n    store?: {[key: string]: boolean}) {\n  if (store) {\n    store[className] = add;\n  } else if (add) {\n    ngDevMode && ngDevMode.rendererAddClass++;\n    isProceduralRenderer(renderer) ? renderer.addClass(native, className) :\n                                     native['classList'].add(className);\n  } else {\n    ngDevMode && ngDevMode.rendererRemoveClass++;\n    isProceduralRenderer(renderer) ? renderer.removeClass(native, className) :\n                                     native['classList'].remove(className);\n  }\n}\n\nfunction setDirty(context: StylingContext, index: number, isDirtyYes: boolean) {\n  const adjustedIndex =\n      index >= StylingIndex.SingleStylesStartPosition ? (index + StylingIndex.FlagsOffset) : index;\n  if (isDirtyYes) {\n    (context[adjustedIndex] as number) |= StylingFlags.Dirty;\n  } else {\n    (context[adjustedIndex] as number) &= ~StylingFlags.Dirty;\n  }\n}\n\nfunction isDirty(context: StylingContext, index: number): boolean {\n  const adjustedIndex =\n      index >= StylingIndex.SingleStylesStartPosition ? (index + StylingIndex.FlagsOffset) : index;\n  return ((context[adjustedIndex] as number) & StylingFlags.Dirty) == StylingFlags.Dirty;\n}\n\nfunction isClassBased(context: StylingContext, index: number): boolean {\n  const adjustedIndex =\n      index >= StylingIndex.SingleStylesStartPosition ? (index + StylingIndex.FlagsOffset) : index;\n  return ((context[adjustedIndex] as number) & StylingFlags.Class) == StylingFlags.Class;\n}\n\nfunction isSanitizable(context: StylingContext, index: number): boolean {\n  const adjustedIndex =\n      index >= StylingIndex.SingleStylesStartPosition ? (index + StylingIndex.FlagsOffset) : index;\n  return ((context[adjustedIndex] as number) & StylingFlags.Sanitize) == StylingFlags.Sanitize;\n}\n\nfunction pointers(configFlag: number, staticIndex: number, dynamicIndex: number) {\n  return (configFlag & StylingFlags.BitMask) | (staticIndex << StylingFlags.BitCountSize) |\n      (dynamicIndex << (StylingIndex.BitCountSize + StylingFlags.BitCountSize));\n}\n\nfunction getInitialValue(context: StylingContext, flag: number): string|null {\n  const index = getInitialIndex(flag);\n  return context[StylingIndex.InitialStylesPosition][index] as null | string;\n}\n\nfunction getInitialIndex(flag: number): number {\n  return (flag >> StylingFlags.BitCountSize) & StylingIndex.BitMask;\n}\n\nfunction getMultiOrSingleIndex(flag: number): number {\n  const index =\n      (flag >> (StylingIndex.BitCountSize + StylingFlags.BitCountSize)) & StylingIndex.BitMask;\n  return index >= StylingIndex.SingleStylesStartPosition ? index : -1;\n}\n\nfunction getMultiStartIndex(context: StylingContext): number {\n  return getMultiOrSingleIndex(context[StylingIndex.MasterFlagPosition]) as number;\n}\n\nfunction getStyleSanitizer(context: StylingContext): StyleSanitizeFn|null {\n  return context[StylingIndex.StyleSanitizerPosition];\n}\n\nfunction setProp(context: StylingContext, index: number, prop: string) {\n  context[index + StylingIndex.PropertyOffset] = prop;\n}\n\nfunction setValue(context: StylingContext, index: number, value: string | null | boolean) {\n  context[index + StylingIndex.ValueOffset] = value;\n}\n\nfunction setFlag(context: StylingContext, index: number, flag: number) {\n  const adjustedIndex =\n      index === StylingIndex.MasterFlagPosition ? index : (index + StylingIndex.FlagsOffset);\n  context[adjustedIndex] = flag;\n}\n\nfunction getPointers(context: StylingContext, index: number): number {\n  const adjustedIndex =\n      index === StylingIndex.MasterFlagPosition ? index : (index + StylingIndex.FlagsOffset);\n  return context[adjustedIndex] as number;\n}\n\nfunction getValue(context: StylingContext, index: number): string|boolean|null {\n  return context[index + StylingIndex.ValueOffset] as string | boolean | null;\n}\n\nfunction getProp(context: StylingContext, index: number): string {\n  return context[index + StylingIndex.PropertyOffset] as string;\n}\n\nexport function isContextDirty(context: StylingContext): boolean {\n  return isDirty(context, StylingIndex.MasterFlagPosition);\n}\n\nexport function setContextDirty(context: StylingContext, isDirtyYes: boolean): void {\n  setDirty(context, StylingIndex.MasterFlagPosition, isDirtyYes);\n}\n\nfunction findEntryPositionByProp(\n    context: StylingContext, prop: string, startIndex?: number): number {\n  for (let i = (startIndex || 0) + StylingIndex.PropertyOffset; i < context.length;\n       i += StylingIndex.Size) {\n    const thisProp = context[i];\n    if (thisProp == prop) {\n      return i - StylingIndex.PropertyOffset;\n    }\n  }\n  return -1;\n}\n\nfunction swapMultiContextEntries(context: StylingContext, indexA: number, indexB: number) {\n  const tmpValue = getValue(context, indexA);\n  const tmpProp = getProp(context, indexA);\n  const tmpFlag = getPointers(context, indexA);\n\n  let flagA = tmpFlag;\n  let flagB = getPointers(context, indexB);\n\n  const singleIndexA = getMultiOrSingleIndex(flagA);\n  if (singleIndexA >= 0) {\n    const _flag = getPointers(context, singleIndexA);\n    const _initial = getInitialIndex(_flag);\n    setFlag(context, singleIndexA, pointers(_flag, _initial, indexB));\n  }\n\n  const singleIndexB = getMultiOrSingleIndex(flagB);\n  if (singleIndexB >= 0) {\n    const _flag = getPointers(context, singleIndexB);\n    const _initial = getInitialIndex(_flag);\n    setFlag(context, singleIndexB, pointers(_flag, _initial, indexA));\n  }\n\n  setValue(context, indexA, getValue(context, indexB));\n  setProp(context, indexA, getProp(context, indexB));\n  setFlag(context, indexA, getPointers(context, indexB));\n\n  setValue(context, indexB, tmpValue);\n  setProp(context, indexB, tmpProp);\n  setFlag(context, indexB, tmpFlag);\n}\n\nfunction updateSinglePointerValues(context: StylingContext, indexStartPosition: number) {\n  for (let i = indexStartPosition; i < context.length; i += StylingIndex.Size) {\n    const multiFlag = getPointers(context, i);\n    const singleIndex = getMultiOrSingleIndex(multiFlag);\n    if (singleIndex > 0) {\n      const singleFlag = getPointers(context, singleIndex);\n      const initialIndexForSingle = getInitialIndex(singleFlag);\n      const flagValue = (isDirty(context, singleIndex) ? StylingFlags.Dirty : StylingFlags.None) |\n          (isClassBased(context, singleIndex) ? StylingFlags.Class : StylingFlags.None) |\n          (isSanitizable(context, singleIndex) ? StylingFlags.Sanitize : StylingFlags.None);\n      const updatedFlag = pointers(flagValue, initialIndexForSingle, i);\n      setFlag(context, singleIndex, updatedFlag);\n    }\n  }\n}\n\nfunction insertNewMultiProperty(\n    context: StylingContext, index: number, classBased: boolean, name: string, flag: number,\n    value: string | boolean): void {\n  const doShift = index < context.length;\n\n  // prop does not exist in the list, add it in\n  context.splice(\n      index, 0, flag | StylingFlags.Dirty | (classBased ? StylingFlags.Class : StylingFlags.None),\n      name, value);\n\n  if (doShift) {\n    // because the value was inserted midway into the array then we\n    // need to update all the shifted multi values' single value\n    // pointers to point to the newly shifted location\n    updateSinglePointerValues(context, index + StylingIndex.Size);\n  }\n}\n\nfunction valueExists(value: string | null | boolean, isClassBased?: boolean) {\n  if (isClassBased) {\n    return value ? true : false;\n  }\n  return value !== null;\n}\n\nfunction prepareInitialFlag(\n    name: string, isClassBased: boolean, sanitizer?: StyleSanitizeFn | null) {\n  if (isClassBased) {\n    return StylingFlags.Class;\n  } else if (sanitizer && sanitizer(name)) {\n    return StylingFlags.Sanitize;\n  }\n  return StylingFlags.None;\n}\n\nfunction hasValueChanged(\n    flag: number, a: string | boolean | null, b: string | boolean | null): boolean {\n  const isClassBased = flag & StylingFlags.Class;\n  const hasValues = a && b;\n  const usesSanitizer = flag & StylingFlags.Sanitize;\n  // the toString() comparison ensures that a value is checked\n  // ... otherwise (during sanitization bypassing) the === comparsion\n  // would fail since a new String() instance is created\n  if (!isClassBased && hasValues && usesSanitizer) {\n    // we know for sure we're dealing with strings at this point\n    return (a as string).toString() !== (b as string).toString();\n  }\n\n  // everything else is safe to check with a normal equality check\n  return a !== b;\n}\n"]}