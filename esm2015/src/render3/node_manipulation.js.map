{"version":3,"file":"node_manipulation.js","sourceRoot":"","sources":["../../../../../packages/core/src/render3/node_manipulation.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {assertDefined} from './assert';\nimport {attachLViewDataToNode} from './element_discovery';\nimport {callHooks} from './hooks';\nimport {LContainer, RENDER_PARENT, VIEWS, unusedValueExportToPlacateAjd as unused1} from './interfaces/container';\nimport {LContainerNode, LElementContainerNode, LElementNode, LNode, LProjectionNode, LTextNode, LViewNode, TNode, TNodeFlags, TNodeType, unusedValueExportToPlacateAjd as unused2} from './interfaces/node';\nimport {unusedValueExportToPlacateAjd as unused3} from './interfaces/projection';\nimport {ProceduralRenderer3, RComment, RElement, RNode, RText, Renderer3, isProceduralRenderer, unusedValueExportToPlacateAjd as unused4} from './interfaces/renderer';\nimport {CLEANUP, CONTAINER_INDEX, DIRECTIVES, FLAGS, HEADER_OFFSET, HOST_NODE, HookData, LViewData, LViewFlags, NEXT, PARENT, QUERIES, RENDERER, TVIEW, unusedValueExportToPlacateAjd as unused5} from './interfaces/view';\nimport {assertNodeOfPossibleTypes, assertNodeType} from './node_assert';\nimport {readElementValue, stringify} from './util';\n\nconst unusedValueToPlacateAjd = unused1 + unused2 + unused3 + unused4 + unused5;\n\n/** Retrieves the sibling node for the given node. */\nexport function getNextLNode(node: LNode): LNode|null {\n  // View nodes don't have TNodes, so their next must be retrieved through their LView.\n  if (node.tNode.type === TNodeType.View) {\n    const viewData = node.data as LViewData;\n    return viewData[NEXT] ? (viewData[NEXT] as LViewData)[HOST_NODE] : null;\n  }\n  return node.tNode.next ? node.view[node.tNode.next.index] : null;\n}\n\n/** Retrieves the first child of a given node */\nexport function getChildLNode(node: LNode): LNode|null {\n  if (node.tNode.child) {\n    const viewData = node.tNode.type === TNodeType.View ? node.data as LViewData : node.view;\n    return readElementValue(viewData[node.tNode.child.index]);\n  }\n  return null;\n}\n\n/** Retrieves the parent LNode of a given node. */\nexport function getParentLNode(\n    node: LContainerNode | LElementNode | LElementContainerNode | LTextNode |\n    LProjectionNode): LElementNode|LElementContainerNode|LViewNode;\nexport function getParentLNode(node: LViewNode): LContainerNode|null;\nexport function getParentLNode(node: LElementContainerNode): LElementNode|LElementContainerNode|\n    LViewNode;\nexport function getParentLNode(node: LNode): LElementNode|LElementContainerNode|LContainerNode|\n    LViewNode|null;\nexport function getParentLNode(node: LNode): LElementNode|LElementContainerNode|LContainerNode|\n    LViewNode|null {\n  if (node.tNode.index === -1 && node.tNode.type === TNodeType.View) {\n    // This is a dynamically created view inside a dynamic container.\n    // If the host index is -1, the view has not yet been inserted, so it has no parent.\n    const containerHostIndex = (node.data as LViewData)[CONTAINER_INDEX];\n    return containerHostIndex === -1 ? null : node.view[containerHostIndex].dynamicLContainerNode;\n  }\n  const parent = node.tNode.parent;\n  return readElementValue(parent ? node.view[parent.index] : node.view[HOST_NODE]);\n}\n\n/**\n * Retrieves render parent LElementNode for a given view.\n * Might be null if a view is not yet attatched to any container.\n */\nfunction getRenderParent(viewNode: LViewNode): LElementNode|null {\n  const container = getParentLNode(viewNode);\n  return container ? container.data[RENDER_PARENT] : null;\n}\n\nconst enum WalkLNodeTreeAction {\n  /** node insert in the native environment */\n  Insert = 0,\n\n  /** node detach from the native environment */\n  Detach = 1,\n\n  /** node destruction using the renderer's API */\n  Destroy = 2,\n}\n\n\n/**\n * Stack used to keep track of projection nodes in walkLNodeTree.\n *\n * This is deliberately created outside of walkLNodeTree to avoid allocating\n * a new array each time the function is called. Instead the array will be\n * re-used by each invocation. This works because the function is not reentrant.\n */\nconst projectionNodeStack: LProjectionNode[] = [];\n\n/**\n * Walks a tree of LNodes, applying a transformation on the LElement nodes, either only on the first\n * one found, or on all of them.\n *\n * @param startingNode the node from which the walk is started.\n * @param rootNode the root node considered. This prevents walking past that node.\n * @param action identifies the action to be performed on the LElement nodes.\n * @param renderer the current renderer.\n * @param renderParentNode Optional the render parent node to be set in all LContainerNodes found,\n * required for action modes Insert and Destroy.\n * @param beforeNode Optional the node before which elements should be added, required for action\n * Insert.\n */\nfunction walkLNodeTree(\n    startingNode: LNode | null, rootNode: LNode, action: WalkLNodeTreeAction, renderer: Renderer3,\n    renderParentNode?: LElementNode | null, beforeNode?: RNode | null) {\n  let node: LNode|null = startingNode;\n  let projectionNodeIndex = -1;\n  while (node) {\n    let nextNode: LNode|null = null;\n    const parent = renderParentNode ? renderParentNode.native : null;\n    const nodeType = node.tNode.type;\n    if (nodeType === TNodeType.Element) {\n      // Execute the action\n      executeNodeAction(action, renderer, parent, node.native !, beforeNode);\n      if (node.dynamicLContainerNode) {\n        executeNodeAction(\n            action, renderer, parent, node.dynamicLContainerNode.native !, beforeNode);\n      }\n    } else if (nodeType === TNodeType.Container) {\n      executeNodeAction(action, renderer, parent, node.native !, beforeNode);\n      const lContainerNode: LContainerNode = (node as LContainerNode);\n      const childContainerData: LContainer = lContainerNode.dynamicLContainerNode ?\n          lContainerNode.dynamicLContainerNode.data :\n          lContainerNode.data;\n      if (renderParentNode) {\n        childContainerData[RENDER_PARENT] = renderParentNode;\n      }\n      nextNode =\n          childContainerData[VIEWS].length ? getChildLNode(childContainerData[VIEWS][0]) : null;\n      if (nextNode) {\n        // When the walker enters a container, then the beforeNode has to become the local native\n        // comment node.\n        beforeNode = lContainerNode.dynamicLContainerNode ?\n            lContainerNode.dynamicLContainerNode.native :\n            lContainerNode.native;\n      }\n    } else if (nodeType === TNodeType.Projection) {\n      const componentHost = findComponentHost(node.view);\n      const head =\n          (componentHost.tNode.projection as(TNode | null)[])[node.tNode.projection as number];\n\n      projectionNodeStack[++projectionNodeIndex] = node as LProjectionNode;\n\n      nextNode = head ? (componentHost.data as LViewData)[PARENT] ![head.index] : null;\n    } else {\n      // Otherwise look at the first child\n      nextNode = getChildLNode(node as LViewNode | LElementContainerNode);\n    }\n\n    if (nextNode === null) {\n      nextNode = getNextLNode(node);\n\n      // this last node was projected, we need to get back down to its projection node\n      if (nextNode === null && (node.tNode.flags & TNodeFlags.isProjected)) {\n        nextNode = getNextLNode(projectionNodeStack[projectionNodeIndex--] as LNode);\n      }\n      /**\n       * Find the next node in the LNode tree, taking into account the place where a node is\n       * projected (in the shadow DOM) rather than where it comes from (in the light DOM).\n       *\n       * If there is no sibling node, then it goes to the next sibling of the parent node...\n       * until it reaches rootNode (at which point null is returned).\n       */\n      while (node && !nextNode) {\n        node = getParentLNode(node);\n        if (node === null || node === rootNode) return null;\n\n        // When exiting a container, the beforeNode must be restored to the previous value\n        if (!node.tNode.next && nodeType === TNodeType.Container) {\n          beforeNode = node.native;\n        }\n        nextNode = getNextLNode(node);\n      }\n    }\n    node = nextNode;\n  }\n}\n\n\n/**\n * Given a current view, finds the nearest component's host (LElement).\n *\n * @param lViewData LViewData for which we want a host element node\n * @returns The host node\n */\nexport function findComponentHost(lViewData: LViewData): LElementNode {\n  let viewRootLNode = lViewData[HOST_NODE];\n\n  while (viewRootLNode.tNode.type === TNodeType.View) {\n    ngDevMode && assertDefined(lViewData[PARENT], 'lViewData.parent');\n    lViewData = lViewData[PARENT] !;\n    viewRootLNode = lViewData[HOST_NODE];\n  }\n\n  ngDevMode && assertNodeType(viewRootLNode, TNodeType.Element);\n  ngDevMode && assertDefined(viewRootLNode.data, 'node.data');\n\n  return viewRootLNode as LElementNode;\n}\n\n/**\n * NOTE: for performance reasons, the possible actions are inlined within the function instead of\n * being passed as an argument.\n */\nfunction executeNodeAction(\n    action: WalkLNodeTreeAction, renderer: Renderer3, parent: RElement | null,\n    node: RComment | RElement | RText, beforeNode?: RNode | null) {\n  if (action === WalkLNodeTreeAction.Insert) {\n    isProceduralRenderer(renderer !) ?\n        (renderer as ProceduralRenderer3).insertBefore(parent !, node, beforeNode as RNode | null) :\n        parent !.insertBefore(node, beforeNode as RNode | null, true);\n  } else if (action === WalkLNodeTreeAction.Detach) {\n    isProceduralRenderer(renderer !) ?\n        (renderer as ProceduralRenderer3).removeChild(parent !, node) :\n        parent !.removeChild(node);\n  } else if (action === WalkLNodeTreeAction.Destroy) {\n    ngDevMode && ngDevMode.rendererDestroyNode++;\n    (renderer as ProceduralRenderer3).destroyNode !(node);\n  }\n}\n\nexport function createTextNode(value: any, renderer: Renderer3): RText {\n  return isProceduralRenderer(renderer) ? renderer.createText(stringify(value)) :\n                                          renderer.createTextNode(stringify(value));\n}\n\n/**\n * Adds or removes all DOM elements associated with a view.\n *\n * Because some root nodes of the view may be containers, we sometimes need\n * to propagate deeply into the nested containers to remove all elements in the\n * views beneath it.\n *\n * @param container The container to which the root view belongs\n * @param rootNode The view from which elements should be added or removed\n * @param insertMode Whether or not elements should be added (if false, removing)\n * @param beforeNode The node before which elements should be added, if insert mode\n */\nexport function addRemoveViewFromContainer(\n    container: LContainerNode, rootNode: LViewNode, insertMode: true,\n    beforeNode: RNode | null): void;\nexport function addRemoveViewFromContainer(\n    container: LContainerNode, rootNode: LViewNode, insertMode: false): void;\nexport function addRemoveViewFromContainer(\n    container: LContainerNode, rootNode: LViewNode, insertMode: boolean,\n    beforeNode?: RNode | null): void {\n  ngDevMode && assertNodeType(container, TNodeType.Container);\n  ngDevMode && assertNodeType(rootNode, TNodeType.View);\n  const parentNode = container.data[RENDER_PARENT];\n  const parent = parentNode ? parentNode.native : null;\n  if (parent) {\n    let node: LNode|null = getChildLNode(rootNode);\n    const renderer = container.view[RENDERER];\n    walkLNodeTree(\n        node, rootNode, insertMode ? WalkLNodeTreeAction.Insert : WalkLNodeTreeAction.Detach,\n        renderer, parentNode, beforeNode);\n  }\n}\n\n/**\n * Traverses down and up the tree of views and containers to remove listeners and\n * call onDestroy callbacks.\n *\n * Notes:\n *  - Because it's used for onDestroy calls, it needs to be bottom-up.\n *  - Must process containers instead of their views to avoid splicing\n *  when views are destroyed and re-added.\n *  - Using a while loop because it's faster than recursion\n *  - Destroy only called on movement to sibling or movement to parent (laterally or up)\n *\n *  @param rootView The view to destroy\n */\nexport function destroyViewTree(rootView: LViewData): void {\n  // If the view has no children, we can clean it up and return early.\n  if (rootView[TVIEW].childIndex === -1) {\n    return cleanUpView(rootView);\n  }\n  let viewOrContainer: LViewData|LContainer|null = getLViewChild(rootView);\n\n  while (viewOrContainer) {\n    let next: LViewData|LContainer|null = null;\n\n    if (viewOrContainer.length >= HEADER_OFFSET) {\n      // If LViewData, traverse down to child.\n      const view = viewOrContainer as LViewData;\n      if (view[TVIEW].childIndex > -1) next = getLViewChild(view);\n    } else {\n      // If container, traverse down to its first LViewData.\n      const container = viewOrContainer as LContainer;\n      if (container[VIEWS].length) next = container[VIEWS][0].data;\n    }\n\n    if (next == null) {\n      // Only clean up view when moving to the side or up, as destroy hooks\n      // should be called in order from the bottom up.\n      while (viewOrContainer && !viewOrContainer ![NEXT] && viewOrContainer !== rootView) {\n        cleanUpView(viewOrContainer);\n        viewOrContainer = getParentState(viewOrContainer, rootView);\n      }\n      cleanUpView(viewOrContainer || rootView);\n      next = viewOrContainer && viewOrContainer ![NEXT];\n    }\n    viewOrContainer = next;\n  }\n}\n\n/**\n * Inserts a view into a container.\n *\n * This adds the view to the container's array of active views in the correct\n * position. It also adds the view's elements to the DOM if the container isn't a\n * root node of another view (in that case, the view's elements will be added when\n * the container's parent view is added later).\n *\n * @param container The container into which the view should be inserted\n * @param viewNode The view to insert\n * @param index The index at which to insert the view\n * @returns The inserted view\n */\nexport function insertView(\n    container: LContainerNode, viewNode: LViewNode, index: number): LViewNode {\n  const state = container.data;\n  const views = state[VIEWS];\n  const lView = viewNode.data as LViewData;\n\n  if (index > 0) {\n    // This is a new view, we need to add it to the children.\n    views[index - 1].data[NEXT] = lView;\n  }\n\n  if (index < views.length) {\n    lView[NEXT] = views[index].data;\n    views.splice(index, 0, viewNode);\n  } else {\n    views.push(viewNode);\n    lView[NEXT] = null;\n  }\n\n  // Dynamically inserted views need a reference to their parent container'S host so it's\n  // possible to jump from a view to its container's next when walking the node tree.\n  if (viewNode.tNode.index === -1) {\n    lView[CONTAINER_INDEX] = container.tNode.parent !.index;\n    (viewNode as{view: LViewData}).view = container.view;\n  }\n\n  // Notify query that a new view has been added\n  if (lView[QUERIES]) {\n    lView[QUERIES] !.insertView(index);\n  }\n\n  // Sets the attached flag\n  lView[FLAGS] |= LViewFlags.Attached;\n\n  return viewNode;\n}\n\n/**\n * Detaches a view from a container.\n *\n * This method splices the view from the container's array of active views. It also\n * removes the view's elements from the DOM.\n *\n * @param container The container from which to detach a view\n * @param removeIndex The index of the view to detach\n * @returns The detached view\n */\nexport function detachView(container: LContainerNode, removeIndex: number): LViewNode {\n  const views = container.data[VIEWS];\n  const viewNode = views[removeIndex];\n  if (removeIndex > 0) {\n    views[removeIndex - 1].data[NEXT] = viewNode.data[NEXT] as LViewData;\n  }\n  views.splice(removeIndex, 1);\n  if (!container.tNode.detached) {\n    addRemoveViewFromContainer(container, viewNode, false);\n  }\n  // Notify query that view has been removed\n  const removedLView = viewNode.data;\n  if (removedLView[QUERIES]) {\n    removedLView[QUERIES] !.removeView();\n  }\n  removedLView[CONTAINER_INDEX] = -1;\n  (viewNode as{view: LViewData | null}).view = null;\n  // Unsets the attached flag\n  viewNode.data[FLAGS] &= ~LViewFlags.Attached;\n  return viewNode;\n}\n\n/**\n * Removes a view from a container, i.e. detaches it and then destroys the underlying LView.\n *\n * @param container The container from which to remove a view\n * @param removeIndex The index of the view to remove\n * @returns The removed view\n */\nexport function removeView(container: LContainerNode, removeIndex: number): LViewNode {\n  const viewNode = container.data[VIEWS][removeIndex];\n  detachView(container, removeIndex);\n  destroyLView(viewNode.data);\n  return viewNode;\n}\n\n/** Gets the child of the given LViewData */\nexport function getLViewChild(viewData: LViewData): LViewData|LContainer|null {\n  if (viewData[TVIEW].childIndex === -1) return null;\n\n  const hostNode: LElementNode|LContainerNode = viewData[viewData[TVIEW].childIndex];\n\n  return hostNode.data ? hostNode.data : (hostNode.dynamicLContainerNode as LContainerNode).data;\n}\n\n/**\n * A standalone function which destroys an LView,\n * conducting cleanup (e.g. removing listeners, calling onDestroys).\n *\n * @param view The view to be destroyed.\n */\nexport function destroyLView(view: LViewData) {\n  const renderer = view[RENDERER];\n  if (isProceduralRenderer(renderer) && renderer.destroyNode) {\n    walkLNodeTree(view[HOST_NODE], view[HOST_NODE], WalkLNodeTreeAction.Destroy, renderer);\n  }\n  destroyViewTree(view);\n  // Sets the destroyed flag\n  view[FLAGS] |= LViewFlags.Destroyed;\n}\n\n/**\n * Determines which LViewOrLContainer to jump to when traversing back up the\n * tree in destroyViewTree.\n *\n * Normally, the view's parent LView should be checked, but in the case of\n * embedded views, the container (which is the view node's parent, but not the\n * LView's parent) needs to be checked for a possible next property.\n *\n * @param state The LViewOrLContainer for which we need a parent state\n * @param rootView The rootView, so we don't propagate too far up the view tree\n * @returns The correct parent LViewOrLContainer\n */\nexport function getParentState(state: LViewData | LContainer, rootView: LViewData): LViewData|\n    LContainer|null {\n  let node;\n  if ((node = (state as LViewData) ![HOST_NODE]) && node.tNode.type === TNodeType.View) {\n    // if it's an embedded view, the state needs to go up to the container, in case the\n    // container has a next\n    return getParentLNode(node) !.data as any;\n  } else {\n    // otherwise, use parent view for containers or component views\n    return state[PARENT] === rootView ? null : state[PARENT];\n  }\n}\n\n/**\n * Removes all listeners and call all onDestroys in a given view.\n *\n * @param view The LViewData to clean up\n */\nfunction cleanUpView(viewOrContainer: LViewData | LContainer): void {\n  if ((viewOrContainer as LViewData)[TVIEW]) {\n    const view = viewOrContainer as LViewData;\n    removeListeners(view);\n    executeOnDestroys(view);\n    executePipeOnDestroys(view);\n    // For component views only, the local renderer is destroyed as clean up time.\n    if (view[TVIEW].id === -1 && isProceduralRenderer(view[RENDERER])) {\n      ngDevMode && ngDevMode.rendererDestroy++;\n      (view[RENDERER] as ProceduralRenderer3).destroy();\n    }\n  }\n}\n\n/** Removes listeners and unsubscribes from output subscriptions */\nfunction removeListeners(viewData: LViewData): void {\n  const cleanup = viewData[TVIEW].cleanup !;\n  if (cleanup != null) {\n    for (let i = 0; i < cleanup.length - 1; i += 2) {\n      if (typeof cleanup[i] === 'string') {\n        // This is a listener with the native renderer\n        const native = readElementValue(viewData[cleanup[i + 1]]).native;\n        const listener = viewData[CLEANUP] ![cleanup[i + 2]];\n        native.removeEventListener(cleanup[i], listener, cleanup[i + 3]);\n        i += 2;\n      } else if (typeof cleanup[i] === 'number') {\n        // This is a listener with renderer2 (cleanup fn can be found by index)\n        const cleanupFn = viewData[CLEANUP] ![cleanup[i]];\n        cleanupFn();\n      } else {\n        // This is a cleanup function that is grouped with the index of its context\n        const context = viewData[CLEANUP] ![cleanup[i + 1]];\n        cleanup[i].call(context);\n      }\n    }\n    viewData[CLEANUP] = null;\n  }\n}\n\n/** Calls onDestroy hooks for this view */\nfunction executeOnDestroys(view: LViewData): void {\n  const tView = view[TVIEW];\n  let destroyHooks: HookData|null;\n  if (tView != null && (destroyHooks = tView.destroyHooks) != null) {\n    callHooks(view[DIRECTIVES] !, destroyHooks);\n  }\n}\n\n/** Calls pipe destroy hooks for this view */\nfunction executePipeOnDestroys(viewData: LViewData): void {\n  const pipeDestroyHooks = viewData[TVIEW] && viewData[TVIEW].pipeDestroyHooks;\n  if (pipeDestroyHooks) {\n    callHooks(viewData !, pipeDestroyHooks);\n  }\n}\n\nfunction canInsertNativeChildOfElement(parent: LElementNode, currentView: LViewData): boolean {\n  if (parent.view !== currentView) {\n    // If the Parent view is not the same as current view than we are inserting across\n    // Views. This happens when we insert a root element of the component view into\n    // the component host element and it should always be eager.\n    return true;\n  }\n  // Parent elements can be a component which may have projection.\n  if (parent.data === null) {\n    // Parent is a regular non-component element. We should eagerly insert into it\n    // since we know that this relationship will never be broken.\n    return true;\n  }\n\n  // Parent is a Component. Component's content nodes are not inserted immediately\n  // because they will be projected, and so doing insert at this point would be wasteful.\n  // Since the projection would than move it to its final destination.\n  return false;\n}\n\n/**\n * We might delay insertion of children for a given view if it is disconnected.\n * This might happen for 2 main reason:\n * - view is not inserted into any container (view was created but not iserted yet)\n * - view is inserted into a container but the container itself is not inserted into the DOM\n * (container might be part of projection or child of a view that is not inserted yet).\n *\n * In other words we can insert children of a given view this view was inserted into a container and\n * the container itself has it render parent determined.\n */\nfunction canInsertNativeChildOfView(parent: LViewNode): boolean {\n  ngDevMode && assertNodeType(parent, TNodeType.View);\n\n  // Because we are inserting into a `View` the `View` may be disconnected.\n  const grandParentContainer = getParentLNode(parent) as LContainerNode;\n  if (grandParentContainer == null) {\n    // The `View` is not inserted into a `Container` we have to delay insertion.\n    return false;\n  }\n  ngDevMode && assertNodeType(grandParentContainer, TNodeType.Container);\n  if (grandParentContainer.data[RENDER_PARENT] == null) {\n    // The parent `Container` itself is disconnected. So we have to delay.\n    return false;\n  }\n\n  // The parent `Container` is in inserted state, so we can eagerly insert into\n  // this location.\n  return true;\n}\n\n/**\n * Returns whether a native element can be inserted into the given parent.\n *\n * There are two reasons why we may not be able to insert a element immediately.\n * - Projection: When creating a child content element of a component, we have to skip the\n *   insertion because the content of a component will be projected.\n *   `<component><content>delayed due to projection</content></component>`\n * - Parent container is disconnected: This can happen when we are inserting a view into\n *   parent container, which itself is disconnected. For example the parent container is part\n *   of a View which has not be inserted or is mare for projection but has not been inserted\n *   into destination.\n *\n\n *\n * @param parent The parent where the child will be inserted into.\n * @param currentView Current LView being processed.\n * @return boolean Whether the child should be inserted now (or delayed until later).\n */\nexport function canInsertNativeNode(parent: LNode, currentView: LViewData): boolean {\n  // We can only insert into a Component or View. Any other type should be an Error.\n  ngDevMode && assertNodeOfPossibleTypes(\n                   parent, TNodeType.Element, TNodeType.ElementContainer, TNodeType.View);\n\n  if (parent.tNode.type === TNodeType.Element) {\n    // Parent is a regular element or a component\n    return canInsertNativeChildOfElement(parent as LElementNode, currentView);\n  } else if (parent.tNode.type === TNodeType.ElementContainer) {\n    // Parent is an element container (ng-container).\n    // Its grand-parent might be an element, view or a sequence of ng-container parents.\n    let grandParent = getParentLNode(parent);\n    while (grandParent !== null && grandParent.tNode.type === TNodeType.ElementContainer) {\n      grandParent = getParentLNode(grandParent);\n    }\n    if (grandParent === null) {\n      return false;\n    } else if (grandParent.tNode.type === TNodeType.Element) {\n      return canInsertNativeChildOfElement(grandParent as LElementNode, currentView);\n    } else {\n      return canInsertNativeChildOfView(grandParent as LViewNode);\n    }\n  } else {\n    // Parent is a View.\n    return canInsertNativeChildOfView(parent as LViewNode);\n  }\n}\n\n/**\n * Inserts a native node before another native node for a given parent using {@link Renderer3}.\n * This is a utility function that can be used when native nodes were determined - it abstracts an\n * actual renderer being used.\n */\nfunction nativeInsertBefore(\n    renderer: Renderer3, parent: RElement, child: RNode, beforeNode: RNode | null): void {\n  if (isProceduralRenderer(renderer)) {\n    renderer.insertBefore(parent, child, beforeNode);\n  } else {\n    parent.insertBefore(child, beforeNode, true);\n  }\n}\n\n/**\n * Appends the `child` element to the `parent`.\n *\n * The element insertion might be delayed {@link canInsertNativeNode}.\n *\n * @param parent The parent to which to append the child\n * @param child The child that should be appended\n * @param currentView The current LView\n * @returns Whether or not the child was appended\n */\nexport function appendChild(parent: LNode, child: RNode | null, currentView: LViewData): boolean {\n  if (child !== null && canInsertNativeNode(parent, currentView)) {\n    const renderer = currentView[RENDERER];\n    if (parent.tNode.type === TNodeType.View) {\n      const container = getParentLNode(parent) as LContainerNode;\n      const renderParent = container.data[RENDER_PARENT];\n      const views = container.data[VIEWS];\n      const index = views.indexOf(parent as LViewNode);\n      const beforeNode =\n          index + 1 < views.length ? (getChildLNode(views[index + 1]) !).native : container.native;\n      nativeInsertBefore(renderer, renderParent !.native, child, beforeNode);\n    } else if (parent.tNode.type === TNodeType.ElementContainer) {\n      const beforeNode = parent.native;\n      let grandParent = getParentLNode(parent as LElementContainerNode);\n      while (grandParent.tNode.type === TNodeType.ElementContainer) {\n        grandParent = getParentLNode(grandParent as LElementContainerNode);\n      }\n      if (grandParent.tNode.type === TNodeType.View) {\n        const renderParent = getRenderParent(grandParent as LViewNode);\n        nativeInsertBefore(renderer, renderParent !.native, child, beforeNode);\n      } else {\n        nativeInsertBefore(renderer, (grandParent as LElementNode).native, child, beforeNode);\n      }\n    } else {\n      isProceduralRenderer(renderer) ? renderer.appendChild(parent.native !as RElement, child) :\n                                       parent.native !.appendChild(child);\n    }\n    return true;\n  }\n  return false;\n}\n\n/**\n * Removes the `child` element of the `parent` from the DOM.\n *\n * @param parent The parent from which to remove the child\n * @param child The child that should be removed\n * @param currentView The current LView\n * @returns Whether or not the child was removed\n */\nexport function removeChild(parent: LNode, child: RNode | null, currentView: LViewData): boolean {\n  if (child !== null && canInsertNativeNode(parent, currentView)) {\n    // We only remove the element if not in View or not projected.\n    const renderer = currentView[RENDERER];\n    isProceduralRenderer(renderer) ? renderer.removeChild(parent.native as RElement, child) :\n                                     parent.native !.removeChild(child);\n    return true;\n  }\n  return false;\n}\n\n/**\n * Appends a projected node to the DOM, or in the case of a projected container,\n * appends the nodes from all of the container's active views to the DOM.\n *\n * @param node The node to process\n * @param currentParent The last parent element to be processed\n * @param currentView Current LView\n */\nexport function appendProjectedNode(\n    node: LElementNode | LElementContainerNode | LTextNode | LContainerNode,\n    currentParent: LElementNode | LElementContainerNode | LViewNode, currentView: LViewData,\n    renderParent: LElementNode, parentView: LViewData): void {\n  appendChild(currentParent, node.native, currentView);\n\n  // the projected contents are processed while in the shadow view (which is the currentView)\n  // therefore we need to extract the view where the host element lives since it's the\n  // logical container of the content projected views\n  attachLViewDataToNode(node.native, parentView);\n\n  if (node.tNode.type === TNodeType.Container) {\n    // The node we are adding is a container and we are adding it to an element which\n    // is not a component (no more re-projection).\n    // Alternatively a container is projected at the root of a component's template\n    // and can't be re-projected (as not content of any component).\n    // Assign the final projection location in those cases.\n    const lContainer = (node as LContainerNode).data;\n    lContainer[RENDER_PARENT] = renderParent;\n    const views = lContainer[VIEWS];\n    for (let i = 0; i < views.length; i++) {\n      addRemoveViewFromContainer(node as LContainerNode, views[i], true, node.native);\n    }\n  } else if (node.tNode.type === TNodeType.ElementContainer) {\n    let ngContainerChild = getChildLNode(node as LElementContainerNode);\n    const parentView = currentView[HOST_NODE].view;\n    while (ngContainerChild) {\n      appendProjectedNode(\n          ngContainerChild as LElementNode | LElementContainerNode | LTextNode | LContainerNode,\n          currentParent, currentView, renderParent, parentView);\n      ngContainerChild = getNextLNode(ngContainerChild);\n    }\n  }\n  if (node.dynamicLContainerNode) {\n    node.dynamicLContainerNode.data[RENDER_PARENT] = renderParent;\n    appendChild(currentParent, node.dynamicLContainerNode.native, currentView);\n  }\n}\n"]}