{"version":3,"file":"util.js","sourceRoot":"","sources":["../../../../../packages/core/src/render3/util.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {devModeEqual} from '../change_detection/change_detection_util';\n\nimport {assertDefined, assertLessThan} from './assert';\nimport {ACTIVE_INDEX, LContainer} from './interfaces/container';\nimport {LContext, MONKEY_PATCH_KEY_NAME} from './interfaces/context';\nimport {TNode, TNodeFlags} from './interfaces/node';\nimport {RComment, RElement, RText} from './interfaces/renderer';\nimport {StylingContext} from './interfaces/styling';\nimport {CONTEXT, FLAGS, HEADER_OFFSET, HOST, LViewData, LViewFlags, PARENT, RootContext, TData, TVIEW} from './interfaces/view';\n\n\n/**\n * Returns whether the values are different from a change detection stand point.\n *\n * Constraints are relaxed in checkNoChanges mode. See `devModeEqual` for details.\n */\nexport function isDifferent(a: any, b: any, checkNoChangesMode: boolean): boolean {\n  if (ngDevMode && checkNoChangesMode) {\n    return !devModeEqual(a, b);\n  }\n  // NaN is the only value that is not equal to itself so the first\n  // test checks if both a and b are not NaN\n  return !(a !== a && b !== b) && a !== b;\n}\n\nexport function stringify(value: any): string {\n  if (typeof value == 'function') return value.name || value;\n  if (typeof value == 'string') return value;\n  if (value == null) return '';\n  return '' + value;\n}\n\n/**\n * Flattens an array in non-recursive way. Input arrays are not modified.\n */\nexport function flatten(list: any[]): any[] {\n  const result: any[] = [];\n  let i = 0;\n\n  while (i < list.length) {\n    const item = list[i];\n    if (Array.isArray(item)) {\n      if (item.length > 0) {\n        list = item.concat(list.slice(i + 1));\n        i = 0;\n      } else {\n        i++;\n      }\n    } else {\n      result.push(item);\n      i++;\n    }\n  }\n\n  return result;\n}\n\n/** Retrieves a value from any `LViewData` or `TData`. */\nexport function loadInternal<T>(index: number, arr: LViewData | TData): T {\n  ngDevMode && assertDataInRangeInternal(index + HEADER_OFFSET, arr);\n  return arr[index + HEADER_OFFSET];\n}\n\nexport function assertDataInRangeInternal(index: number, arr: any[]) {\n  assertLessThan(index, arr ? arr.length : 0, 'index expected to be a valid data index');\n}\n\n/**\n * Takes the value of a slot in `LViewData` and returns the element node.\n *\n * Normally, element nodes are stored flat, but if the node has styles/classes on it,\n * it might be wrapped in a styling context. Or if that node has a directive that injects\n * ViewContainerRef, it may be wrapped in an LContainer. Or if that node is a component,\n * it will be wrapped in LViewData. It could even have all three, so we keep looping\n * until we find something that isn't an array.\n *\n * @param value The initial value in `LViewData`\n */\nexport function readElementValue(value: RElement | StylingContext | LContainer | LViewData):\n    RElement {\n  while (Array.isArray(value)) {\n    value = value[HOST] as any;\n  }\n  return value;\n}\n\n/**\n * Retrieves an element value from the provided `viewData`, by unwrapping\n * from any containers, component views, or style contexts.\n */\nexport function getNativeByIndex(index: number, arr: LViewData): RElement {\n  return readElementValue(arr[index + HEADER_OFFSET]);\n}\n\nexport function getNativeByTNode(tNode: TNode, hostView: LViewData): RElement|RText|RComment {\n  return readElementValue(hostView[tNode.index]);\n}\n\nexport function getTNode(index: number, view: LViewData): TNode {\n  return view[TVIEW].data[index + HEADER_OFFSET] as TNode;\n}\n\nexport function getComponentViewByIndex(nodeIndex: number, hostView: LViewData): LViewData {\n  // Could be an LViewData or an LContainer. If LContainer, unwrap to find LViewData.\n  const slotValue = hostView[nodeIndex];\n  return slotValue.length >= HEADER_OFFSET ? slotValue : slotValue[HOST];\n}\n\nexport function isContentQueryHost(tNode: TNode): boolean {\n  return (tNode.flags & TNodeFlags.hasContentQuery) !== 0;\n}\n\nexport function isComponent(tNode: TNode): boolean {\n  return (tNode.flags & TNodeFlags.isComponent) === TNodeFlags.isComponent;\n}\n\nexport function isLContainer(value: RElement | RComment | LContainer | StylingContext): boolean {\n  // Styling contexts are also arrays, but their first index contains an element node\n  return Array.isArray(value) && typeof value[ACTIVE_INDEX] === 'number';\n}\n\n/**\n * Retrieve the root view from any component by walking the parent `LViewData` until\n * reaching the root `LViewData`.\n *\n * @param component any component\n */\nexport function getRootView(target: LViewData | {}): LViewData {\n  ngDevMode && assertDefined(target, 'component');\n  let lViewData = Array.isArray(target) ? (target as LViewData) : readPatchedLViewData(target) !;\n  while (lViewData && !(lViewData[FLAGS] & LViewFlags.IsRoot)) {\n    lViewData = lViewData[PARENT] !;\n  }\n  return lViewData;\n}\n\nexport function getRootContext(viewOrComponent: LViewData | {}): RootContext {\n  return getRootView(viewOrComponent)[CONTEXT] as RootContext;\n}\n\n/**\n * Returns the monkey-patch value data present on the target (which could be\n * a component, directive or a DOM node).\n */\nexport function readPatchedData(target: any): LViewData|LContext|null {\n  return target[MONKEY_PATCH_KEY_NAME];\n}\n\nexport function readPatchedLViewData(target: any): LViewData|null {\n  const value = readPatchedData(target);\n  if (value) {\n    return Array.isArray(value) ? value : (value as LContext).lViewData;\n  }\n  return null;\n}\n"]}